hash是在url上拼接/#url/，刷新页面不会有影响
history是直接改变url，刷新页面会有影响

对象查找自身属性时，如果找不到，就会通过_proto去构造函数的prototype上查找

箭头函数和普通函数的区别
没有自己的作用域，继承上层作用域的this，没有arguments

new操作符
创建一个对象
将改对象的_proto指向该函数的prototype

eventLoop
js是单线程，eventloop 宏任务和微任务 js在执行完所有同步任务后回去检查有没有微任务，如果有就先执行完，然后再去检查宏任务，执行完一个宏任务后再去检查微任务

输入一个url
dns解析，找到对应ip
三次握手四次挥手建立连接
从服务器请求资源 https
请求到html
dom tree，cssom tree  
render Tree
js 加载 加载完之后渲染页面

document.ready 和 DOMContentLoaded dom加载完毕
window.onload所有资源加载完毕

回流  位置或者大小发生发生改变
重绘  样式发生改变 重新绘制

js加载方式  defer  async

async 先加载完先执行
defer 一定是按照加载的顺序来

css加载不堵塞，构建堵塞
js加载和执行都堵塞，如果用defer是异步加载，等dom构建完执行，async也是异步加载，但是加载完就执行  

性能优化
cdn
http缓存
webpack构建 

react组件传值
父子组件传值
兄弟组件传值，可以让父组件来传
context                   
redux

水平垂直居中

flex: 1   flex-grow: 1  flex-shrink: 1  flex-basis: 0%
剩余空间占多少
压缩多少
算完flex-basis再根据剩余空间来分配，有剩余按照flex-grow，长度不够按照flex-shrink（flex-basis不是auto的时候会覆盖width，是auto的时候则是width生效）

border-box  标准盒模型  content = padding + 内容
content-box  content = 内容

什么是跨域
一个域名分为  https://www.baidu.com:8080/xxx.json
协议 子域名 主域名 端口号  资源地址
跨域方法：
跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script）就可以跨域，因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。

csrf其实就是一个跨域请求，但是他攻击你访问过的网站能带上对应的cookie，一般就是表单提交资源嵌入
大概过程就是：1.登陆www.A.com，浏览器有了cookie
            2.不小心访问了危险网站www.B.com,然后B发了一个请求给A，你这个请求的域名是www.A.com/xxxx，就是同源，所以能拿到A的cookie，然后就炸开了

cookie的同源策略  只要你请求某个域名，就会带上某个域名的cookie，可以用samesite去限制（就是跨域请求的时候不会带上cookie）

cookie属性 domain path http-only secure samesite  expires/max-age  name value

跨域 csrf cookie 彻底懂了 牛逼

jsonp 就是js手动生成一个script标签，src标签写入对应的接口，理论上就是拼接上一个callback，然后后端返回执行回调的内容，前端就会执行然后后端执行函数时的参数，前端就可以拿到
代理  webpack proxy
nginx
cors 服务器设置相应头  Access-Control-Allow-Origin   允许访问的域名
Access-Control-Allow-Method  允许访问的方法
Access-Control-Allow-Credentials  允许携带cookie
Access-Control-Max-Age  预检的存活时间
Access-Control-Allow-Headers  允许哪个头访问我
Access-Control-Expose-Headers  允许返回的头
postMessage

http有哪些请求 get post put delete head   
get和post的区别  get不安全，有大小限制
    常见状态码  get一般会有缓存，因为它是去服务器获取东西
    post不会有，因为它是去服务器改东西，缓存也没有意义

http缓存
强缓存和协商缓存
强缓存 看服务器返回的是expires/cache-control（max-age） 

协商缓存   last-modified/if-modified-since
          etag/if-none-match
          3xx 重定向  304协商缓存  没有更新
          4xx  400 客户端请求报文有语法错误  401 需要有通过 HTTP 认证  403 禁止访问   404 找不到  405 不允许使用改方法访问  access-control-allow-Methods
          500 服务端报错
web安全  csrf token  cookie samesite 

es6 常用方法
const/let  暂时性死区，let块级作用域
箭头函数

vue fiber是啥，为啥要有fiber，fiber的实现思路

vue使用 object.defineProperty 在 getter的时候进行依赖收集，将所有watcher对象的实例放到dep中
在setter的时候调用dep的notify方法通知内部所有的watcher对象调用对应的update进行视图更新

react15 协调器 和 渲染器 交替工作 递归
react16 可中断的循环过程  调度器  协调器  渲染器  
调度器和协调器之间  调度器调度优先级高的任务  
协调器负责找出需要更新的组件打上标记 然后交给渲染器

fiber是啥，fiber是纤程，是一种新的数据结构，更新时调度机制， 使得diff阶段可以被暂停

fiber算是链表吧  children，father， sibling

vue不需要fiber，因为vue可以精确更新，react自顶向下更新

vue diff和react diff的区别

react 从左到右
vue2  首尾交叉对比
vue3  首尾对比往中间收缩，最长递增子序列算法

react15 - 虚拟dom（是一颗普通的tree）- diff（生成一个新的tree对比）- 交给Renderer
react16 - 虚拟dom（fiber tree） -diff（生成一个新的tree对比）可以中断的过程 - 打上标记 - 然后交给renderer

算法排序  刷完了

react是什么
react是现在比较流行的js框架，不用手动操作dom，组件化，成熟的生态

react

节流防抖  throttle  debounce



必包
作用域
继承
变量提升
typescript（一问这个慌的像只鸡）
type和interface区别  type可以声明基本类型和联合类型  interface可以声明函数   
ts编程
react 
setState同步还是异步
setAge(1)
如何获取异步
webpack流程   
hook原理   
ahooks原理  
babel  
runtime  
qiankun
ssr  
umi   
微前端和iframe的区别

key为什么不能是index

react事件机制
react事件合成， onClick还是click，onChange变成change，blur，keydown，keyup
react事件绑定  原本的dom上会绑定一个noop函数，即空函数，document上会绑定真正的函数
react事件触发  冒泡到document，document上绑的是dispatchEvent，点击就是调用dispatchEvent
如何通过原生的dom找到对应的fiber对象，react初始化的时候，用一个随机的 key internalInstanceKey 
指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。

事件捕获  事件冒泡

react 在渲染fiberTree 的时候看到属性上的onclick事件，会先进

hook原理 嚼不动

useMemo，返回一个缓存的值
useCallback，返回一个缓存的callback

webpack构建过程
读取入口文件
调用loader编译文件
收集依赖，babel进行解析
生成chunk
输出

常用的loader  babel-loader url  file style css-loaded less  从右到左

webpack优化
optimization  文件压缩 treser-plugn
code-split  splitchunk
treeshaking

react-router  路由原理

vue和react的区别  
react函数式编程  vue不是
react推荐数据不可变immutable  vue直接改变原状态
react自上而下更新  vue精准更新

set, Map

ts子集还是子类 external 脚手架debugger qiankun底层原理 css样式命名规范 巨石应用 页面卡顿排查 vue 虚拟列表实现(interception.shenmegui)  npmlink  source-map  
localstorage   虚拟列表   离线缓存

key同package.json文件中的dependencies对象的key一样  
value第三方依赖编译打包后生成的js文件，然后js文件执行后赋值给window的全局变量名称

项目经历要搞一搞

js堵塞动画

垃圾回收机制

github项目

如何在脚手架中打包

如何分析打包的资源大小

async await原理

工作中遇到的问题   load chunk failed  微前端 样式隔离 css命名 和iframe区别  巨石应用构建问题  内存泄漏排查问题（memory，performance） nodejs断点

react hook原理  

eslint

umi