javascript
    js闭包  一个能够访问其他函数内部变量的函数
    最常见的方式  函数里面return一个新的函数

    闭包的弊端  内存泄漏，函数执行完之后，内部的变量应该被销毁，但是闭包使变量不会被销毁，从而造成内存泄漏
    闭包的作用  方法和属性的私有化


    this指向，到这个函数的直接调用位置

    由new调用：绑定到新创建的对象
    由call或apply、bind调用：绑定到指定的对象
    由上下文对象调用：绑定到上下文对象
    默认：全局对象

    箭头函数 继承外层函数调用的this绑定

    原型链 如果你有一个对象，你想使用一个它的属性，如果你找不到这个属性，就会_proto这个属性找到它的构造函数的protoType这个对象上去查找这个属性
    parent._proto = Parent.prototype;
    js中万物皆对象  分为普通对象和函数对象  普通对象的构造函数是Object，函数对象的构造函数是Function，原型链的顶端Object.prototype._proto = null

    继承 
    1.call apply  使用call或apply方法，将父对象的构造函数绑定在子对象上
    2.将构造函数的prototype执行要继承的构造函数的实例，然后改一下constructor
    3.将构造函数的prototype直接指向要继承的构造函数
    4.拷贝继承

    事件循环 eventLoop js是单线程，如果没有eventLoop就发生堵塞，执行栈执行为同步任务后，会去检查微任务队列是否为空，如果微任务队列不为空，就执行完所有的
    微任务，然后再去查看宏任务队列，执行完单个宏任务之后，再去检查微任务队列

    pwa 
    渐进式编程 
    网页只有两个线程，js线程和GUI渲染线程，这两个线程是互斥的，为了在高耗时js运算时，UI页面仍可用，得额外开辟一个js线程来运行这些高耗时的代码，这就是web worker

    前端如何解决跨域问题
    什么是跨域
    一个域名分为  https://www.baidu.com:8080/xxx.json
    协议 子域名 主域名 端口号  资源地址

    跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
    所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script）就可以跨域，
    因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。
    
    服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。感觉这个比较存疑，就不说了

    怎么解决跨域问题
    开发代理  什么是开发代理，利用webpack的proxy，或者是whistle之类的ip映射到域名上的操作
    jsonp  什么是jsonp，就是利用script标签可以跨域的原理，在服务端根据客户端传来的信息，查找数据库，然后返回一份可执行的javascript代码，客户端直接解析执行代码(因为是用script标签，所以返回来的javascript字符串就会被解析执行)，即调用 jsonpCallback() 函数，彻底懂了
    nginx代理跨域
    cors 服务器设置相应头  Access-Control-Allow-Origin   允许访问的域名
    Access-Control-Allow-Method  允许访问的方法
    Access-Control-Allow-Credentials  允许携带cookie
    Access-Control-Max-Age  预检的存活时间
    Access-Control-Allow-Headers  允许哪个头访问我
    Access-Control-Expose-Headers  允许返回的头

    网络安全
    xss攻击就是脚本跨站攻击
    存储型 XSS  存到数据库里，比如评论区留言，留言个<script>alert</script>
    反射型 XSS  服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
    dom型 XSS  url上面参数搞个<script>alert</script>，前端直接拿参数

    前端做转义  对一些标签<>等特殊字符进行转义，服务端检测url中是否带有恶意代码，比如javascript script
    ; const escapeChar = unsafe => {
    ;   return unsafe
    ;       .replace(/</g, '&lt;')
    ;       .replace(/>/g, '&gt;')
    ;       .replace(/"/g, '&quot;');
    ;   };
    避免使用  dangerouslySetInnerHTML

    csrf
    csrf其实就是一个跨域请求，但是他攻击你访问过的网站能带上对应的cookie，一般就是表单提交资源嵌入
    大概过程就是：1.登陆www.A.com，浏览器有了cookie
                2.不小心访问了危险网站www.B.com,然后B发了一个请求给A，你这个请求的域名是www.A.com/xxxx，就是同源，所以能拿到A的cookie，然后就炸开了

    怎么防止csrf
    同源检测，请求中在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
    Origin Header
    Referer Header
    这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。
    cookie的同源策略  只要你请求某个域名，就会带上某个域名的cookie，可以用samesite去限制（就是跨域请求的时候不会带上cookie）
    cookie属性 domain path http-only secure samesite  expires/max-age  name value
    使用token，不用cookie

    为什么csrf其实是跨域请求，那却能成功，因为我们要正确的理解跨域请求是什么
    跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
    所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script）（csrf）就可以跨域，
    因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。

    web worker 
      new worker(url)
      message和postMessage
      只服务于注册它的页面，不同页面之间不能共享
      页面关闭时，该页面新建的web worker也会关闭，不会留在浏览器中

    service worker 问到代码实现可能直接扑街
      navigator.register(url)
      不同页面之间可以共享，遵从同源策略
      注册的页面关闭也不会中断，会长留在浏览器中

    es6有哪些用过的语法
    const, let 暂时性死区，没有声明之前不能先使用
    箭头函数  继承外层函数调用的this绑定
    promise
    async await
    class
    Map，Set  
    Set是一种叫做无序且唯一集合的数据结构，使用场景 数组去重
    Map是一种叫做字典的数据结构，使用场景 数据存储  键值对存储的方式  Map的key可以是任意值

    WeakSet和set类似，也是不重复的值的集合，区别
      WeakSet 的成员只能是对象，而不能是其他类型的值
      WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
      应用场景：储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。用set或者其他数组之类的就不行，比如一个场景，你定义一个set去存储dom节点，如果这两个dom节点被删掉了，你需要手动把
      set dom的引用手动删除掉，如果你用weakSet，删除dom的时候便会自动删除

    WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。

    WeatMap和Map类似
      WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
      WeakMap的键名所指向的对象，不计入垃圾回收机制。
      应用场景：WeakMap 应用的典型场合就是 DOM 节点作为键名

      let myWeakmap = new WeakMap();
    ​
      myWeakmap.set(
       document.getElementById('logo'),
        {timesClicked: 0})
      ;
      ​
      document.getElementById('logo').addEventListener('click', function() {
       let logoData = myWeakmap.get(document.getElementById('logo'));
       logoData.timesClicked++;
      }, false);

    这里这个dom要是被清掉了，那weakMap中这个对象就没了

    因为WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历

    WeakMap  

    Symbol 是一种原始数据类型，表示独一无二的值。当你需要一个独一无二的值，就不需要去声明一些奇怪的字符串，可以用symbol代替，不说了，有点傻逼

css篇

react篇
    react是什么，为什么要用react  react是前端现在比较流行的一个js库，不用手动操作dom，组件化，有成熟的生态

    react生命周期
    初始化阶段 
    comopnentwillmount（getDerivedStateFromProps）
    render
    compnoentDidmount

    更新阶段
    componentWillReceiveProps(getDerivedStateFromProps)
    shouldComponentUpdate
    componentWillUpdate(废弃)
    render
    componentDidUpdate

    卸载阶段
    componentWillUnMount(getSnapshotBeforeUpdate)

    react setState之后会发生什么
    react会重新生成整个vdom，在react15中，会将老的vdom 和 新的vdom递归去比较，遍历递归子节点， 调和阶段 reconciler， 然后会到 rerender阶段，
    reconciler和rerender之前是交替工作的，如果你中途中断的话，会看到更新不完全的dom

    react16使用了新的fiber架构，react15在reconciler是递归处理虚拟dom的，react16的reconciler是可中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。
    react16还多了一个Scheduler调度器，当浏览器有剩余时间时通知我们，同时调度任务的优先级，高优任务优先进入Reconciler，react15中reconciler和rerender之前是交替工作的，
    react16 Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，整个Scheduler与Reconciler
    的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

    react16是如何更新dom的
    Fiber节点构成的Fiber树就对应DOM树，在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。
    （而在重新协调构建新的 Fiber 树的过程也就是 React Diff 发生的地方）
    对比然后更新

    什么是fiber架构
    fiber 架构是 React 在 16 以后引入的，之前是直接递归渲染 vdom，现在则是多了一步 vdom 转 fiber 的 reconcile，在 reconcile 
    的过程中创建 dom 和做 diff 并打上增删改的 effectTag，然后一次性 commit。这个 reconcile 是可被打断的，可以调度，也就是 fiber 的 schedule。
    每个节点由三个属性，children，return和sibling，是一个树状链表，每次中断都可以通过这个三个属性去继续更新

    react setState是同步还是异步
    react 16,17 
    在合成事件和钩子函数中是异步的，在原生和setTimeout中不是批量异步的
    异步不是说像setTimeout和Promise的那种异步，而是调用顺序的问题，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值
    react 18 全部是异步批量更新

    react setState为什么有时是同步的，有时是异步的，其实和react的事件机制有关，react有一个legacy 事件处理系统，batchedEventUpdates为批量更新的主要函数，
    React通过开关isBatchingEventUpdates来控制是否启用批量更新。但是如果是发生在setTimeout中,由于eventLoop 放在了下一次事件循环中执行，此时 batchedEventUpdates 中已经执行完isBatchingEventUpdates = false，
    所以批量更新被打破，我们就可以直接访问到最新变化的值了。

    react事件机制
    react事件合成， onClick还是click，onChange变成change，blur，keydown，keyup
    react事件绑定  原本的dom上会绑定一个noop函数，即空函数，document上会绑定真正的函数
    react事件触发  大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如scroll事件），冒泡到document，document上绑的是dispatchEvent，点击就是调用dispatchEvent，
    如何通过原生的dom找到对应的fiber对象，react初始化的时候，用一个随机的 key internalInstanceKey 
    指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。


    1 我们写的事件是绑定在dom上么，如果不是绑定在哪里？   不是，是绑定在document上的
    2 为什么我们的事件不能绑定给组件？  
    3 为什么我们的事件手动绑定this(不是箭头函数的情况)
    4 为什么不能用 return false 来阻止事件的默认行为？  合成事件中React 会对大多数事件执行用的 document.addEventListener()，所以不能用return false，需要用e.preventDefault()
    5 react怎么通过dom元素，找到与之对应的 fiber对象的？  React 在初始化真实 dom 的时候，用一个随机的 key internalInstanceKey 指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。
    6 onClick是在冒泡阶段绑定的？ 那么onClickCapture就是在事件捕获阶段绑定的吗？   是。 不是。 捕获是在事件插件系统的核心extractEvents中模拟的。

    hooks原理
    fiber tree上每个fiber节点都放了一个memorizeState去存储hook信息，是一个通过next串联的链表，这就是不能在if判断语句中使用hooks的原因

    useRef  将传进来的value包装成了一个拥有current属性的对象，冻结了一下，并将其放在memorizeState上， update ref还是返回原来的对象
    useCallback memorizeState存储了一个数组，一个是传入的回调函数，一个是传入的dep，会将dep进行比较

    useEffect 的 hook 在 render 阶段会把 effect 放到 fiber 的 updateQueue 中，这是一个  lastEffect.next 串联的环形链表
    ，然后 commit 阶段会异步执行所有 fiber 节点的 updateQueue 中的 effect。
    useLayoutEffect 和 useEffect 差不多，区别只是它是在 commit 阶段的 layout 阶段同步执行所有 fiber 节点的 updateQueue 中的 effect。
    因为useEffect是在react组件render之后才会执行，所以在useEffect获取的状态一定是最新的

    useState 同样分为 mountState 和 updateState 两个阶段：
    mountState 会返回 state 和 dispatch 函数，dispatch 函数里会记录更新到 hook.queue，然后标记当前 fiber 到根 fiber 的 lane 需要更新，之后调度下次渲染。
    再次渲染的时候会执行 updateState，会取出 hook.queue，根据优先级确定最终的 state 返回，这样渲染出的就是最新的结果。

    react和vue的区别
    模版不同
    react组件直接import，vue需要注册
    react推崇函数式，immutable，数据不可变
    vue不需要fiber，因为vue可以精确更新（因为它的观察者模式，vue使用 object.defineProperty 在 getter的时候进行依赖收集，将所有watcher对象的实例放到dep中
    在setter的时候调用dep的notify方法通知内部所有的watcher对象调用对应的update进行视图更新），react自顶向下更新
    vue是数据可变的，双向绑定，声明式的写法

    vue diff和react diff的区别
    react 从左到右
    vue2  首尾交叉对比
    vue3  首尾对比往中间收缩，最长递增子序列算法

    react受控组件与非受控组件  可以通过value和onchange去控制的组件，比如一个input框，选中失焦效果，这种就是非受控

    什么情况下要使用hooks，有些过哪些自定义hooks
    和状态有关系可以封装成一个hooks，useScroll下拉加载

    react有用过哪些hooks，useState，useMemo, useCallback, useEffect, useReducer, useLayoutEffect
    useMemo可以返回一个缓存过的值， useCallback返回一个缓存过的回调函数，搭配React.memo做性能优化
    useLayoutEffect 和 useEffect

    用户点击事件，改变了某一个state
    React 内部更新 state 变量
    React 处理更新组件中 return 出来的 DOM 节点（进行一系列 diff 调度等流程）
    将更新过后的 DOM 数据绘制到浏览器中
    用户看到新的页面

    那这时候的 useEffect 只会在render之后才会调用，也就是在浏览器绘制完后才调用，而且 useEffect 还是异步执行的，所谓的异步就是被 React 使用 requestIdleCallback 封装的，
    只在浏览器空闲时候才会执行，这就保证了不会阻塞浏览器的渲染过程。

    useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题　
    useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。

    而 useLayoutEffect 就不一样，它会在render之前执行，而且是同步阻塞后面的流程。

    useReducer  const [state, dispatch] = useReducer();
    使用场景，但你一个操作需要更新多个state时，可以使用reducer，虽然useState可以放多个属性在一个状态里，但推荐你在一个 state 里放太多东西，因为它不会合并 state，用起来不方便

    react高阶组件  其实就是一个函数，返回一个增强过的组件，可以用来做组件复用

    为什么用hooks不用class component或者类组件

    1.1 虽然React一直提倡的是我们能够函数组件，但是当我们发现函数组件中需要状态时，我们可能不得不将其改变成类组件
    1.2 在使用类组件时，我们不得不去通过箭头函数或者bind去绑定，而这又是比较消耗性能
    1.3 复杂的生命周期
    1.4 在复用组件时，难免要使用render Props或者HOC，这会使代码结构看起来极其复杂，HOC会让组件之间更多的嵌套

    key为什么不能是index  当同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在当前层级的位置发生了变化后。react diff算法通过新旧节点比较后，
    如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。这无疑大大提高了React性能和渲染效率，
    但是如果key是index，如果出现顺序调换的问题，key值还是原来的key值，就不会进行移动操作，导致无法更新

    react diff算法是怎么样的
    如果是新的虚拟dom是单个节点，那就是直接去老的fiber里遍历，如果key相同，type相同，就搭上update标签，删掉其他的
    如果key不同，继续找下一个

    如果新的虚拟dom是多个节点，那就先进入第一轮遍历，遍历的时候一一对应，如果不能复用，就立马跳出第一轮循环，进入第二轮循环，
    将剩余的老fiber放入一个以老fiberkey或者索引为key，value为fiber节点的Map中，然后遍历新dom到map中去找有没有可以复用的节点，
    找到了就给这个节点看这个节点的索引值是否大于lastplaceIndex，如果大就把lastplaceIndex置为这个fiber的索引，然后从map中删除该节点
    如果小于lastPlaceIndex，就打上移动的标签，其实就是插入，插到老fiber的最后面，最后看老fiberMap中有剩余节点就删掉，新dom中在老fiber
    找不到的就插入