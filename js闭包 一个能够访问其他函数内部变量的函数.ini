javascript
    js闭包  一个能够访问其他函数内部变量的函数
    最常见的方式  函数里面return一个新的函数

    闭包的弊端  内存泄漏，函数执行完之后，内部的变量应该被销毁，但是闭包使变量不会被销毁，从而造成内存泄漏
    闭包的作用  方法和属性的私有化

    this指向，到这个函数的直接调用位置

    由new调用：绑定到新创建的对象
    由call或apply、bind调用：绑定到指定的对象
    由上下文对象调用：绑定到上下文对象
    默认：全局对象

    箭头函数 继承外层函数调用的this绑定

    原型链 如果你有一个对象，你想使用一个它的属性，如果你找不到这个属性，就会_proto这个属性找到它的构造函数的protoType这个对象上去查找这个属性
    parent._proto = Parent.prototype;
    js中万物皆对象  分为普通对象和函数对象  普通对象的构造函数是Object，函数对象的构造函数是Function，原型链的顶端Object.prototype._proto = null

    继承 
    1.call apply  使用call或apply方法，将父对象的构造函数绑定在子对象上
    2.将构造函数的prototype执行要继承的构造函数的实例，然后改一下constructor
    3.将构造函数的prototype直接指向要继承的构造函数
    4.拷贝继承

    事件循环 eventLoop js是单线程，如果没有eventLoop就发生堵塞，执行栈执行为同步任务后，会去检查微任务队列是否为空，如果微任务队列不为空，就执行完所有的
    微任务，然后再去查看宏任务队列，执行完单个宏任务之后，再去检查微任务队列

    pwa 
    渐进式编程 
    网页只有两个线程，js线程和GUI渲染线程，这两个线程是互斥的，为了在高耗时js运算时，UI页面仍可用，得额外开辟一个js线程来运行这些高耗时的代码，这就是web worker

    web worker 
      new worker(url)
      message和postMessage
      只服务于注册它的页面，不同页面之间不能共享
      页面关闭时，该页面新建的web worker也会关闭，不会留在浏览器中

    service worker 问到代码实现可能直接扑街
      navigator.register(url)
      不同页面之间可以共享，遵从同源策略
      注册的页面关闭也不会中断，会长留在浏览器中

    前端如何解决跨域问题
    什么是跨域
    一个域名分为  https://www.baidu.com:8080/xxx.json
    协议 子域名 主域名 端口号  资源地址（这个不同不算跨域哈）
    baidu.com 主域名（一级域名）  www.baidu.com 子域名（二级域名）

    跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
    所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script）就可以跨域，
    因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。
    
    服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。感觉这个比较存疑，就不说了

    怎么解决跨域问题
      开发代理  什么是开发代理，利用webpack的proxy，或者是whistle之类的ip映射到域名上的操作
      jsonp  什么是jsonp，就是利用script标签可以跨域的原理，在服务端根据客户端传来的信息，查找数据库，然后返回一份可执行的javascript代码，
      客户端直接解析执行代码(因为是用script标签，所以返回来的javascript字符串就会被解析执行)，即调用 jsonpCallback() 函数，彻底懂了
    nginx代理跨域  反向代理


    cors 服务器设置相应头  好像前三个是一定要设置的
    Access-Control-Allow-Origin   允许访问的域名
    Access-Control-Allow-Method  允许访问的方法
    Access-Control-Allow-Headers  允许哪个头访问我
    Access-Control-Allow-Credentials  允许携带cookie
    Access-Control-Max-Age  预检的存活时间
    Access-Control-Expose-Headers  允许返回的头

    网络安全
    xss攻击就是脚本跨站攻击
    存储型 XSS  存到数据库里，比如评论区留言，留言个<script>alert</script>
    反射型 XSS  服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
    dom型 XSS  url上面参数搞个<script>alert</script>，前端直接拿参数

    前端做转义  对一些标签<>等特殊字符进行转义，服务端检测url中是否带有恶意代码，比如javascript script
    ; const escapeChar = unsafe => {
    ;   return unsafe
    ;       .replace(/</g, '&lt;')
    ;       .replace(/>/g, '&gt;')
    ;       .replace(/"/g, '&quot;');
    ;   };
    避免使用  dangerouslySetInnerHTML

    csrf
    csrf其实就是一个跨域请求，但是他攻击你访问过的网站能带上对应的cookie，一般就是表单提交资源嵌入
    大概过程就是：1.登陆www.A.com，浏览器有了cookie
                2.不小心访问了危险网站www.B.com,然后B发了一个请求给A，你这个请求的域名是www.A.com/xxxx，就是同源，所以能拿到A的cookie，
                然后就炸开了

    怎么防止csrf
    同源检测，请求中在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
    Origin Header
    Referer Header
    这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。
    cookie的同源策略  只要你请求某个域名，就会带上某个域名的cookie，可以用samesite去限制（就是跨域请求的时候不会带上cookie）
    cookie属性 domain path http-only secure samesite  expires/max-age  name value
    使用token，不用cookie

    为什么csrf其实是跨域请求，那却能成功，因为我们要正确的理解跨域请求是什么
    跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
    所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script）（csrf）就可以跨域，
    因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。

    es6有哪些用过的语法
    const, let 暂时性死区，没有声明之前不能先使用
    箭头函数  继承外层函数调用的this绑定
    promise
    async await
    class
    Map，Set  
    Set是一种叫做无序且唯一集合的数据结构，使用场景 数组去重
    Map是一种叫做字典的数据结构，使用场景 数据存储  键值对存储的方式  Map的key可以是任意值

    WeakSet和set类似，也是不重复的值的集合，区别
      WeakSet 的成员只能是对象，而不能是其他类型的值
      (Set里面的值可以是数组，只要是有iterable接口的数据接口，比如new Set([1,2,3]), 但是这里weakSet的值只能是对象，比如
      let ws = new WeakSet() ws.add({name: 'zzp'});)
      WeakSet 中的对象都是弱引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
      应用场景：储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。用set或者其他数组之类的就不行，比如一个场景，
      你定义一个set去存储dom节点，如果这两个dom节点被删掉了，你需要手动把
      set dom的引用手动删除掉，如果你用weakSet，删除dom的时候便会自动删除

      let obj1 ={name:"leslie1"};
      let obj2 ={name:"leslie2"};
      let ws = new WeakSet();
      let s = new Set();
      ws.add(obj1);
      s.add(obj2)
      // console.log(ws);
      // console.log(s);
      obj1=null;
      obj2=null;
      console.log(ws);  WeakSet里没有obj1了
      console.log(s);  Set里还有obj2

    WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。

    WeatMap和Map类似
      WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
      WeakMap的键名所指向的对象，不计入垃圾回收机制。
      应用场景：WeakMap 应用的典型场合就是 DOM 节点作为键名

      let myWeakmap = new WeakMap();
    ​
      myWeakmap.set(
       document.getElementById('logo'),
        {timesClicked: 0})
      ;
      ​
      document.getElementById('logo').addEventListener('click', function() {
       let logoData = myWeakmap.get(document.getElementById('logo'));
       logoData.timesClicked++;
      }, false);

    这里这个dom要是被清掉了，那weakMap中这个对象就没了

    因为WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历

    WeakMap  

    Symbol 是一种原始数据类型，表示独一无二的值。当你需要一个独一无二的值，就不需要去声明一些奇怪的字符串，可以用symbol代替，不说了，有点傻逼
    Symbol.for  typeof 就是用的symbol

    js数组别忘了哟
    1.1 push  往数组的最后加入元素，改变原数组，返回新数组的长度
    1.2 unshift 往数组的开头加入元素，改变原数组，返回新数组的长度  
    1.3 pop 删除数组的最后一个元素，改变原数组，返回被删除的元素
    1.4 shift 删除数组的第一个元素，改变原数组，返回被删除的元素
    1.5 splice(index, count, value1, value2...) 删除数组中某个元素，改变原数组
    1.6 slice(start, end) 获取子数组，包含原数组索引start的值到索引end的值，不包含end，返回获取的子数组，不改变原数组

    canvas  动画堵塞
    用过canvas 大概说一下画一个canvas的过程
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    // 清除画布
    ctx.clear();

    // 绘制直线
    ctx.moveTo(50, 50);
    ctx.lineTo(200, 200);
    ctx.stroke();

    // 绘制一个三角形
    ctx.moveTo(50, 50);
    ctx.lineTo(200, 200);
    ctx.lineTo(200, 50);
    ctx.lineTo(50, 50);
    ctx.stroke();

    // 绘制一个矩形边框
    ctx.strokeRect(50, 50, 200, 100);

    // 绘制一段圆弧
    ctx.arc(60, 60, 50, 0, Math.PI, false);
    ctx.stroke();

    // 画出一个半圆和一个整圆，关闭路径就不会连接起来
    ctx.beginPath() // 开启路径
    ctx.arc(60, 60, 50, 0, Math.PI, false);
    ctx.stroke();
    ctx.closePath() // 闭合路径
    // 绘制一个圆弧
    ctx.beginPath() // 开启路径
    ctx.arc(200, 60, 50, 0, Math.PI*2, false);
    ctx.stroke();
    ctx.closePath() // 闭合路径

    // 绘制椭圆
    ctx.ellipse(100, 150, 50, 100, 0, 0, 2 * Math.PI);
    ctx.stroke();

    // 贝塞尔曲线，其实就是画不规则的曲线，不是只能画圆


    // 二次贝塞尔曲线，只能弯曲一次的曲线
    ctx.moveTo(50, 50);
    // quadraticCurveTo(cp1x, cp1y, x, y)，其中cp1x和cp1y为一个控制点，x和y为结束点。
    ctx.quadraticCurveTo(200, 200, 350, 50);
    // 绘制
    ctx.stroke();

    //三次贝塞尔曲线，能弯曲两次的曲线
    ctx.moveTo(50, 200);
    // ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x, y)，其中cp1x和cp1y为一个控制点，cp2x和cp2y为第二个控制点，x和y为结束点。
    ctx.bezierCurveTo(150, 50, 250, 350, 350, 200);
      // 绘制
    ctx.stroke();

    多次弯曲曲线，两条三次贝塞尔曲线拼起来就ok啦，只要不closepath就会连接起来，太牛逼了
    ctx.beginPath();
    ctx.moveTo(50, 50); // 起点位置
    ctx.bezierCurveTo(80, 0, 120, 100, 150, 50); // 前半段控制点和终点位置
    ctx.bezierCurveTo(180, 0, 220, 100, 250, 50); // 后半段控制点和终点位置
    ctx.stroke();

    svg

    // 画圆
    <svg>
      <circle cx="100" cy="100" r="100"/>  坐标，半径
    </svg>

    // 矩形
    <svg width="300" height="300">
      <rect x="0" y="0" rx="5" ry="5" width="300" height="200"/>
    </svg>

    // 椭圆
    <svg width="300" height="300">
      <ellipse cx="100" cy="100" rx="100" ry="50"/>
    </svg>

    // 画直线，这个比canvas简单
    <svg width="300" height="300">
      <!-- 不设置样式属性 style 是看不出效果的 -->
      <line x1="50" x2="50" y1="200" y2="50" style="stroke: #000000;"/>
    </svg>

    // 画折现，和canvas画三角形一个原理
    <svg width="300" height="300">
      <!-- 不设置样式属性style是看不出效果的 并且polyline默认为填充需要把fill属性设置为none -->
      <polyline points="0 0, 20 40, 70 80, 100 90, 200 30, 250 50" fill="none" style="stroke: #000000;" />
    </svg>

    // 多边形 polygon标签和polyline标签类似，都是由很多个点链接在一起的。但不同的是polygon路径中的最后一个点和第一个点是默认闭合的。
    <svg width="300" height="300">
      <!-- 不设置样式属性style是看不出效果的 并且polygon默认为填充需要把fill属性设置为none -->
      <polygon points="0 0, 20 40, 70 80, 100 90, 200 30, 250 50" fill="none" style="stroke: #000000;" />
    </svg>

    // path 路径  这个玩法和canvas的path差不多啊，Z表示是否闭合路径
    M = Move to
    L = Line to
    H = Horizontal Line to
    V = Vertical Line to
    Q = Quadratic Bezier Curve to  二次贝塞尔曲线
    T = Smooth Quadratic Bezier Curve to
    C = Curve to  三次贝塞尔曲线
    S = Smooth Curve to
    A = Elliptical Arc
    Z = close path

    <!-- 从起始点（50， 20）画一条到（250， 20）的直线 -->
    <path d="M50 20 L250 20" style="stroke: #000000;"/>

    <!-- 从起始点（50， 20）画一条X轴为250的水平直线 -->
    <path d="M50 20 H250" style="stroke: #000000;"/>

    <!-- 从起始点（50， 20）画一条Y轴为250的垂直直线 -->
    <path d="M50 20 V250" style="stroke: #000000;"/>

    注意连续的H命令和V命令取大值，200生效
    <path d="M50 20 H200 100" style="stroke: #000000;"/>
    <path d="M50 20 V200 100" style="stroke: #ff0000;"/>

    Z命令是一个闭合命令，他会从当前点画一条直线到路径的起始点。
    Z命令因为没有参数所以Z和z效果一样，所以不区分大小写，
    和canvas的closePath一个意思
    <path d="M50 20 H200 V200 Z" fill="none" style="stroke: #000000;"/>  

    Q x1 y1, x y 或者 q x1 y1, x y
    参数：x、y为终点位置，x1、y1为控制点。
    <path d="M50 100 Q 175 200 300 100" fill="none" style="stroke: #ff0000;"/> 

    svg和canvas对比
    优点：
    svg与其他图片格式对比
    SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。
    SVG 支持文本渲染
    SVG可在图像质量不下降的情况下被放大和缩小
    svg可以通过可以通过css和js来控制，比如事件监听，css修改样式

    缺点：
    SVG复杂度越高渲染速度就会越慢，在处理大型或复杂的图像时，SVG 可能会变得缓慢或卡顿。（任何过度使用DOM的应用都不快）
    SVG不适合游戏应用，只能结合Canvas来实现
    与 Canvas 相比，使用 SVG 可能需要更多的代码和工作量来实现相同的效果。

    canvas

    优点:
    处理大型或复杂的图像时性能更好

    缺点:
    位图，不能缩放
    不支持文本渲染
    Canvas 不支持添加交互元素和动画效果，因此无法提供与 SVG 相同的用户体验。

css篇
    bfc  什么是bfc，块级格式化上下文
      如何生成BFC
      1、float：设置浮动
      2、overflow：auto，hidden
      3、position：设置absolute或者fixed
      4、display：inline-block、flex、inline-flex、table-cell、table-caption、


    权重
    flex: 1   flex-grow: 1  flex-shrink: 1  flex-basis: 0%
    剩余空间占多少
    压缩多少
    算完flex-basis再根据剩余空间来分配，有剩余按照flex-grow，长度不够按照flex-shrink（flex-basis不是auto的时候会覆盖width，是auto的时候则是width生效）

    css3新特性
      背景
      渐变
      转换和变形
      动画：keyframes，过渡：transition

      @keyframes slidein {
          from { transform: translateX(-100%); }
          to { transform: translateX(0); }
      }

      @keyframes fadeout {
          from { opacity: 1; }
          to { opacity: 0; }
      }

      div.slidein {
          animation-name: slidein;
          animation-duration: 2s;
      }

      p.fadeout {
          animation-name: fadeout;
          animation-duration: 1s;
          animation-delay: 2s;
      }

      媒体查询

    移动端方案
      淘宝方案  1rem等于根元素字体大小 缺点 字体也会跟着缩放  移动端方案
      const oHtml = document.getElementsByTagName('html')[0]
      const width = oHtml.clientWidth;
      // 320px的屏幕基准像素为12px
      oHtml.style.fontSize = 12 * (width / 320) + "px";

      一行css适配rem
      750是设计稿的宽度：之后的单位直接1:1使用设计稿的大小，单位是rem
      html{ font-size: calc(100vw / 750); }

      vw, vh  100vw就是整个屏幕大小，什么叫dpi，苹果的屏幕的1px相当于两2px，所以出图的话是乘以2出的
      不然图片放到苹果上面会模糊，自己要将像素除以2，除非是矢量图，就不会模糊，不然会模糊

      2倍图，3倍图

    scss 语法 &-  var.scss

react篇
    react是什么，为什么要用react  react是前端现在比较流行的一个js库，不用手动操作dom，组件化，有成熟的生态

    react生命周期
    初始化阶段 
    comopnentwillmount(废弃警告)（getDerivedStateFromProps）
      当父组件传递给子组件的props发生变化时，子组件可以通过getDerivedStateFromProps方法更新自己的state，以便重新渲染。
      
      很简单，就是更新的时候跑不到constructor里面去，就可以用这个getDerivedStateFromProps，以前我也用过componentWillReceiveProps
      实现过类似的功能

      constructor(props) {
        super(props);
        this.state = { count: props.value };
      }
      static getDerivedStateFromProps(props, state) {
        if (props.value !== state.count) {
          return { count: props.value };
        }
        return null;
      }
      static不能访问this

    render
    componentDidmount

    更新阶段
    componentWillReceiveProps(废弃警告)(getDerivedStateFromProps)
    shouldComponentUpdate(nextProps, nextState)
    componentWillUpdate(废弃警告)
    render
    getSnapshotBeforeUpdate

    getSnapshotBeforeUpdate是一个在组件更新（即state或props发生变化）之后、
      它的返回值将作为componentDidUpdate方法的第三个参数传递进来。在 render 之后，即将对组件进行挂载时调用。
      理解getSnapshotBeforeUpdate的最常见应用场景是：当组件的某些 DOM 节点在更新前后发生了变化，我们需要获取这些变化前后的状态并进行一些操作。
      下面是一个例子，假设我们有一个聊天室应用，其中有一个聊天记录组件：

      class ChatLog extends React.Component {
        constructor(props) {
          super(props);
          this.chatLog = React.createRef();
        }

        getSnapshotBeforeUpdate(prevProps) {
          // 当消息列表发生变化时，获取当前滚动位置并保存
          if (prevProps.messages.length < this.props.messages.length) {
            const chatLog = this.chatLog.current;
            return chatLog.scrollHeight - chatLog.scrollTop;
          }
          return null;
        }

        componentDidUpdate(prevProps, prevState, snapshot) {
          // 当更新完成后，将滚动位置调整到之前保存的位置
          if (snapshot !== null) {
            const chatLog = this.chatLog.current;
            chatLog.scrollTop = chatLog.scrollHeight - snapshot;
          }
        }

        render() {
          return (
            <div className="chat-log" ref={this.chatLog}>
              {this.props.messages.map((message, index) => (
                <div key={index} className="message">
                  <div className="username">{message.username}</div>
                  <div className="content">{message.content}</div>
                </div>
              ))}
            </div>
          );
        }
      }

      export default ChatLog;
      
      在这个例子中，我们在组件的constructor方法中创建了一个ref，
      用来引用聊天记录组件的DOM节点。在getSnapshotBeforeUpdate方法中，
      我们判断了聊天记录组件的消息列表是否发生变化，如果是的话，我们就获取当前的滚动位置并保存。
      在componentDidUpdate方法中，我们将滚动位置调整到之前保存的位置。

      这样，当我们向聊天室中发送一条新消息时，聊天记录组件的高度将发生变化，
      getSnapshotBeforeUpdate方法将获取当前的滚动位置并保存，
      componentDidUpdate方法将滚动位置调整到之前保存的位置，从而实现了更好的用户体验。

    componentDidUpdate

    卸载阶段
    componentWillUnMount

    错误捕获
    static getDerivedStateFromError 在errorBoundary中使用，子组件崩溃了的情况（就是子组件的render报错了，子组件的dom都没了的那种
    ）会进到这个生命周期，你可以在这个生命周期返回hasError: true，如果hasError是true
    返回错误信息，是false，正常返回this.props.childrenss，注意：错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。
    生命周期和构造函数中 throw new Error也能捕获到

    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }

      static getDerivedStateFromError(error) {
        // 更新 state 使下一次渲染能够显示降级后的 UI 
        return { hasError: true };
      }

      componentDidCatch(error, errorInfo) {
        // 你同样可以将错误日志上报给服务器
        console.log(error, 'error');
        console.log(errorInfo, 'errorInfo');
      }

      render() {
        if (this.state.hasError) {
          // 在 render 函数中显示出错信息
          return <h1>Something went wrong.</h1>;
        }

        return this.props.children;
      }
    }

    class MyComponent extends React.Component {
      constructor(props) {
        super(props);
        this.state = { count: { num: 0 } };
        this.handleClick = this.handleClick.bind(this);
      }

      handleClick() {
        // 制造一个错误
        this.setState({ count: 1 });
      }

      render() {
        console.log(this.state.count, 'this.state.count');  
        return (
          <div>
            <h1>Count: {this.state.count.num.sth}</h1>
            <button onClick={this.handleClick}>Click Me</button>
          </div>
        );
      }
    }

    function App() {
      return (
        <ErrorBoundary>
          <MyComponent />
        </ErrorBoundary>
      );
    }

    export default App;

    componentDidCatch

    错误边界无法捕获以下场景中产生的错误：
      事件处理  比如点击事件中抛个error，自己用try。。。catch兜了
      异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）, 生命周期中使用就不行了，但是setTimeout setState可以
      服务端渲染
      它自身抛出来的错误（并非它的子组件）
    
    为什么要使用fiber架构
    react16使用了新的fiber架构，react15在reconciler是递归处理虚拟dom的，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，
    造成卡顿。
    react16的reconciler是可中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。
    react16还多了一个Scheduler调度器，当浏览器有剩余时间时通知我们，同时调度任务的优先级，高优任务优先进入Reconciler，
    react15中reconciler和rerender之前是交替工作的，
    react16 Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，整个
    Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

    什么是fiber架构
    React16的Reconciler基于Fiber节点实现， fiber 架构是 React 在 16 以后引入的，之前是直接递归渲染 vdom，
    现在则是多了一步 vdom 转 fiber 的 reconcile，在 reconcile 
    的过程中创建 dom 和做 diff 并打上增删改的 effectTag，然后一次性 commit。这个 reconcile 是可被打断的，
    可以调度，也就是 fiber 的 schedule。
    fiber 节点由三个属性，children，return和sibling，是一个树状链表，每次中断都可以通过这个三个属性去继续更新
    作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
    作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

    react setState是同步还是异步
    react 16,17 
    在合成事件和钩子函数中是异步的，在原生和setTimeout中不是批量异步的
    异步不是说像setTimeout和Promise的那种异步，而是调用顺序的问题，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马
    拿到更新后的值
    react 18 createRoot全部是异步批量更新  

    const container = document.getElementById('root');
    const root = createRoot(container);
    const element1 = <MyComponent1 />;
    const element2 = <MyComponent2 />;
    root.render(element1, element2);

    react setState为什么有时是同步的，有时是异步的，其实和react的事件机制有关，react有一个legacy事件处理系统，
    batchedEventUpdates为批量更新的主要函数，
    React通过开关isBatchingEventUpdates来控制是否启用批量更新。但是如果是发生在setTimeout中,由于eventLoop 放在了下一次事件循环中执行，
    此时 batchedEventUpdates 中已经执行完isBatchingEventUpdates = false，所以批量更新被打破，我们就可以直接访问到最新变化的值了。

    react16事件机制
    react事件合成， onClick还是click，onChange变成change，blur，keydown，keyup
    react事件绑定  原本的dom上会绑定一个noop函数，即空函数，document上会绑定真正的函数  
    // document.addEventListener('click',listener,false)
    react事件触发  大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如scroll事件），冒泡到document，
    document上绑的是dispatchEvent，点击就是调用dispatchEvent

    /* 获取原生事件 e.target */
    const nativeEventTarget = getEventTarget(nativeEvent)
    /* 获取当前事件，最近的dom类型fiber ，我们 demo中 button 按钮对应的 fiber，我的理解应该是从fiber找到要执行的事件，
    fiber对象上的memoizedProps 和 pendingProps保存了我们的事件 */
    let targetInst = getClosestInstanceFromNode(nativeEventTarget); 
    /* 重要：进入legacy模式的事件处理系统 */
    dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst);

    如何通过原生的dom找到对应的fiber对象，react初始化的时候，用一个随机的 key internalInstanceKey 
    指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。

    react17
    1 事件统一绑定container上，ReactDOM.render(app， container)，而不是document上，这样好处是有利于微前端的，
    微前端一个前端系统中可能有多个应用，
    如果继续采取全部绑定在document上，那么可能多应用下会出现问题。
    2 取消事件池 React 17 取消事件池复用

    react为什么要用这种事件合成模式呢
    一方面，将事件绑定在document统一管理，防止很多事件直接绑定在原生的dom元素上。造成一些不可控的情况，比如批量更新
    另一方面， React 想实现一个全浏览器的框架， 为了实现这种目标就需要提供全浏览器一致性的事件系统，以此抹平不同浏览器的差异。

    1 我们写的事件是绑定在dom上么，如果不是绑定在哪里？   不是，是绑定在document上的
    2 为什么我们的事件不能绑定给组件？  
    3 为什么我们的事件手动绑定this(不是箭头函数的情况)
    4 为什么不能用 return false 来阻止事件的默认行为？  
    合成事件中React 会对大多数事件执行用的 document.addEventListener()，
    所以不能用return false，需要用e.preventDefault()
    5 react怎么通过dom元素，找到与之对应的 fiber对象的？  React 在初始化真实 dom 的时候，用一个随机的 key
     internalInstanceKey 指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。
    6 onClick是在冒泡阶段绑定的？ 那么onClickCapture就是在事件捕获阶段绑定的吗？   
    是。 不是。 捕获是在事件插件系统的核心extractEvents中模拟的。

    js事件机制  事件捕获  事件冒泡
    假设现在的事件是点击上图中蓝色的<td>。
    那么当td的click事件发生时，会先走红色的「capture phase」：
    Document
    <html>
    <body>
    <table> 
    <tbody>
    <tr>
    <td> (实际被点击的元素)
    由上而下依序触发它们的click事件。

    然后到达「Target phase」后再继续执行绿色的「bubble phase」，反方向由<td>一路往上传至Document，整个事件流到此结束。

    addEventListener()基本上有三个参数，分别是「事件名称」、「事件的处理程序」(事件触发时执行的function)，以及一个「Boolean」值，
    由这个Boolean决定事件是以（true）「捕获」还是（false）「冒泡」机制执行，
    若不指定则预设为「冒泡」。和监听的顺序无关，就是从上到下，先捕获在冒泡

    如果想阻止冒泡，需要在儿子这一层设置stopPropagation(),因为是往上， 如果想阻止捕获，需要在父亲这一层设置stopPropagation()，因为是往下

    react和vue的区别
    模版不同
    react组件直接import，vue需要注册
    react推崇函数式，immutable，数据不可变
    vue不需要fiber，因为vue可以精确更新（因为它的观察者模式，vue使用 object.defineProperty 在 getter的时候进行依赖收集，
    将所有watcher对象的实例放到dep中
    在setter的时候调用dep的notify方法通知内部所有的watcher对象调用对应的update进行视图更新），react自顶向下更新
    vue是数据可变的，双向绑定，声明式的写法

    vue diff和react diff的区别
    react 从左到右
    vue2  首尾交叉对比
    vue3  首尾对比往中间收缩，最长递增子序列算法

    react受控组件与非受控组件  可以通过value和onchange去控制的组件，比如一个input框，选中失焦效果，这种就是非受控

    什么情况下要使用hooks，有些过哪些自定义hooks
    和状态有关系可以封装成一个hooks，useScroll下拉加载

    react有用过哪些hooks，useState，useMemo, useCallback, useEffect, useReducer
    useMemo可以返回一个缓存过的值， useCallback返回一个缓存过的回调函数，搭配React.memo做性能优化

    useLayoutEffect 和 useEffect

    useEffect 只会在render之后才会调用，也就是在浏览器绘制完后才调用，而且 useEffect 还是异步执行的，这就保证了不会阻塞浏览器的渲染过程。

    useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题,
    比如你点击一个按钮改变状态，然后在useEffect依赖这个状态，再次改变这个状态，很明显页面就会闪动，因为
    useEffect是在渲染之后异步加载的，很明显状态改动两次就会闪烁，useLayoutEffect是在渲染之前同步加载，
    所以你改变了第一次状态页面还没渲染之前，useLayoutEffect又改变了第二次状态，（堵塞了第一次状态改变之后的渲染），
    所以页面不会发生闪烁

    在useEffect中修改DOM相关的属性会看到页面有明显的闪动，和上面是一个意思
    useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。
    而 useLayoutEffect 就不一样，它会在渲染之前执行，而且是同步阻塞后面的流程。

    commit阶段有三个阶段，
    before mutation、
    mutation、React 会进行一系列的DOM节点更新
    layout
    具体操作 dom 的阶段是 mutation，操作 dom 之前是 before mutation，而操作 dom 之后是 layout。

    useReducer  const [state, dispatch] = useReducer();
    使用场景，但你一个操作需要更新多个state时，可以使用reducer，虽然useState可以放多个属性在一个状态里，但推荐你在一个 state 里放太多东西，
    因为它不会合并 state，用起来不方便

    react高阶组件  其实就是一个函数，返回一个增强过的组件，可以用来做组件复用

    为什么用hooks不用class component或者函数组件
    1.1 虽然React一直提倡的是我们能够函数组件，但是当我们发现函数组件中需要状态时，我们可能不得不将其改变成类组件
    1.2 在使用类组件时，我们不得不去通过箭头函数或者bind去绑定，而这又是比较消耗性能
    1.3 复杂的生命周期
    1.4 在复用组件时，难免要使用render Props或者HOC，这会使代码结构看起来极其复杂，HOC会让组件之间更多的嵌套

    key为什么不能是index  当同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在当前层级的位置发生了变化后。
    react diff算法通过新旧节点比较后，
    如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。
    这无疑大大提高了React性能和渲染效率，
    但是如果key是index，如果出现顺序调换的问题，key值还是原来的key值，就不会进行移动操作，导致无法更新

    react diff算法是怎么样的
    如果是新的虚拟dom是单个节点，那就是直接去老的fiber里遍历，如果key相同，type相同，就搭上update标签，删掉其他的
    如果key不同，继续找下一个

    如果新的虚拟dom是多个节点，那就先进入第一轮遍历，遍历的时候一一对应，如果不能复用，就立马跳出第一轮循环，进入第二轮循环，
    将剩余的老fiber放入一个以老fiberkey或者索引为key，value为fiber节点的Map中，然后遍历新dom到map中去找有没有可以复用的节点，
    找到了就给这个节点看这个节点的索引值是否大于lastplaceIndex，如果大就把lastplaceIndex置为这个fiber的索引，然后从map中删除该节点
    如果小于lastPlaceIndex，就打上移动的标签，(
      其实就是插入，插到父fiber的最后面，这里很神奇，比如你现在是
      <ul>
        <li>A</li>
        <li>B</li>
        <li>C</li>
      </ul>
      然后你用js获取<li>A</li>,然后ul.appendChild(liA),就会变成
      <ul>
        <li>B</li>
        <li>C</li>
        <li>A</li>
      </ul>，而不是
      <ul>
        <li>A</li>
        <li>B</li>
        <li>C</li>
        <li>A</li>
      </ul>

      Node.appendChild() 方法将一个节点附加到指定父节点的子节点列表的末尾处。如果将被插入的节点已经存在于当前文档的文档树中，
      那么 appendChild() 只会将它从原先的位置移动到新的位置（不需要事先移除要移动的节点）。 
      原来如此  --- mdn

    )，最后看老fiberMap中有剩余节点就删掉，新dom中在老fiber
    找不到的就插入

    更新两个阶段
    render  根据老的fiber树和新的vdom创建新的fiber树并找出差异，也就是diff的结果
    commit  根据diff结果更新真实DOM
    更新完了之后新的fiber树就成为fiberRoot.current
    commit阶段不能中断
    render阶段可以中断

    A B C D E   结束循环，遍历
    E A B C D
    移动4个，老fiber只会右移，不会左移，或者最靠谱就是根据lastPlaceIndex来判断

    首先从rootfiber开始向下优先遍历，为遍历到的每个fiber调用beginwork方法，根据diff算法判断是否是复用还是遍历还是删除，
    打上对应的flags，遍历到没有子节点时，如果没有子节点了，就走completework方法，并且在父fiber的effect链表上添加effect，
    如果父fiber已经有firstEffect了，就将父fiber的effect上放到链表的尾部，一直往上直到根节点，然后根据
    rootFiber上的effect链表去更新dom，把current指针指向构建完成的workingProgress树，也就是新的fiber树
    为什么删除的副作用会在最前面
    放到链表前面就先删除了，是怎么放的，那我就不知道了哈哈

    补全从触发状态更新到render阶段的路径。
    有几种方法可以触发react的更新
    ReactDOM.render —— HostRoot   这个其实也是在 pending里面放了update，不过update.payload 是 element
    this.setState —— ClassComponent   这个其实也是在 pending里面放了update，不过update.payload 是 this.setState的第一个传参
    this.forceUpdate —— ClassComponent
    useState —— FunctionComponent
    useReducer —— FunctionComponent

    这里讲的是ClassComponent的setState
      setState之后会发生什么
      对应的fiber节点上的updateQuene.shared.pending链表上会插入最新的update，shared.pending是一个单向的环状链表，
      此时shared.pending的环被剪开并连接在updateQueue.baseUpdate后面，接下来遍历updateQueue.baseUpdate链表，
      以fiber.updateQueue.baseState为初始state，依次与遍历到的每个Update计算并产生新的state，在遍历时如果有优先级低的Update
      会被跳过。当遍历完成后获得的state，就是该Fiber节点在本次更新的state（源码中叫做memoizedState）state的变化在
      render阶段产生与上次更新不同的vdom（jsx通过babel被编译成javascript对象，这里需要配置@babel/preset-react，这里面有将jsx
      编译成javascript的babel插件），通过Diff算法产生effectTag，在commit阶段渲染在页面上。渲染完成后workInProgress
      Fiber树变为current Fiber树，整个更新流程结束。 

      update的结构长这样，
      const update: Update<*> = {
        eventTime,
        lane,  // 优先级
        suspenseConfig,
        tag: UpdateState,
        payload: null,  更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参。
        callback: null,
        next: null,
      };

      react update的优先级是怎么决定的
      React中更新的优先级是通过“调度器”控制的。调度器使用优先级队列来按优先级排序和处理更新。不同类型的更新具有不同的优先级，
      例如用户交互更新（如点击按钮）的优先级比后台数据更新的优先级更高。当有多个更新需要处理时，React会使用优先级队列按照优先级顺序进行处理。
      这样可以确保高优先级更新尽快被处理，从而提高应用程序的性能和响应速度。

    下面讲一下hook的useState和useReducer
      hooks原理
      fiber tree上每个fiber节点都放了一个memorizeState去存储hook信息，是一个通过next串联的链表，这就是不能在if判断语句中使用hooks的原因
      每个节点的 memorizedState 属性上存放了对应的数据，然后不同的 hooks api 使用对应的数据（应该是遍历这个链表去拿对应的数据）来完成不同的功能。
      链表自然有个创建阶段，也就是 mountXxx，之后就不需要再 mount 了，只需要 update。所以每个 useXx 的实现其实都是分为了 mountXxx 和 updateXxx 两部分的。
      第一次执行 useXxx 的 hook 会走 mountXxx 的逻辑来创建 hook 链表，之后会走 updateXxx 的逻辑。

      const [name, setName] = useState("guang");
      useState('dong');
      const handler = useCallback((evt) => {
          setName('dong');
      },[1]);
      fiber: {
        memorizedState: {
          baseState: 'guang',
          memorizedState: 'guang',
          quene: {
            pending: // 和uploadPayload.shared.pending 一样，是环状链表，链接一个个update
          },
          next: {
            baseState: 'dong',
            memorizedState: 'dong',
            next: {
              memorizedState: [(evt) => {setName('dong')}, [1]]
              next: ...
            }
          },
        }
      }

      update的结构长这样，和classComponent的update不太一样哦
      const update = {  
        action,
        next: null
      }

      实际上hooks的setState实际调用的是dispatchAction.bind(null, hook.queue)

      function dispatchAction(queue, action) {
        // 创建update
        const update = {
          eventTime: eventTime,
          lane: lane,
          suspenseConfig: suspenseConfig,
          action: action,
          eagerReducer: null,
          eagerState: null,
          next: null
        }

        // 环状单向链表操作
        if (queue.pending === null) {
          update.next = update;
        } else {
          update.next = queue.pending.next;
          queue.pending.next = update;
        }
        queue.pending = update;

        // 模拟React开始调度更新
        schedule();
      }

      在schedule中，将workInProgressHook重置为fiber保存的第一个Hook，在组件render时，每当遇到下一个useState，
      我们移动workInProgressHook的指针，只要每次组件render时useState的调用顺序及数量保持一致，那么始终可以通过workInProgressHook
      找到当前useState对应的hook对象。反正最后也是算出state，然后render阶段产生最新的vdom

      useRef  将传进来的value包装成了一个拥有current属性的对象，冻结了一下，并将其放在memorizeState上， 
      update ref还是返回原来的对象，memoizedState保存{current: 1}
      useCallback memorizeState存储了一个数组，一个是传入的回调函数，一个是传入的dep，会将dep进行比较
      useMemo  useCallback保存的是callback函数本身，而useMemo保存的是callback函数的执行结果

      useEffect 的 hook 在 render 阶段会把 effect 放到 fiber 的 updateQueue 中，
      这是一个  next 串联的环形链表，lastEffect指向最后一个effect
      ，然后 commit 阶段会异步执行所有 fiber 节点的 updateQueue 中的 effect。
      useLayoutEffect 和 useEffect 中的effect存在两个不同的链表里
      useLayoutEffect 和 useEffect 差不多，区别只是它是在 commit 阶段的 layout 阶段同步执行所有 fiber 节点的 updateQueue 中的 effect。
      因为useEffect是在react组件render之后才会执行，所以在useEffect获取的状态一定是最新的，
      memoizedState保存包含useEffect回调函数、依赖项等的链表数据结构effect，effect链表同时会保存在fiber.updateQueue中
      为什么我们已经拥有hook链表了，为什么还要维护一个effect链表？
      是因为我们的hook链表不止包括useEffect还有其它hook，如果不引入这个链表的话，我们可能会多很多无用的遍历，故而再次又维护了一个effect对象的链表。
      这个链表结构是这样的
      const effect = {
        tag,  // 用来标志useEffect或者useLayoutEffect
        create,  // create是你传入的函数,deps是依赖项，next是下一个effect。
        destory,  // create是你传入的函数，destroy是create函数的返回值，可能是undefined
        deps,  // deps是依赖项
        next  // next是下一个effect。
      }

      useState 同样分为 mountState 和 updateState 两个阶段：
      mountState 会返回 state 和 dispatch 函数，dispatch 函数里会记录更新到 hook.queue，然后标记当前 fiber 到根 fiber 的 lane 需要更新，
      之后调度下次渲染。
      再次渲染的时候会执行 updateState，会取出 hook.queue，根据优先级确定最终的 state 返回，这样渲染出的就是最新的结果。
      memoizedState保存state的值

    function Greeting(props) {
      return (
        <div className="greeting">
          <h1>Hello, {props.name}!</h1>
          <p>Welcome to my website.</p>
        </div>
      );
    }

    Babel会将它转换成下面的JavaScript代码：
    function Greeting(props) {
      return React.createElement(
        "div",
        { className: "greeting" },
        React.createElement(
          "h1",
          null,
          "Hello, ",
          props.name,
          "!"
        ),
        React.createElement(
          "p",
          null,
          "Welcome to my website."
        )
      );
    }

    react再转成vdom， vdom长这样
    {
      "$$typeof": Symbol(react.element)
      "type": "ul",
      "key": "ul",
      "ref": null,
      "props": {
          "children": [
              {
                  "type": "li",
                  "key": "A",
                  "ref": null,
                  "props": {
                      "children": "A"
                  },
                  "_owner": null,
                  "_store": {}
              },
              {
                  "type": "li",
                  "key": "B",
                  "ref": null,
                  "props": {
                      "id": "B",
                      "children": "B"
                  },
                  "_owner": null,
                  "_store": {}
              },
              {
                  "type": "li",
                  "key": "C",
                  "ref": null,
                  "props": {
                      "children": "C"
                  },
                  "_owner": null,
                  "_store": {}
              }
          ]
      },
      "_owner": null,
      "_store": {}
    }


    react性能优化
      pureComponent  浅比较
      shouldComponentUpdate  可以自定义比较 
      React.memo 搭配 useMemo，useCallback  

    react组件通信

    hooks模拟classComponent生命周期
    模拟componentdidmount
    useEffect(() => {

    }, [])

    模拟componentDidUpdate
    const flag = useRef(false); 
    useEffect(() => {
      flag.current = true; 
      if(flag){
        // doSth
      }
    })

    react-router  useNavigator replace: true 会替换history当前的历史，之前的那个就没了，意味着无法用浏览器的返回按钮返回到之前的页面，就是replaceState
    路由原理
      hash路由  
          hash路由通过a标签去跳转，因为是hash，页面不会刷新
          我们可以通过hashchange事件来监听当url的hash值变化时做处理，搞一个对象存储相应的callback，key是路由的路径
          刷新页面不会出发hashChange，但是可以通过load事件来监听刷新页面后要做的事

          hash路由为什么刷新能保存状态，因为先把hash值和对应的事件存到routes对象里面了，取一下hash值执行router[hash]()就完事了
          
      history路由
          history路由通过 history.pushState 去改变url，页面不会刷新，和a标签没有任何关系哈
          到现在还还没想明白，我晕....
          popstate只有history.go, back, forward时才会出发
          刷新状态也不会丢失，应该是匹配了一下路由执行了
    
    hash是在url上拼接/#url/，刷新页面不会有影响
    history是直接改变url，刷新页面会有影响，配置下nginx代理就行了，状态也不会丢失
    location / {
      try_files $uri $uri /index.html
    }

    react-router 都已经到6了  问到就是一个🐔

    react-router exact 
    <Route path="/" component={init} />
    <Route path="/about" component={About} />
    <Route path="/contact" component={Contact} />
    访问 "/" 会出来

    v5与v6的区别
    1.用<Routes> children形式替代<Switch>
    2.Route组件的render换为element
    3.去除Switch中的<Redirect>，用react-router-dom中的Redirect 替代，或者用 <Navigate> 实现
    4.子路由的渲染及Outlet的使用
    5.history对象废弃,路由跳转使用navigate代替
    6.删除match对象

工程化
    Webpack是一个开源的JavaScript模块打包工具，它可以将多个JavaScript模块打包成一个或多个捆绑包，以便在浏览器中使用。
    Webpack的主要功能是对模块进行打包和优化，可以将各种类型的模块（包括JavaScript、CSS、图片、字体等）转换为浏览器可以识别的静态资源，
    并且可以通过插件机制进行扩展，实现更多的自定义功能。
    
    webpack构建过程
        参数解析
        读取入口文件
        调用loader编译文件
        收集依赖，babel进行解析
        生成chunk
        输出文件

        // 具体一点
        将命令行参数与 webpack 配置文件 合并、解析得到参数对象。
        参数对象传给 webpack 执行得到 Compiler 对象。
        执行 Compiler 的 run方法开始编译。每次执行 run 编译都会生成一个 Compilation 对象。
        触发 Compiler 的 make方法分析入口文件，调用 compilation 的 buildModule 方法创建主模块对象。
        生成入口文件 AST(抽象语法树)，通过 AST 分析和递归加载依赖模块。
        所有模块分析完成后，执行 compilation 的 seal 方法对每个 chunk 进行整理、优化、封装。
        最后执行 Compiler 的 emitAssets 方法把生成的文件输出到 output 的目录中。

    webpack里面有哪些配置项
        entry 入口文件
        output 输入chunk
        devtool  生成source-map
          随着各种打包工具的星期，为了提高前端项目的性能和不同浏览器上的兼容性，我们线上环境的代码一般都要经过如下等处理：
          压缩混淆，减小体积
          多个文件合并，减少 HTTP 请求数
          将 es6+代码转换成浏览器能够识别的 es5 代码

          经过如上的步骤之后，我们代码的性能和兼容性提高了，然后由于转换后的代码和源代码的不同，会导致我们的开发调试变得很困难，SourceMap 的诞生就是为了解决如上问题的。
          简而言之，SourceMap 就是一个储存着代码位置信息的文件，转换后的代码的每一个位置，所对应的转换前的位置。有了它，点击浏览器的控制台报错信息时，
          可以直接显示出错源代码位置而不是转换后的代码。

          bundled: 模块未分离
          generated: 模块分离，未经loader处理的代码
          transformed: 模块分离，经loader处理过的代码
          original: 自己写的代码，定位精确到行、列
          original lines: 自己写的代码，定位只精确到行

          点击控制台显示的报错信息能否准确跳转到具体的代码位置，看到的代码是编译过的代码还是源代码
          （有没有sourceMap决定能否跳转对应的源码位置，cheap有sourcemap但跳到的的源码是经过loader处理过的），
          开发要打包速度快且调试方便，直接eval-cheap-module-source-Map，生产环境下，我们不必过多关注打包性能，
          主要考虑 quality 代码的保护性、出错的定位速度以及安全性等。
          none，source-map，hidden-source-map(能看到编译过后的代码)，nosources-source-map（啥都看不到），
          cheap-module-source-map（可以看到源代码）

          sourceMap原理
          可以看到尾部有这句注释：
          //# sourceMappingURL=main.js.map
          正是因为这句注释，标记了该文件的 Source Map 地址，浏览器才可以正确的找到源代码的位置。 sourceMappingURL 指向 Source Map 文件的 URL 。

        module loader webpack只识别js，用来处理其他文件，Loaders本身是一个函数，接受源文件作为参数，返回转换的结果。
        loader的执行顺序是 从下到上，
        从右到左 的顺序执行的，file-loader会把图片打成文件，但是url-loader会把图片打成base64写到js中，会导致js变大，使用limit
        常用的loader：style-loader（通过注入<style>标签将CSS插入到DOM中），
        css-loader（仅处理css的各种加载语法(@import和url()函数等),就像 js 解析 import/require() 一样），
        postcss-loader（PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 
        和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。
        PostCSS 在业界被广泛地应用。PostCSS 的 autoprefixer 插件是最流行的 CSS 处理工具之一。
        autoprefixer 添加了浏览器前缀，它使用 Can I Use 上面的数据。
        先postcss-loader，然后在less-loader/sass-loader,（这里说的是从上到下写，当然调用的时候是从下到上，也就是先调用了less-loader，然后再sass-loader）
        官方是这么推荐的，

        module.exports = {
          ident: 'postcss',
          plugins: [
              // 解决flexbugs
              require('postcss-flexbugs-fixes'),
              require('autoprefixer')({
                  overrideBrowserslist: [
                      'Android 4.1',
                      'iOS 7.1',
                      'Chrome > 31',
                      'ff > 31',
                      'ie >= 8',
                      '> 1%', // 必须大于 1% 用户使用的浏览器
                      //'last 2 versions', // 所有主流浏览器最近的 2个版本
                  ],
                  grid: true,
              }),
          ],
          sourceMap: process.env.NODE_ENV === 'development',
      };

        sass-loader（解析scss，转换为css），
        babel-loader，file-loader，url-loader
        url-loader也是处理图片类型资源，只不过它与file-loader有一点不同，url-loader可以设置一个根据图片大小进行不同的操作，
        如果该图片大小大于指定的大小，
        则将图片进行打包资源，否则将图片转换为base64字符串合并到js文件里
        就不要file-loader了，url-loader设置大小，可以分别打到文件里或者打到资源里

        url-loader test: /\.(ttf|woff|woff2|eot|otf)$/,

        Webpack 5引入了Asset Modules，可以用于处理图片、字体等文件。Asset Modules会自动根据文件类型选择合适的处理方式，
        例如对于图片文件会使用"asset/resource"进行处理，对于字体文件会使用"asset/inline"，将文件转换成base64编码的格式。
        这个asset也可以把文件打成base64，和url-loader差不多，配置dataUrlCondition属性
        这个asset module可以打包几乎所有类型的文件
        {
            test: /\.png|jpg|gif|jpeg|svg/,
            type: 'asset',
            parser: {
                dataUrlCondition: {
                    maxSize: 10 * 1024,
                },
            },
            generator: {
                filename: 'images/[base]',
            },
        },

        Base64编码的图片具有以下优点和缺点：
          优点：
          可以直接将编码后的图片数据作为文本传输，避免了二进制数据传输可能出现的兼容性问题。
          Base64编码后的图片数据可以直接嵌入HTML、CSS或JavaScript代码中，无需使用img标签或CSS背景图等方式进行引用
          （还是需要的哈，src=“data:image/png;base64,iVBORw0KGgoAAAANSU...”）。
          使用Base64编码的图片可以减少HTTP请求次数，从而加快网页的加载速度。

          缺点：
          Base64编码后的图片数据会比原始的二进制数据增大约1/3左右，因此会增加网页的文件大小，如果图片过大，则会导致网页加载速度变慢。
          使用Base64编码的图片无法实现图片的懒加载和缓存功能，因为它们是以文本形式直接嵌入在代码中的，无法被浏览器识别和缓存。
          Base64编码的图片数据无法进行压缩和优化，因为它们已经是文本格式了，无法再进行压缩，而原始的二进制数据可
          以通过压缩算法进行压缩和优化。

        plugin webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作
        常用的plugin：HtmlWebpackPlugin，生成html文件,为html引入外部资源如script、link，将entry配置的相关入口

        CleanWebpackPlugin
        默认情况下，这个插件会删除webpack的output.path中的所有文件，以及每次成功重新构建后所有未使用的资源。
        这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，
        导致文件夹非常庞大。

        mini-css-extract-plugin
        本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件。
        需要搭配MiniCssExtractPlugin.loader使用，与style-loader冲突，style-loader会把文件里的css提取到style标签里
        use: [this.mode === 'dev' ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader'],
        plugins: [
          new MiniCssExtractPlugin({
            filename: '[name].css'
          })
        ],

        HotModuleReplacementPlugin 热更新

        DefinePlugin 创建一个在编译时可以配置的全局常量。这会对开发模式和生产模式的构建允许不同的行为非常有用 

        externals 打包的时候从输出的 bundle 中排除依赖，不过需要从页面上加载进相应的资源文件，一个换成多个
        optimization minizer 压缩代码，比如CssMinimizerPlugin，TerserPlugin，splitChunks code split
        SplitChunksPlugin  代码分割

        这两个都是看开发或者生产环境才使用的
        开发可以开，生产不开
        BundleAnalyzerPlugin 体积分析插件
        new BundleAnalyzerPlugin({
            analyzerMode: 'disabled', // 不启动展示打包报告的HTTP服务器
            generateStatsFile: false, // 要生成stats.json文件
        }),
        "generateAnalyzFile": "webpack --profile --json > dist/stats.json", // 生成分析文件
        "analyz": "webpack-bundle-analyzer --port 8888 ./dist/stats.json" // 启动展示打包报告的http服务器
        
        开发可以开，生产不开
        SpeedMeasurePlugin 速度分析插件
        const smp = new SpeedMeasurePlugin()
        const isSmp = process.env.NODE_ENV === 'smp';
        isSmp ? smp.wrap(config) : config;

        "add": "ci add",
        "list": "ci list",
        "delete": "ci delete",
        "select": "ci select",
        "lint": "eslint src --max-warnings 0",
        "lint:quiet": "eslint --ext .ts,.tsx,.js,.jsx src --quiet",
        "stylelint": "stylelint --fix \"**/*.{css,scss}\" src",
        "prettier": "prettier src --write",
        "build": "NODE_ENV=production webpack --config ./config/webpack.prod.js",
        "dev": "NODE_ENV=development webpack-dev-server --open --config ./config/webpack.dev.js",
        "serve:smp": "NODE_ENV=smp node ./config/server.js",
        "serve": "NODE_ENV=development node ./config/server.js",
        "serve:s": "NODE_ENV=development DEV_ENV=entry.json node ./config/server.js",
        "analyzer": "webpack-bundle-analyzer --port 8888 ./build/stats.json",
        "webpack": "node --trace-deprecation node_modules/webpack/bin/webpack.js",
        "precommit-msg": "echo 'Pre-commit checks...' && exit 0"

        css压缩 CssMinimizerPlugin
        js压缩 TerserPlugin

        resolve
          resolve.extensions
            在导入语句没带文件后缀时，webpack 会自动带上后缀后去尝试询问文件是否存在，查询的顺序是按照我们配置 的 resolve.extensions 顺序从前到后查找，webpack 默认支持的后缀是 js 与  json。
            举个🌰：如果我们配置 resolve.extensions= ['js', 'json']，那么 webpack 会先找 xxx.js
          resolve.alias
            alias 的意思为 别名，能把原导入路径映射成一个新的导入路径。
            比如我们项目中可能会有一些相对路径的写法，就可以使用 alias 配置来减少查找过程；
            还比如我们经常使用的 react 库，其实我们可以直接使用其 dist 目录下打包好的 react.min.js，这样就能跳过耗时的模块解析

    webpack5 新特性
        tree shaking更加强大
        cache fileSystem本地 memory内存 支持持久化缓存，可显著提高构建速度

    babel是怎么编译的  AST   parse  transform  generate
    parse 阶段把代码从字符串转换为 AST（代码的树形结构），transform 阶段对 AST 做各种增删改，
    generate 阶段再把转换后的 AST 打印成目标代码并生成 sourcemap。
    babel-plugin 在aysnc函数里面插入try...catch，在try里面插入body里面的代码，然后生成AST节点替换原来的节点

    babel-preset  预设数组   @babel/preset-env  @babel/preset-react  @babel/preset-typescript
    babel-plugin  插件数组   @babel/plugin-transform-runtime   @babel/plugin-proposal-class-properties   
    @babel/plugin-syntax-dynamic-import
  
    preset-env preset-env 内部会自动（根据targets）引入相应的 plugin 来做 AST 的转换，主要是转移es6～es9的语法
    preset-env是ES语法插件的合集，官方已经不再推荐使用preset-201x之类的包，该包可以通过配置自动兼容代码，包括自动引入polyfill垫片
    处理新的API（例如：Promise,Generator,Symbol等）以及 实例方法（例如Array.prototype.includes等）。

    presets: ['@babel/preset-env',
      {
          targets: {
              browsers: ['> 5%', 'IE 10', 'iOS 7', 'Firefox > 20'],
          },
          useBuiltIns: 'usage', // 按需加载polyfill
          corejs: 2,
          modules: false,
      },
    ]
    useBuiltIns  entry, usage 和 false。
    false 只做了语法转换， entry 引入了所有的es扩展包，不管用不用得着一股脑都打包进来，只有 usage 会自动检测代码中用到的功能
    自动引入模块（注：
    babel默认不会检测第三方依赖包代码，所以使用 usage 时，可能会出现引入第三方的代码包未注入模块而引发bug）。
    所以，这里如果不考虑代码包大小，你可以选择 entry 方式。而如果你需要代码尽可能的精简，则使用 usage，这也是官方推荐的用法。

    我们知道，ES+中不仅包含新增的语法（如箭头函数、类），还有一些实例的扩展（Array.prototype.includes等），以及很多内置函数
    （如Promise、Symbol）。
    然而preset-env在不引入polyfill时，对于处理这些应用场景是无能为力的。而为了解决这样的问题，我们通常有两种方法：
    使用 Polyfill 或 Babel-runtime 
    进行功能填充。接下来我们会举例说明两者的优缺点以及应用场景。(其实useBuiltIns设置成usage就可以自动引入需要的polifill了)

    @babel/plugin-transform-runtime
    babel-runtime 开发类库/工具（生成不污染全局空间和内置对象原型的代码）, 借助 @babel/runtime 中帮助函数
    （helper function）移除冗余工具函数
    Babel >= 7.4.0  安装 core-js 替代 babel-polyfill ，而 regenerator-runtime 会在我们安装 @babel/runtime 
    时自动安装，所以不必单独安装了。
    Babel <= 7.4.0  开发类库, 选择 @babel/runtime, 内部项目，@babel/polyfill

    结合一下代码我们可以看出，corejs: false 其实等同于使用 @babel/polyfill 时的 useBuiltIns: false，
    只对ES语法进行了转换。corejs：2 等同于 Babel 6时的 polyfill: true ，
    它们都会为代码创建一个沙盒环境，为 core-js 提供假名，这样就做到了不污染全局空间。corejs: 3 是在 corejs: 2
    的基础上进而解决了之前无法实例方法的窘况（corejs3会polyfill实例方法），同时也保持了不污染全局空间，简直完美~

    是的 [赞]，preset env 的 entry 只过滤 targets 这个维度，usage 再加上用到的这个维度，而 transform runtime 
    插件是独立的，没有 targets 配置，corejs 有什么转什么

    @babel/preset-env + entry = 注入语法的下限是 target 浏览器，上限是当前版本 core-js
    @babel/preset-env + usage = 注入语法的下限是 target 浏览器，上限是源代码与当前版本 core-js 交集
    @babel/plugin-transform-runtime = 当前版本整个 core-js

    babel配置就是配置一下presets，使用@babel/preset-env，配置相应的target，根据target来引入相应的plugin），配置语法然后useBuiltIns用usage，corejs配置下版本，一般选择3，然后为了生成不污染全局空间和内置对象原型的代码
    在plugin里面在配置个@babel/plugin-transform-runtime

性能优化
    减少回流重绘
    什么是回流
    改变元素大小或者位置时会导致重新生成renderTree
    什么是重绘
    将renderTree绘制到屏幕上
    重绘不一定会回流，比如改变字体颜色   

    js放在底部： 为什么js要放在底部，JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建，
    js使用defer或者async
    defer 异步加载，延迟执行，像下面就能保证执行顺序，执行时机是在等dom加载完
    (DOMContentLoaded | document.ready)后执行
    <script src="a.js" defer />
    <script src="b.js" defer />
    async 异步加载，加载完就执行，不能保证加载顺序，执行时机完全看有没有加载完，加载完就执
    行，可能在DOMContentLoaded触发之
    前或之后执行，但一定是在onload之前执行
    <script src="a.js" async />
    <script src="b.js" async />

    DOMContentLoaded = document.ready 在dom加载完成后，会执行 
    window.onload 所有资源加载完成后，会执行

    css 执行会阻塞渲染，阻止 JS 执行 css标签放在头部, 为什么，css不是会阻塞渲染吗，因为不放在头部的话，先加载html会让客户看到一个特别丑的页面
    静态资源使用cdn
    雪碧图
    preload预加载 Prefetch
      Preload来告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级。
      对于那些本来请求优先级较低的关键请求，我们可以通过设置Prefetch来提升这些请求的优先级。
      Prefetch来告诉浏览器用户将来可能在其他页面（非本页面）可能  使用到的资源（脚本js文件，图片，样式css文件），在当前页面加载完成后，就去预先加载这些资源放在http缓存内，
      最常见的dns-prefetch。比如，当我们在浏览A页面，如果会通过A页面中的链接跳转到B页面，而B页面中我们有些资源希望尽早提前加载，
      那么我们就可以在A页面里添加这些资源Prefetch，那么当浏览器空闲时，就会去加载这些资源

    dns-prefetch是指在当前页面加载完成后，提前解析某些域名的DNS信息，以缩短后续请求的连接时间。这样就可以减少用户等待页面响应的时间，更快地展示页面内容。
    <link rel="dns-prefetch" href="//www.google.com">  使用DNS预解析来提前查询Google的DNS记录并缓存到本地
    <link rel="prefetch" href="https://www.google-analytics.com/analytics.js">  当浏览器遇到以下代码时，会预加载Google Analytics脚本：
    <link rel="preload" href="/path/to/myScript.js" as="script（css这里是style）">  在上述代码中，我们将一个JavaScript文件设置为preload资源，并且将as属性设置为"script"，这样浏览器就会将它作为JavaScript文件进行预加载。
    preload预加载js文件不会堵塞HTML解析。相反，它可以提高HTML解析的速度和性能。
    当浏览器遇到预加载的js文件时，它会立即发起资源请求并开始下载，而不会等到HTML解析完成。浏览器会在后台下载js文件，不会阻塞HTML解析和加载过程。当js文件下载完成后，浏览器会立即缓存并执行它。
    因此，preload预加载js文件可以提高页面性能和速度，并且不会影响HTML解析和加载过程。当HTML解析完成后，预加载的js文件也已经准备好了，可以立即执行，提高用户的体验。

    图片懒加载，IntersectionObserver，svg
    原理，判断图片是否出现在浏览器可视区域，如果是的话才开始把img里的src替换成data-src，即替换成真正的图片

    那么如何判断图片是否出现在可视区域

    图片距离浏览器可视区域的顶部 小于浏览器的的可视区域高度，即该图片已经被滑到过可视区域过，也可能被继续往上滑滑出可视区域
    按照图片懒加载的逻辑，这里就应该加载了这张图片

    可是虚拟列表是要清除滑出可视区域的数据的，就是只展示可视区域内的数据，这里要加多一个判断，也就是真正判断是否在可视区域内
    document.body.clientHeight 可以获取 可视区域高度， element.getBoundingClientRect().top 可以获取该元素距离可视区域
    顶部的距离，（指的就是）element.height 可以获取元素的高度，如果  top < clientHeight && top > 负的 element.height， 则该元素在
    可视区域内 

    IntersectionObserver 原理
    目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），
    另一次是完全离开视口（开始不可见）。

    实现优先级：
      若浏览器支持原生loading="lazy"则使用原生浏览器懒加载；
      若浏览器支持IntersectionObserver属性，则通过该属性实现；
      否则使用原生js执行懒加载（scroll 事件等）；

    虚拟列表原理
      原理比较复杂，
      那种固定宽度的挺好理解
      不固定宽度的有点难理解

    判断元素是否在可视区域（只有一部分在可视区域也算）
    const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) >= 0);

    http缓存
      强缓存（比如你第一次请求demo.js，服务器会返回文件，并且响应头里设置exprires或者cache-control并放到缓存里
            然后你第二请求demo.js, 浏览器会去缓存里面找demo.js看看之前的响应头事件有没有过期，没过期就直接使用，
            不会去请求服务器端了）

        请求某个文件时，会看看响应头里面的expires和cache-control里去浏览器缓存中找，首先看expires
        过期时间，如果还没过期，那就直接拿浏览器缓存，不过有问题，expires是一个缓存到期时间（和食品有没有过期一个意思，
        和本地时 相比，如果当前的本地时间比这个时间大，就是过期了，不过本地时间可以改，如果你改成比
        expires大就过期了，就过期了，或者是cache-control里的max-age去控制过期时长

      协商缓存

        第一次请求的时候服务器返回的时候响应头会有一个last-modifed，后面请求的时候请求头会自动带上(前端不用设置，会自己带上)
        if-modified-since（就是之前返回的last-modifed），
        这个字段去和服务器对比更新的时间，时间不一样就是更新了，就返回更新的资源（200和新数据），
        如果时间一样就返回304， 并且会显示一个 Not Modified 的字符串，告诉浏览器使用本地缓存;
        不过因为是绝对时间，最小单位是秒导致有误差，也就是说如果我短时间内资源发生了改变，Last-Modified 并不会发生变化
        周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为。

        第二种方案
        etag和if-none-match 和第一种一样，不过是hash值，就不会存在误差了
        Last-Modified 和 Etag 是可以同时设置的，服务器会优先校验 Etag，
        如果 Etag 相等就会继续比对 Last-Modified，最后才会决定是否返回 304

        浏览器disable cache  会在请求头加了个cache-control = no-cache  强缓存和协商缓存都会失效

    gzip压缩

    webpack的性能优化
      打包速度优化
        减少查找过程
        缩小构建目标
          排除 Webpack 不需要解析的模块，即使用 loader 的时候，在尽量少的模块中去使用。
          我们可以借助 include 和 exclude 这两个参数，规定 loader 只在那些模块应用和在哪些模块不应用。
          我们修改公共配置文件 webpack.common.js
        缓存 Cache 相关
        合理使用 sourceMap
        externals
          其实就是可以让你的依赖包不用被打入bundle.js中，你可以在html里面引用对应的cdnjs，然后你在代码仍然可以使用import,require等各种规范
          key同package.json文件中的dependencies对象的key一样  
          value第三方依赖编译打包后生成的js文件，然后js文件执行后赋值给window的全局变量名称

        多进程打包 happypack
        const HappyPack = require('happypack');
        const os = require('os');
        // 开辟一个线程池，拿到系统CPU的核数，happypack 将编译工作利用所有线程
        const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });

        plugins: [
          new HappyPack({
            id: 'happybabel',
            loaders: ['babel-loader'],
            threadPool: happyThreadPool
          })
        ]

      tree-shaking
      code-split
      代码压缩  css压缩 CssMinimizerPlugin  js压缩 TerserPlugin

      服务端渲染
      
      按需加载，逻辑后移，优先保证首屏内容渲染
      复杂计算使用web worker
      接口缓存、计算结果缓存
      骨架屏

typescript
    typescript是什么，ts是一个编程语言，可以说是js的一个超集，你可以在其中写任何js的代码，编译时会被编译成js
    更好的可维护性和可读性
    引入了静态类型声明，不需要太多的注释和文档，大部分的函数看类型定义就知道如何使用了
    在编译阶段就能发现大部分因为变量类型导致的错误

    类型声明，interface，泛型(generics)

    在 TypeScript 中，实用类型（Utility Types）是定义好的一些通用类型，可以用来快速定义其他类型
    pick，omit，exclude，extract
      如果你要用的

      pick只要某个属性
      interface UserInfo {
        name:string;
        age:number;
      }

      // 这时候我们只需要 UserInfo 的 name和age 属性。
      type UserInfoT = Pick<UserInfo, "name">  用type
      interface UserInfoT extends Pick<UserInfo, 'name' | 'age'> {}  用interface

      omit排除某个属性
      interface UserInfo {
          name:string;
          age:number;
      }
      // 这时候我们不需要 UserInfo 的 name和age 属性。
      type UserInfoT = Omit<UserInfo, 'name' | 'age'>

      Exclude 和omit类似，针对的是联合类型
      type User = 'name' | 'age' | 'gender'
      type ExcludeType = Exclude<User, 'gender'>;
      // 相当于
      type ExcludeType = 'name' | 'age' 

      extract 和pick类似，针对的是联合类型
      type User = 'name' | 'age' | 'gender'
      type ExcludeType = Exclude<User, 'name' | 'work'>;
      // 相当于
      type ExcludeType = 'name'

      interface和type的区别
      相同之处
        两者都可以用来描述对象或函数,但语法不同:

        type Point = {
          x: number;
          y: number;
        };

        type SetPoint = (x: number, y: number) => void;

        interface Point {
          x: number;
          y: number;
        }

        interface SetPoint {
          (x: number, y: number): void;
        }

        二者都可以被继承

        interface 继承 interface
        interface Person{
            name:string
        }

        interface Student extends Person { stuNo: number }

        interface 继承 type
        type Person{
          name:string
        }

        interface Student extends Person { stuNo: number }


        type 继承 type
        type Person{
          name:string
        }

        type Student = Person & { stuNo: number }

        type 继承 interface
        interface Person{
          name:string
        }

        type Student = Person & { stuNo: number }

    不同之处
        type可以定义基本类型别名, 但是interface无法定义
        // 声明一个布尔类型
        type MyBoolean = boolean;

        type可以声明联合类型
        type name = 'zzp' | 'zzl';
        type MyUnion = string | number === let myVar: string | number;

        type可以申明 元组类型
        type MyTuple = [string, number, boolean];
        let myTuple: MyTuple = ['hello', 123, true];

        声明合并
        interface Person { name: string }
        interface Person { age: number }

        let user: Person = {
            name: "Tolu",
            age: 0,
        };

        type Person { name: string }; 

        // Error: 标识符“Person”重复。ts(2300)
        type Person { age: number }

        官方推荐用 interface，其他无法满足需求的情况下用 type
      
        d.ts声明文件  有时，我们不免会引入外部的 JS库，这时TS就对引入的JS文件里变量的具体类型不明确了，为了告诉TS变量的类型，因
        此就有了.d.ts (d即declare)，ts的声明文件。“d.ts”文件用于为 TypeScript 提供有关用 JavaScript 编写的 API 的类型信息
        这个时候你不能用TS重写主流的库，这个时候我们只需要编写仅包含类型注释的 d.ts 文件，然后从您的 TS 代码中，可以在仍然使用纯 JS 库的同时，获得静态类型检查的 TS 优势。

项目/业务
    ahooks原理
        有用过哪些ahooks，useRequest，
        useLatest，返回当前最新值的 Hook，可以避免闭包问题。
        useUpdateEffect
        使用上与 useEffect 完全相同，只是它忽略了首次执行，只在依赖项更新时执行。
        还有一些拖拉拽的交互 useDrag，useDrop的拖拉api

        swr是什么， 如果设置了 options.cacheKey，useRequest 会将当前请求成功的数据缓存起来。下次组件初始化时，如果有缓存数据，
        我们会优先返回缓存数据，然后在背后发送新请求，也就是 SWR 的能力。
        
        useRequest很强大，const {loading, params(参数缓存，可以获取上一次请求用的条件), run, runAsync, cancel} = useRequest(url, {
          manual: true,  // 手动触发
          pollingInterval: 3000,  // 轮询，可以通过 cancel 来停止轮询，通过 run/runAsync 来启动轮询。
          refreshDeps: []  // 依赖项，当依赖项的值变化，便会重新发起请求，屌爆了
          debounceWait: 300,  // 防抖
          throttleWait: 300,  // 节流
          cacheKey: 'cacheKey-demo',  // SWR，在组件第二次加载时，会优先返回缓存的内容，然后在背后重新发起请求。你可以通过点击按钮来体验效果。
          staleTime: 5000,    // 缓存数据保持新鲜时间。在该时间间隔内，认为数据是新鲜的，不会重新发请求，如果设置为 -1，则表示数据永远新鲜
          cacheTime: 0,  // 设置缓存数据回收时间。默认缓存数据 5 分钟后回收, 如果设置为 -1, 则表示缓存数据永不过期, cacheTime要是超时了，你的缓存就没了，就无法实现那种第二次加载的时候，优先返回缓存的内容，缓存的内容被清掉了

          setCache: (data) => localStorage.setItem(cacheKey, JSON.stringify(data)),
          getCache: () => JSON.parse(localStorage.getItem(cacheKey) || '{}'),

          retryCount: 3, // 通过设置 options.retryCount，指定错误重试次数，则 useRequest 在失败后会进行重试。
        });

        const [userId, setUserId] = useState('1');
        const { data, run } = useRequest(() => getUserSchool(userId), {
          refreshDeps: [userId],
        });
        上面的示例代码，useRequest 会在初始化和 userId 变化时，触发函数执行。
        与下面代码实现功能完全一致
        const [userId, setUserId] = useState('1');
        const { data, refresh } = useRequest(() => getUserSchool(userId));
        useEffect(() => {
          refresh();
        }, [userId]);

        run(params[0])  // 能够获取缓存的参数

    qiankun
        为什么是qiankun而不是iframe
        iframe的优点
          非常简单，无需任何改造
          完美隔离，JS、CSS 都是独立的运行环境
          不限制使用，页面上可以放多个 iframe 来组合业务

        iframe的缺点
          无法保持路由状态，刷新后路由状态就丢失（这点也不是完全不能解决，可以将路由作为参数拼接在链接后，刷新时去参数进行页面跳转）
          完全的隔离导致与子应用的交互变得极其困难
          iframe 中的弹窗无法突破其本身
          整个应用全量资源加载，加载太慢
    
    qiankun原理
        当路由切换的时候（劫持路由），去下载对应应用的代码，然后跑在容器里，qiankun 只是对 single-spa 的升级。
        比如 single-spa，它做的就是监听路由变化，路由切换的时候加载、卸载注册的应用的代码。
        只不过 single-spa 的入口是一个 js 文件，需要代码里手动指定要加载啥 js、css 等，不方便维护。
        qiankun 只是对 single-spa 的升级。

        它升级了啥东西呢？第一个就是入口，改为了 html 作为入口，解析 html，(我的理解是把子应用的html搞到容器里，容器就是你在主应用中为
        字应用提供的容器，然后这个import-html-entry会把html中的js和css replace怎么处理的我也不知道了
        <!--  script http://localhost:8000/main.js replaced by import-html-entry -->
        )从中分析 js、css，然后再加载，这个是
        import-html-entry 这个包实现的。所以你在 qiankun 的 package.json 里可以看到 single-spa 和 
        import-html-entry 这俩依赖。加载之后呢？自然是放容器里运行呀。这个容器 single-spa 也没做，qiankun 做了。
        它是把 js 代码包裹了一层 function，然后再把内部的 window 用 Proxy 包一层，
        这样内部的代码就被完全隔离了，这样就实现了一个 JS 沙箱。就是 function 包裹了一层，所以代码放在了单独作用域跑，
        又用 with 修改了 window，所以 window 也被隔离了。子应用上的window可以用window.proxy访问

    
    qiankun坑点
        样式隔离方案有问题
        shadow-dom 主应用的样式和使用了strictStyleIsolation的子应用样式互不影响但是会导致弹窗的样式挂掉，
        因为弹窗默认是挂在 body 上的，也就不在 shadow dom 里了，那 shadow dom 里给它加的样式自然就不生效了。

        scoped css 也就是对所有样式加了一层 data-qiankun=“应用名” 的选择器来隔离：弹窗样式还是会挂，没有global可以支持控制
        因为react 和 vue 项目本身都会用 scoped css 或者 css modules 的组件级别样式隔离方案，这俩方案都支持传递样式给子元素、设置全局样式等，
        只是实现和使用方式不同。
        global是什么，因为scoped css和css modules都会生成前缀，如果你想影响外面的组件，比如外面组件某个样式是 outside，你写样式控制他会被加前后缀导致
        控制不到外部组件，用global，被包裹在global里的样式就不会被加前后缀

        所以就是不用qiankun的样式隔离，自己做好父子应用间的样式隔离

    ssr
        SSR 普通的CSR就是单页面应用带来的问题，服务端请求到html时，是空白的html，这时候的页面就会出现白屏，
        如果是用SSR，会有一层中间层可以拿到已经渲染出来的html片段
        reactdomServer.renderToString

网络
    http状态码
        3xx 重定向  304协商缓存  没有更新  
        301 表示永久重定向，302 表示临时重定向。
        如果浏览器收到的是 301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。

        比如你这次是 nginx 配置了 重定向，从 www.a.com 跳转到了 www.b.com，那永久重定向就是浏览器会缓存，你后面在访问 www.a.com
        直接就跳到www.b.com，这时你就算已经改了nginx的配置去掉了重定向到www.b.com这个配置，但是浏览器缓存也会让你跳到 www.b.com，
        因为你没有再去读nginx，但是临时重定向就不会缓存，还是会去请求nginx，这时候你已经改了配置，就不会重定向到www.b.com

        但如果浏览器收到的是 302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。
        因此，301 适合地址永久转移的场景，比如域名变更；而 302 适合临时转移的场景，比如首页临时跳转到活动页


        4xx  400 客户端请求报文有语法错误  401 需要有通过 HTTP 认证  403 禁止访问   404 找不到 
        405 不允许使用该方法访问  access-control-allow-Methods
        500 服务端报错

    get和post的区别  
        get不安全（其实都不安全，不过get直接裸露在Url上就显得更不安全了），有大小限制是因为url浏览器有长度限制
        get一般会有缓存，因为它是去服务器获取东西
        post不会有，因为它是去服务器改东西，缓存也没有意义

        浏览器在发送 GET 请求时，不会附带请求体
        刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。
        GET 请求的地址可以被保存为浏览器书签，POST 不可以

    http有哪些请求 get post put delete head   

    cdn是什么
      请求一个网站的请求过程 
      没有cdn的过程
        用户在自己的浏览器中输入要访问的网站域名。
        浏览器向本地DNS服务器请求对该域名的解析。
        本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。dns-prefetch
        本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以迭代方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。
        浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址 。
        浏览器获取IP地址之后，经过标准的TCP握手流程，建立TCP连接。
        浏览器向服务器发起HTTP请求。服务器将用户请求内容传送给浏览器。
        经过标准的TCP挥手流程，断开TCP连接。

      引入了cdn的过程
        当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，
        则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。
        CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。
        用户向CDN的全局负载均衡设备发起URL访问请求。
        CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。
        基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的IP地址，
        最终将得到的IP地址返回给全局负载均衡设备：根据用户IP地址，判断哪一个边缘节点距用户最近；根据用户所请求的URL中携带的内容名称，
        判断哪一个边缘节点上有用户所需内容；查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。
        全局负载均衡设备把服务器的IP地址返回给用户。
        用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，
        而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

      cdn的组成
        中心节点
          中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理。

        边缘节点
          CDN边缘节点主要指异地分发节点，由负载均衡设备、高速缓存服务器两部分组成。
          中心节点就像仓配网络中负责货物调配的总仓，而边缘节点就是负责存储货物的各个城市的本地仓库。

设计模式
    发布订阅模式
        就是会有事件调度中心，然后会有订阅者会在什么订阅事件，发布者会发布事件，然后事件调度中心会去通知你，订阅者和发布者之间不会有任何联系

        class PubSub {
            constructor() {
                this.subscribers = [];
            }
            
            subscribe(topic, callback) {
                let callbacks = this.subscribers[topic];
                if (!callbacks) {
                    this.subscribers[topic] = [callback];
                } else {
                    callbacks.push(callback);
                }
            }
            
            publish(topic, ...args) {
                let callbacks = this.subscribers[topic] || [];
                callbacks.forEach(callback => callback(...args));
            }
        }
        
        // 创建事件调度中心，为订阅者和发布者提供调度服务
        let pubSub = new PubSub();
        // A订阅了SMS事件（A只关注SMS本身，而不关心谁发布这个事件）
        pubSub.subscribe('SMS', console.log);
        // B订阅了SMS事件
        pubSub.subscribe('SMS', console.log);
        // C发布了SMS事件（C只关注SMS本身，不关心谁订阅了这个事件）
        pubSub.publish('SMS', 'I published `SMS` event');

    观察者模式
        被观察者触发事件时，会去通知所有的观察者去更新，观察者想要订阅目标事件，只能将自己添加到被观察者中去进行管理，观察者和被观察者之间有很强的依赖关系
        class Subject {
            constructor() {
                this.observers = [];
            }
        
            add(observer) {
                this.observers.push(observer);
            }
        
            notify(...args) {
                this.observers.forEach(observer => observer.update(...args));
            }
        }
        
        class Observer {
            update(...args) {
                console.log(...args);
            }
        }
        
        // 创建观察者ob1
        let ob1 = new Observer();
        // 创建观察者ob2
        let ob2 = new Observer();
        // 创建目标sub
        let sub = new Subject();
        // 目标sub添加观察者ob1 （目标和观察者建立了依赖关系）
        sub.add(ob1);
        // 目标sub添加观察者ob2
        sub.add(ob2);
        // 目标sub触发SMS事件（目标主动通知观察者）
        sub.notify('I fired `SMS` event');
    
    单例模式
        某个类只能有一个实例
        class Singleton {

          constructor(name) {
            this.name = name
            this.instance = null
          }

          getName() {
            alert(this.name)
          }

          static getInstance(name) {
            if (!this.instance) {
              this.instance = new Singleton(name)
            }
            return this.instance
          }
        }

        const instanceA = Singleton.getInstance('seven1')
        const instanceB = Singleton.getInstance('seven2')

    工厂模式  
        将 new 操作单独封装，只对外提供相应接口；
        遇到new 时，就要考虑是否应该使用工厂模式；

        比如你现在有一个汽车有很多零件，轮胎，方向盘，那你需要用new很多个类，这时候你就可以用工厂模式，直接封装好，就不用在外面new了

        // 定义产品
        class Product {
            constructor(name) {
                this.name = name;
            }
            init() {
                console.log('初始化产品')
            }
        }

        // 定义工厂
        class Factory {
            create(name) {
                return new Product(name); // 核心思想
            }
        }

        let c = new Factory(); 
        let p = c.create('p1');
        p.init();


    装饰者模式  有点像高阶函数和es7的decorator，其实就是再不改变原来类的情况下， 对这个类进行增强
        class Circle {
            draw() {
                console.log('画一个圆形');
            }
        }

        class Decorator {
            constructor(circle) {
                this.circle = circle;
            }
            draw() {
                this.circle.draw();
                this.setRedBorder(circle);
            }
            setRedBorder(circle) {
                console.log('画一个红色边框');
            }
        }

        let circle = new Circle();
        let decorator = new Decorator(circle);
        decorator.draw(); //画一个圆形，画一个红色边框

项目/业务
    能大概讲一下你的项目吗
    要不要写lazada的项目，纠结

    肯定要写的了，里面挺多可以说的
    首屏优化，canvas动画效果，骨架屏

数据结构
    线性结构
        数组
          是一个连续的结构，靠下标查找速度会比较快，时间复杂度O(1)
          插入和删除会比较慢，因为需要移动元素，时间复杂度O(N)

        栈
          后进先出
          栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。
          从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端（栈顶）插入（push）和删除（pop）数据。
          薯片罐，薯片先扔进去的在栈底

          // Stack类
          function Stack() {
            this.items = [];

            // 添加新元素到栈顶
            this.push = function(element) {
              this.items.push(element);
            };
            // 移除栈顶元素，同时返回被移除的元素
            this.pop = function() {
              return this.items.pop();
            };
            // 查看栈顶元素
            this.peek = function() {
              return this.items[this.items.length - 1];
            };
            // 判断是否为空栈
            this.isEmpty = function() {
              return this.items.length === 0;
            };
            // 清空栈
            this.clear = function() {
              this.items = [];
            };
            // 查询栈的长度
            this.size = function() {
              return this.items.length;
            };
            // 打印栈里的元素
            this.print = function() {
              console.log(this.items.toString());
            };
          }

          // 创建Stack实例
          var stack = new Stack();
          console.log(stack.isEmpty()); // true
          stack.push(5); // undefined
          stack.push(8); // undefined
          console.log(stack.peek()); // 8
          stack.push(11); // undefined
          console.log(stack.size()); // 3
          console.log(stack.isEmpty()); // false
          stack.push(15); // undefined
          stack.pop(); // 15
          console.log(stack.size()); // 3
          stack.print(); // 5,8,11
          stack.clear(); // undefined
          console.log(stack.size()); // 0

        队列
          先进先出
          队列在尾部添加新元素，并从顶部移除元素。
          最新添加的元素必须排在队列的末尾。
          队列只有 入队 enqueue(向队列尾部添加新项) 出队 dequeue(移除队列的第一项，并返回被移除的元素)。

          // Queue类
          function Queue() {
            this.items = [];

            // 向队列尾部添加元素
            this.enqueue = function(element) {
              this.items.push(element);
            };

            // 移除队列的第一个元素，并返回被移除的元素
            this.dequeue = function() {
              return this.items.shift();
            };

            // 返回队列的第一个元素
            this.front = function() {
              return this.items[0];
            };

            // 判断是否为空队列
            this.isEmpty = function() {
              return this.items.length === 0;
            };

            // 获取队列的长度
            this.size = function() {
              return this.items.length;
            };

            // 清空队列
            this.clear = function() {
              this.items = [];
            };

            // 打印队列里的元素
            this.print = function() {
              console.log(this.items.toString());
            };
          }

          // 创建Queue实例
          var queue = new Queue();
          console.log(queue.isEmpty()); // true
          queue.enqueue('John'); // undefined
          queue.enqueue('Jack'); // undefined
          queue.enqueue('Camila'); // undefined
          queue.print(); // "John,Jack,Camila"
          console.log(queue.size()); // 3
          console.log(queue.isEmpty()); // false
          queue.dequeue(); // "John"
          queue.dequeue(); // "Jack"
          queue.print(); // "Camila"
          queue.clear(); // undefined
          console.log(queue.size()); // 0

        链表
          是一个不连续的结构，只能遍历查找速度会比较慢，时间复杂度O(N)
          插入和删除会比较快，不需要移动元素，只需要考虑相邻结点的指针改变，时间复杂度O(1)

          class LinkList {
            constructor() {

            }
            #head = null;
            #length = 0;
            #Node = class{
                constructor(element) {
                    this.element = element;
                    this.next = null;
                }
            }

            append = (element) => {
                const node = new this.#Node(element);
                let currentNode = this.#head;
                if(this.#head){
                    while(currentNode.next){
                        currentNode = currentNode.next;
                    }
                    currentNode.next = node;
                } else{
                    this.#head = node;
                }
                this.#length++;
            }

            insert = (position, element) => {
                if(position < 0 || position >= this.#length){
                    return false;
                }
                const node = new this.#Node(element);
                let previousNode;
                let currentNode = this.#head;
                
                if(position === 0){
                    node.next = this.#head;
                    this.#head = node;
                }
                for(let i = 0; i < position; i++){
                    previousNode = currentNode;
                    currentNode = currentNode.next;
                }

                previousNode.next = node;
                node.next = currentNode;

                this.#length ++;
            }

            // 从链表的特定位置移除一项
            removeAt = (position) => {
                if ((position < 0 && position >= this.#length) || this.#length === 0) {
                        // 越界
                        return false;
                } else {
                        var currentNode = this.#head;
                        var previousNode;

                        if (position === 0) {
                                this.#head = currentNode.next;
                        } else {
                                // 循环找到位置
                                for(let i = 0; i < position; i++){
                                    previousNode = currentNode;
                                    currentNode = currentNode.next;
                                }
                                // 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点
                                previousNode.next = currentNode.next;
                                            }

                        this.#length--;
              }
            };

            // 从链表中移除指定项
            remove = (element) => {
                var index = this.indexOf(element);
                return this.removeAt(index);
            };

            list = () => {
                return this.#head;
            };

            // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值
            toString = () => {
                var currentNode = this.#head;
                var string = '';

                while (currentNode) {
                        string += ',' + currentNode.element;
                        currentNode = currentNode.next;
                }

                return string.slice(1);
            };

            // 打印链表数据
            print = () => {
                console.log(this.toString());
            };


            // 返回元素在链表的索引，如果链表中没有该元素则返回 -1
            indexOf = (element) => {
                var currentNode = this.#head;
                var index = 0;

                while (currentNode) {
                        if (currentNode.element === element) {
                                return index;
                        }

                        index++;
                        currentNode = currentNode.next;
                }

                return -1;
            };
          }

          const linkList = new LinkList();

          linkList.append('Tom');
          linkList.append('Peter');
          linkList.append('Paul');

          linkList.insert(1, 'Jack');
          linkList.print(); // "Tom,Jack,Peter,Paul"

    非线性结构
        堆
        二叉树
        图

算法
    基本排序算法
        冒泡排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898b4742e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function bubleSort(arr) {
            var len = arr.length;
            for (let outer = len ; outer >= 2; outer--) {
                for(let inner = 0; inner <=outer - 1; inner++) {
                    if(arr[inner] > arr[inner + 1]) {
                        [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]
                    }
                }
            }
            return arr;
        }
        选择排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc899fabfa0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function selectSort(arr) {
            var len = arr.length;
            for(let i = 0 ;i < len - 1; i++) {
                for(let j = i ; j<len; j++) {
                    if(arr[j] < arr[i]) {
                        [arr[i],arr[j]] = [arr[j],arr[i]];
                    }
                }
            }
            return arr
        }
        插入排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898df137f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function insertSort(arr) {
            for(let i = 1; i < arr.length; i++) {  //外循环从1开始，默认arr[0]是有序段
                for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中
                    if(arr[j] < arr[j-1]) {
                        [arr[j],arr[j-1]] = [arr[j-1],arr[j]];
                    } else {
                        break;
                    }
                }
            }
            return arr;
        }
    高级排序算法
        快速排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898c22284~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function quickSort(arr) {
            if(arr.length <= 1) {
                return arr;  //递归出口
            }
            var left = [],
                right = [],
                current = arr.splice(0,1); //注意splice后，数组长度少了一个
            for(let i = 0; i < arr.length; i++) {
                if(arr[i] < current) {
                    left.push(arr[i])  //放在左边
                } else {
                    right.push(arr[i]) //放在右边
                }
            }
            return quickSort(left).concat(current,quickSort(right)); //递归
        }
        希尔排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898c88c5f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        insertSort(arr,[3,2,1]);
          function shellSort(arr,gap) {
              console.log(arr)//为了方便观察过程，使用时去除
              for(let i = 0; i<gap.length; i++) {  //最外层循环，一次取不同的步长，步长需要预先给出
                  let n = gap[i]; //步长为n
                  for(let j = i + n; j < arr.length; j++) { //接下类和插入排序一样，j循环依次取后面的数
                      for(let k = j; k > 0; k-=n) { //k循环进行比较，和直接插入的唯一区别是1变为了n
                          if(arr[k] < arr[k-n]) {
                              [arr[k],arr[k-n]] = [arr[k-n],arr[k]];
                              console.log(`当前序列为[${arr}] \n 交换了${arr[k]}和${arr[k-n]}`)//为了观察过程
                          } else {
                              continue;
                          }
                      }
                  }
              }
              return arr;
        }

其他
    输入一个url
      dns解析，找到对应ip
      TCP三次握手四次挥手建立连接
      从服务器请求资源 https
      请求到html
      dom tree，cssom tree  
      render Tree
      js 加载 加载完之后渲染页面

      浏览器自动补全协议、端口
      浏览器自动完成url编码
      浏览器根据url地址查找本地缓存，根据缓存规则看是否命中缓存，若命中缓存则直接使用缓存，不再发出请求（http缓存）
      不过没命中缓存，就要向服务器发起请求
      浏览器向本地DNS服务器请求对该域名的解析。
      本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。（dns-prefetch）
      本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以迭代方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。
      浏览器向服务器发出建立TCP连接的申请，完成三次握手后，连接通道建立
      若使用了HTTPS协议，则还会进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2
      浏览器决定要附带哪些cookie到请求头中
      浏览器自动设置好请求头、协议版本、cookie，发出GET请求
      服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。
      浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接。
      浏览器根据响应状态码决定如何处理这一次响应
      浏览器根据响应头中的Content-Type字段识别响应类型，如果是text/html，则对响应体的内容进行HTML解析，否则做其他处理
      浏览器根据响应头的其他内容完成缓存、cookie的设置
      浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源
      解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），
      随后对渲染树中的每个节点计算位置和大小（reflow），
      最后把每个节点利用GPU绘制到屏幕（repaint）
      在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件

    async await 原理
    其实就是 

    工作中遇到的问题
        load chunk failed  没有增量更新，删除了老的文件，那怎么解决呢
        监听报错事件，如果error报错信息里有loading chunk的字眼，就刷新页面
          window.addEventListener(
          'error',
          function (event) {
            if (
              event.message &&
              String(event.message).includes('Loading chunk') &&
              String(event.message).includes('failed')
            ) {
              window.location.reload();
            }
          },
          true,
        );
        css样式命名规范(css隔离问题)   BEM   模块+元素+修饰
        巨石应用构建问题   只构建需要构建的部分，可以用git检测更新的部分
        页面卡顿排查，内存泄漏排查问题（memory，performance）   
          performance分析有任务因为js中的两个计算量都很大，所以有两个long task的提示，我们的目标就是去优化掉long task
          memory中可以看有没有占用内存大小特别高的变量
        nodejs断点  
          使用node --inspect-brk 和 chrome devTool 结合使用
          或者 vscode
          vscode需配置 .vscode/launch.json

    文件上传如何做断点续传
        客户端将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时附带其序号。
        服务器接收到每片数据时，将其保存成一个临时文件，并记录每个文件的 hash 和序号。
        若上传中止，将来再次上传时，可以向服务器索要已上传的分片序号，客户端仅需上传剩余分片即可。
        当全部分片上传完成后，服务器按照分片的顺序组装成完整的文件，并删除分片文件。

    webSocket
        websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，
        然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。
        首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，
        请求行中的 path 需要使用ws:开头的地址，请求头中要分别加入upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version标记
        然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含Switching Protocols，
        同时响应头中包含upgrade、connection、Sec-WebSocket-Accept标记
        当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。

        webSocket 与传统的 http 有什么优势
        当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成:
        第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据
        第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。
        响应后，客户端立即又发起一次请求，重复整个流程。
        无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，
        无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。
        websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，
        服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。

    dispatchEvent
        学到的骚操作，可以用来通信
        // 创建一个带有数据的自定义事件
        const myEvent = new CustomEvent('my-event', { detail: { data: 'Hello World' } });

        // 触发自定义事件并传递数据
        window.dispatchEvent(myEvent);

        // 监听自定义事件
        window.addEventListener('my-event', function(event) {
          console.log('Received data:', event.detail.data);
        });

        不用传数据的话
        window.dispatchEvent(new Event('vListenLogin'));
        window.addEventListener('vListenLogin', function(){});

        事件委托
        前端模板引擎
        
    eslint
        eslint:recommended ESLint内置的推荐规则在么有讲到 所有打钩的就是内置规则
        eslint:all：ESLint 内置的所有规则；
        eslint-config-standard：standard 的 JS 规范；
        eslint-config-prettier：关闭和 ESLint 中以及其他扩展中有冲突的规则；

        平时用的是哪个规范 recommended
        extends: [
          'eslint:recommended', // 是 ESLint 官方的扩展,内置推荐规则
          'eslint-config-standard',
          'plugin:react/recommended',
          "plugin:react-hooks/recommended",
          "plugin:@typescript-eslint/eslint-recommended",
          "plugin:@typescript-eslint/recommended",
        ],
        plugins: [
          'react',
          'react-hooks',
          '@typescript-eslint'
        ],
        parser: '@typescript-eslint/parser',

        如果 extends 配置的是一个数组，那么最终会将所有规则项进行合并，出现冲突的时候，后面的会覆盖前面的；
        通过 rules 单独配置的规则优先级比 extends 高；

        规则强度是 airbnb > standard > recommended

        ESlint的插件是干嘛的：
        首先我们需要知道的Eslint本质只是一个代码检测工具，默认情况下也只能检测js文件，如果我们需要在工程化中加入去兼容其他语法例如[.vue]、[.jsx]等其他格式的文件时就没有办法实现，所以我们需要加入一些插件来实现对非js格式的文件进行检测。
        
    国际化
        i18next react-i18next  一条龙搞定
        基本用法
        语言翻译器

        插值表达式  插值表达式的语法是使用两个大花括号包裹属性名。 
        {t('currentTime', { time: dayjs().format('MM/DD/YYYY') })}
        { currentTime: 'Current time is {{time}}' }

        格式化
        { currentTime: '当前时间是 {{time, YYYY-MM-DD}}' }
        i18n.services.formatter.add('DD/MM/YY', (value, lng, options) => {
          return dayjs(value).format('DD/MM/YY')
        });

        i18next-http-backend  能将翻译文件拆分，为了方便维护，我们可以选择使用 json 文件来作为保存翻译文本的资源文件。

    nginx  单点登录  token被窃取

    移动端 vconsole  抓包 fiddle

    picture实现倍图

    页面抖动，占位解决一切
