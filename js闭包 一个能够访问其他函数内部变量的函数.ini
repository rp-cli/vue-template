javascript
    js闭包  一个能够访问其他函数内部变量的函数
    最常见的方式  函数里面return一个新的函数

    闭包的弊端  内存泄漏，函数执行完之后，内部的变量应该被销毁，但是闭包使变量不会被销毁，从而造成内存泄漏
    闭包的作用  方法和属性的私有化


    this指向，到这个函数的直接调用位置

    由new调用：绑定到新创建的对象
    由call或apply、bind调用：绑定到指定的对象
    由上下文对象调用：绑定到上下文对象
    默认：全局对象

    箭头函数 继承外层函数调用的this绑定

    原型链 如果你有一个对象，你想使用一个它的属性，如果你找不到这个属性，就会_proto这个属性找到它的构造函数的protoType这个对象上去查找这个属性
    parent._proto = Parent.prototype;
    js中万物皆对象  分为普通对象和函数对象  普通对象的构造函数是Object，函数对象的构造函数是Function，原型链的顶端Object.prototype._proto = null

    继承 
    1.call apply  使用call或apply方法，将父对象的构造函数绑定在子对象上
    2.将构造函数的prototype执行要继承的构造函数的实例，然后改一下constructor
    3.将构造函数的prototype直接指向要继承的构造函数
    4.拷贝继承

    事件循环 eventLoop js是单线程，如果没有eventLoop就发生堵塞，执行栈执行为同步任务后，会去检查微任务队列是否为空，如果微任务队列不为空，就执行完所有的
    微任务，然后再去查看宏任务队列，执行完单个宏任务之后，再去检查微任务队列

    pwa 
    渐进式编程 
    网页只有两个线程，js线程和GUI渲染线程，这两个线程是互斥的，为了在高耗时js运算时，UI页面仍可用，得额外开辟一个js线程来运行这些高耗时的代码，这就是web worker

    web worker 
      new worker(url)
      message和postMessage
      只服务于注册它的页面，不同页面之间不能共享
      页面关闭时，该页面新建的web worker也会关闭，不会留在浏览器中

    service worker 问到代码实现可能直接扑街
      navigator.register(url)
      不同页面之间可以共享，遵从同源策略
      注册的页面关闭也不会中断，会长留在浏览器中

    前端如何解决跨域问题
    什么是跨域
    一个域名分为  https://www.baidu.com:8080/xxx.json
    协议 子域名 主域名 端口号  资源地址（这个不同不算跨域哈）

    跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
    所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script）就可以跨域，
    因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。
    
    服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。感觉这个比较存疑，就不说了

    怎么解决跨域问题
    开发代理  什么是开发代理，利用webpack的proxy，或者是whistle之类的ip映射到域名上的操作
    jsonp  什么是jsonp，就是利用script标签可以跨域的原理，在服务端根据客户端传来的信息，查找数据库，然后返回一份可执行的javascript代码，
    客户端直接解析执行代码(因为是用script标签，所以返回来的javascript字符串就会被解析执行)，即调用 jsonpCallback() 函数，彻底懂了
    nginx代理跨域  反向代理
    cors 服务器设置相应头  好像前三个是一定要设置的
    Access-Control-Allow-Origin   允许访问的域名
    Access-Control-Allow-Method  允许访问的方法
    Access-Control-Allow-Headers  允许哪个头访问我
    Access-Control-Allow-Credentials  允许携带cookie
    Access-Control-Max-Age  预检的存活时间
    Access-Control-Expose-Headers  允许返回的头

    网络安全
    xss攻击就是脚本跨站攻击
    存储型 XSS  存到数据库里，比如评论区留言，留言个<script>alert</script>
    反射型 XSS  服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
    dom型 XSS  url上面参数搞个<script>alert</script>，前端直接拿参数

    前端做转义  对一些标签<>等特殊字符进行转义，服务端检测url中是否带有恶意代码，比如javascript script
    ; const escapeChar = unsafe => {
    ;   return unsafe
    ;       .replace(/</g, '&lt;')
    ;       .replace(/>/g, '&gt;')
    ;       .replace(/"/g, '&quot;');
    ;   };
    避免使用  dangerouslySetInnerHTML

    csrf
    csrf其实就是一个跨域请求，但是他攻击你访问过的网站能带上对应的cookie，一般就是表单提交资源嵌入
    大概过程就是：1.登陆www.A.com，浏览器有了cookie
                2.不小心访问了危险网站www.B.com,然后B发了一个请求给A，你这个请求的域名是www.A.com/xxxx，就是同源，所以能拿到A的cookie，
                然后就炸开了

    怎么防止csrf
    同源检测，请求中在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
    Origin Header
    Referer Header
    这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。
    cookie的同源策略  只要你请求某个域名，就会带上某个域名的cookie，可以用samesite去限制（就是跨域请求的时候不会带上cookie）
    cookie属性 domain path http-only secure samesite  expires/max-age  name value
    使用token，不用cookie

    为什么csrf其实是跨域请求，那却能成功，因为我们要正确的理解跨域请求是什么
    跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
    所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script）（csrf）就可以跨域，
    因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。

    es6有哪些用过的语法
    const, let 暂时性死区，没有声明之前不能先使用
    箭头函数  继承外层函数调用的this绑定
    promise
    async await
    class
    Map，Set  
    Set是一种叫做无序且唯一集合的数据结构，使用场景 数组去重
    Map是一种叫做字典的数据结构，使用场景 数据存储  键值对存储的方式  Map的key可以是任意值

    WeakSet和set类似，也是不重复的值的集合，区别
      WeakSet 的成员只能是对象，而不能是其他类型的值
      (Set里面的值可以是数组，只要是有iterable接口的数据接口，比如new Set([1,2,3]), 但是这里weakSet的值只能是对象，比如
      let ws = new WeakSet() ws.add({name: 'zzp'});)
      WeakSet 中的对象都是弱引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
      应用场景：储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。用set或者其他数组之类的就不行，比如一个场景，
      你定义一个set去存储dom节点，如果这两个dom节点被删掉了，你需要手动把
      set dom的引用手动删除掉，如果你用weakSet，删除dom的时候便会自动删除

      let obj1 ={name:"leslie1"};
      let obj2 ={name:"leslie2"};
      let ws = new WeakSet();
      let s = new Set();
      ws.add(obj1);
      s.add(obj2)
      // console.log(ws);
      // console.log(s);
      obj1=null;
      obj2=null;
      console.log(ws);  WeakSet里没有obj1了
      console.log(s);  Set里还有obj2

    WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。

    WeatMap和Map类似
      WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
      WeakMap的键名所指向的对象，不计入垃圾回收机制。
      应用场景：WeakMap 应用的典型场合就是 DOM 节点作为键名

      let myWeakmap = new WeakMap();
    ​
      myWeakmap.set(
       document.getElementById('logo'),
        {timesClicked: 0})
      ;
      ​
      document.getElementById('logo').addEventListener('click', function() {
       let logoData = myWeakmap.get(document.getElementById('logo'));
       logoData.timesClicked++;
      }, false);

    这里这个dom要是被清掉了，那weakMap中这个对象就没了

    因为WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历

    WeakMap  

    Symbol 是一种原始数据类型，表示独一无二的值。当你需要一个独一无二的值，就不需要去声明一些奇怪的字符串，可以用symbol代替，不说了，有点傻逼
    Symbol.for  typeof 就是用的symbol

    js数组别忘了哟
    1.1 push  往数组的最后加入元素，改变原数组，返回新数组的长度
    1.2 unshift 往数组的开头加入元素，改变原数组，返回新数组的长度  
    1.3 pop 删除数组的最后一个元素，改变原数组，返回被删除的元素
    1.4 shift 删除数组的第一个元素，改变原数组，返回被删除的元素
    1.5 splice(index, count, value1, value2...) 删除数组中某个元素，改变原数组
    1.6 slice(start, end) 获取子数组，包含原数组索引start的值到索引end的值，不包含end，返回获取的子数组，不改变原数组

    canvas  动画堵塞
    用过canvas 大概说一下画一个canvas的过程
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    // 清除画布
    ctx.clear();

    // 绘制直线
    ctx.moveTo(50, 50);
    ctx.lineTo(200, 200);
    ctx.stroke();

    // 绘制一个三角形
    ctx.moveTo(50, 50);
    ctx.lineTo(200, 200);
    ctx.lineTo(200, 50);
    ctx.lineTo(50, 50);
    ctx.stroke();

    // 绘制一个矩形边框
    ctx.strokeRect(50, 50, 200, 100);

    // 绘制一段圆弧
    ctx.arc(60, 60, 50, 0, Math.PI, false);
    ctx.stroke();

    // 画出一个半圆和一个整圆，关闭路径就不会连接起来
    ctx.beginPath() // 开启路径
    ctx.arc(60, 60, 50, 0, Math.PI, false);
    ctx.stroke();
    ctx.closePath() // 闭合路径
    // 绘制一个圆弧
    ctx.beginPath() // 开启路径
    ctx.arc(200, 60, 50, 0, Math.PI*2, false);
    ctx.stroke();
    ctx.closePath() // 闭合路径

    // 绘制椭圆
    ctx.ellipse(100, 150, 50, 100, 0, 0, 2 * Math.PI);
    ctx.stroke();

    // 贝塞尔曲线，其实就是画不规则的曲线，不是只能画圆


    // 二次贝塞尔曲线，只能弯曲一次的曲线
    ctx.moveTo(50, 50);
    // quadraticCurveTo(cp1x, cp1y, x, y)，其中cp1x和cp1y为一个控制点，x和y为结束点。
    ctx.quadraticCurveTo(200, 200, 350, 50);
    // 绘制
    ctx.stroke();

    //三次贝塞尔曲线，能弯曲两次的曲线
    ctx.moveTo(50, 200);
    // ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x, y)，其中cp1x和cp1y为一个控制点，cp2x和cp2y为第二个控制点，x和y为结束点。
    ctx.bezierCurveTo(150, 50, 250, 350, 350, 200);
      // 绘制
    ctx.stroke();

    多次弯曲曲线，两条三次贝塞尔曲线拼起来就ok啦，只要不closepath就会连接起来，太牛逼了
    ctx.beginPath();
    ctx.moveTo(50, 50); // 起点位置
    ctx.bezierCurveTo(80, 0, 120, 100, 150, 50); // 前半段控制点和终点位置
    ctx.bezierCurveTo(180, 0, 220, 100, 250, 50); // 后半段控制点和终点位置
    ctx.stroke();

css篇
    bfc  什么是bfc，块级格式化上下文
      如何生成BFC
      1、float：设置浮动
      2、overflow：auto，hidden
      3、position：设置absolute或者fixed
      4、display：inline-block、flex、inline-flex、table-cell、table-caption、


    权重
    flex: 1   flex-grow: 1  flex-shrink: 1  flex-basis: 0%
    剩余空间占多少
    压缩多少
    算完flex-basis再根据剩余空间来分配，有剩余按照flex-grow，长度不够按照flex-shrink（flex-basis不是auto的时候会覆盖width，是auto的时候则是width生效）

    css3新特性
      背景
      渐变
      转换和变形
      动画：keyframes，过渡：transition

      @keyframes slidein {
          from { transform: translateX(-100%); }
          to { transform: translateX(0); }
      }

      @keyframes fadeout {
          from { opacity: 1; }
          to { opacity: 0; }
      }

      div.slidein {
          animation-name: slidein;
          animation-duration: 2s;
      }

      p.fadeout {
          animation-name: fadeout;
          animation-duration: 1s;
          animation-delay: 2s;
      }

      媒体查询

    移动端方案
      淘宝方案  1rem等于根元素字体大小 缺点 字体也会跟着缩放  移动端方案
      const oHtml = document.getElementsByTagName('html')[0]
      const width = oHtml.clientWidth;
      // 320px的屏幕基准像素为12px
      oHtml.style.fontSize = 12 * (width / 320) + "px";

      vw, vh  100vw就是整个屏幕大小，什么叫dpi，苹果的屏幕的1px相当于两2px，所以出图的话是乘以2出的
      不然图片放到苹果上面会模糊，自己要将像素除以2，除非是矢量图，就不会模糊，不然会模糊

      2倍图，3倍图

    scss 语法 &-  var.scss

react篇
    react是什么，为什么要用react  react是前端现在比较流行的一个js库，不用手动操作dom，组件化，有成熟的生态

    react生命周期
    初始化阶段 
    comopnentwillmount(废弃警告)（getDerivedStateFromProps）
      当父组件传递给子组件的props发生变化时，子组件可以通过getDerivedStateFromProps方法更新自己的state，以便重新渲染。
      
      很简单，就是更新的时候跑不到constructor里面去，就可以用这个getDerivedStateFromProps，以前我也用过componentWillReceiveProps
      实现过类似的功能

      constructor(props) {
        super(props);
        this.state = { count: props.value };
      }
      static getDerivedStateFromProps(props, state) {
        if (props.value !== state.count) {
          return { count: props.value };
        }
        return null;
      }
      static不能访问this

    render
    compnoentDidmount

    更新阶段
    componentWillReceiveProps(废弃警告)(getDerivedStateFromProps)
    shouldComponentUpdate(nextProps, nextState)
    componentWillUpdate(废弃警告)
    render
    getSnapshotBeforeUpdate

    getSnapshotBeforeUpdate是一个在组件更新（即state或props发生变化）之后、
      在render方法被调用之前被调用的生命周期方法。它的返回值将作为componentDidUpdate方法的第三个参数传递进来。
      理解getSnapshotBeforeUpdate的最常见应用场景是：当组件的某些 DOM 节点在更新前后发生了变化，我们需要获取这些变化前后的状态并进行一些操作。
      下面是一个例子，假设我们有一个聊天室应用，其中有一个聊天记录组件：

      class ChatLog extends React.Component {
        constructor(props) {
          super(props);
          this.chatLog = React.createRef();
        }

        getSnapshotBeforeUpdate(prevProps) {
          // 当消息列表发生变化时，获取当前滚动位置并保存
          if (prevProps.messages.length < this.props.messages.length) {
            const chatLog = this.chatLog.current;
            return chatLog.scrollHeight - chatLog.scrollTop;
          }
          return null;
        }

        componentDidUpdate(prevProps, prevState, snapshot) {
          // 当更新完成后，将滚动位置调整到之前保存的位置
          if (snapshot !== null) {
            const chatLog = this.chatLog.current;
            chatLog.scrollTop = chatLog.scrollHeight - snapshot;
          }
        }

        render() {
          return (
            <div className="chat-log" ref={this.chatLog}>
              {this.props.messages.map((message, index) => (
                <div key={index} className="message">
                  <div className="username">{message.username}</div>
                  <div className="content">{message.content}</div>
                </div>
              ))}
            </div>
          );
        }
      }

      export default ChatLog;
      
      在这个例子中，我们在组件的constructor方法中创建了一个ref，
      用来引用聊天记录组件的DOM节点。在getSnapshotBeforeUpdate方法中，
      我们判断了聊天记录组件的消息列表是否发生变化，如果是的话，我们就获取当前的滚动位置并保存。
      在componentDidUpdate方法中，我们将滚动位置调整到之前保存的位置。

      这样，当我们向聊天室中发送一条新消息时，聊天记录组件的高度将发生变化，
      getSnapshotBeforeUpdate方法将获取当前的滚动位置并保存，
      componentDidUpdate方法将滚动位置调整到之前保存的位置，从而实现了更好的用户体验。

    componentDidUpdate

    卸载阶段
    componentWillUnMount
    
    为什么要使用fiber架构
    react16使用了新的fiber架构，react15在reconciler是递归处理虚拟dom的，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。
    react16的reconciler是可中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。
    react16还多了一个Scheduler调度器，当浏览器有剩余时间时通知我们，同时调度任务的优先级，高优任务优先进入Reconciler，
    react15中reconciler和rerender之前是交替工作的，
    react16 Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，整个Scheduler与Reconciler
    的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

    什么是fiber架构
    React16的Reconciler基于Fiber节点实现， fiber 架构是 React 在 16 以后引入的，之前是直接递归渲染 vdom，
    现在则是多了一步 vdom 转 fiber 的 reconcile，在 reconcile 
    的过程中创建 dom 和做 diff 并打上增删改的 effectTag，然后一次性 commit。这个 reconcile 是可被打断的，可以调度，也就是 fiber 的 schedule。
    fiber 节点由三个属性，children，return和sibling，是一个树状链表，每次中断都可以通过这个三个属性去继续更新
    作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
    作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。


    react setState是同步还是异步
    react 16,17 
    在合成事件和钩子函数中是异步的，在原生和setTimeout中不是批量异步的
    异步不是说像setTimeout和Promise的那种异步，而是调用顺序的问题，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值
    react 18 全部是异步批量更新  

    const container = document.getElementById('root');
    const root = createRoot(container);
    const element1 = <MyComponent1 />;
    const element2 = <MyComponent2 />;
    root.render(element1, element2);

    react setState为什么有时是同步的，有时是异步的，其实和react的事件机制有关，react有一个legacy事件处理系统，batchedEventUpdates为批量更新的主要函数，
    React通过开关isBatchingEventUpdates来控制是否启用批量更新。但是如果是发生在setTimeout中,由于eventLoop 放在了下一次事件循环中执行，
    此时 batchedEventUpdates 中已经执行完isBatchingEventUpdates = false，所以批量更新被打破，我们就可以直接访问到最新变化的值了。

    react事件机制
    react事件合成， onClick还是click，onChange变成change，blur，keydown，keyup
    react事件绑定  原本的dom上会绑定一个noop函数，即空函数，document上会绑定真正的函数
    react事件触发  大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如scroll事件），冒泡到document，
    document上绑的是dispatchEvent，点击就是调用dispatchEvent，
    如何通过原生的dom找到对应的fiber对象，react初始化的时候，用一个随机的 key internalInstanceKey 
    指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。

    1 我们写的事件是绑定在dom上么，如果不是绑定在哪里？   不是，是绑定在document上的
    2 为什么我们的事件不能绑定给组件？  
    3 为什么我们的事件手动绑定this(不是箭头函数的情况)
    4 为什么不能用 return false 来阻止事件的默认行为？  
    合成事件中React 会对大多数事件执行用的 
    document.addEventListener()，
    所以不能用return false，需要用e.preventDefault()
    5 react怎么通过dom元素，找到与之对应的 fiber对象的？  React 在初始化真实 dom 的时候，用一个随机的 key
     internalInstanceKey 指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。
    6 onClick是在冒泡阶段绑定的？ 那么onClickCapture就是在事件捕获阶段绑定的吗？   
    是。 不是。 捕获是在事件插件系统的核心extractEvents中模拟的。

    hooks原理
    fiber tree上每个fiber节点都放了一个memorizeState去存储hook信息，是一个通过next串联的链表，这就是不能在if判断语句中使用hooks的原因

    useRef  将传进来的value包装成了一个拥有current属性的对象，冻结了一下，并将其放在memorizeState上， update ref还是返回原来的对象
    useCallback memorizeState存储了一个数组，一个是传入的回调函数，一个是传入的dep，会将dep进行比较

    useEffect 的 hook 在 render 阶段会把 effect 放到 fiber 的 updateQueue 中，这是一个  next 串联的环形链表，lastEffect指向最后一个effect
    ，然后 commit 阶段会异步执行所有 fiber 节点的 updateQueue 中的 effect。
    useLayoutEffect 和 useEffect 差不多，区别只是它是在 commit 阶段的 layout 阶段同步执行所有 fiber 节点的 updateQueue 中的 effect。
    因为useEffect是在react组件render之后才会执行，所以在useEffect获取的状态一定是最新的

    useState 同样分为 mountState 和 updateState 两个阶段：
    mountState 会返回 state 和 dispatch 函数，dispatch 函数里会记录更新到 hook.queue，然后标记当前 fiber 到根 fiber 的 lane 需要更新，之后调度下次渲染。
    再次渲染的时候会执行 updateState，会取出 hook.queue，根据优先级确定最终的 state 返回，这样渲染出的就是最新的结果。

    react和vue的区别
    模版不同
    react组件直接import，vue需要注册
    react推崇函数式，immutable，数据不可变
    vue不需要fiber，因为vue可以精确更新（因为它的观察者模式，vue使用 object.defineProperty 在 getter的时候进行依赖收集，将所有watcher对象的实例放到dep中
    在setter的时候调用dep的notify方法通知内部所有的watcher对象调用对应的update进行视图更新），react自顶向下更新
    vue是数据可变的，双向绑定，声明式的写法

    vue diff和react diff的区别
    react 从左到右
    vue2  首尾交叉对比
    vue3  首尾对比往中间收缩，最长递增子序列算法

    react受控组件与非受控组件  可以通过value和onchange去控制的组件，比如一个input框，选中失焦效果，这种就是非受控

    什么情况下要使用hooks，有些过哪些自定义hooks
    和状态有关系可以封装成一个hooks，useScroll下拉加载

    react有用过哪些hooks，useState，useMemo, useCallback, useEffect, useReducer, useLayoutEffect
    useMemo可以返回一个缓存过的值， useCallback返回一个缓存过的回调函数，搭配React.memo做性能优化

    useLayoutEffect 和 useEffect
    用户点击事件，改变了某一个state
    React 内部更新 state 变量
    React 处理更新组件中 return 出来的 DOM 节点（进行一系列 diff 调度等流程）
    将更新过后的 DOM 数据绘制到浏览器中
    用户看到新的页面
    那这时候的 useEffect 只会在render之后才会调用，也就是在浏览器绘制完后才调用，而且 useEffect 还是异步执行的，所谓的异步就是被 React 使用 
    requestIdleCallback 封装的，
    只在浏览器空闲时候才会执行，这就保证了不会阻塞浏览器的渲染过程。

    useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题　
    useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。

    而 useLayoutEffect 就不一样，它会在render之前执行，而且是同步阻塞后面的流程。

    useReducer  const [state, dispatch] = useReducer();
    使用场景，但你一个操作需要更新多个state时，可以使用reducer，虽然useState可以放多个属性在一个状态里，但推荐你在一个 state 里放太多东西，因为它不会合并 state，用起来不方便

    react高阶组件  其实就是一个函数，返回一个增强过的组件，可以用来做组件复用

    为什么用hooks不用class component或者类组件

    1.1 虽然React一直提倡的是我们能够函数组件，但是当我们发现函数组件中需要状态时，我们可能不得不将其改变成类组件
    1.2 在使用类组件时，我们不得不去通过箭头函数或者bind去绑定，而这又是比较消耗性能
    1.3 复杂的生命周期
    1.4 在复用组件时，难免要使用render Props或者HOC，这会使代码结构看起来极其复杂，HOC会让组件之间更多的嵌套

    key为什么不能是index  当同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在当前层级的位置发生了变化后。react diff算法通过新旧节点比较后，
    如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。
    这无疑大大提高了React性能和渲染效率，
    但是如果key是index，如果出现顺序调换的问题，key值还是原来的key值，就不会进行移动操作，导致无法更新

    react diff算法是怎么样的
    如果是新的虚拟dom是单个节点，那就是直接去老的fiber里遍历，如果key相同，type相同，就搭上update标签，删掉其他的
    如果key不同，继续找下一个

    如果新的虚拟dom是多个节点，那就先进入第一轮遍历，遍历的时候一一对应，如果不能复用，就立马跳出第一轮循环，进入第二轮循环，
    将剩余的老fiber放入一个以老fiberkey或者索引为key，value为fiber节点的Map中，然后遍历新dom到map中去找有没有可以复用的节点，
    找到了就给这个节点看这个节点的索引值是否大于lastplaceIndex，如果大就把lastplaceIndex置为这个fiber的索引，然后从map中删除该节点
    如果小于lastPlaceIndex，就打上移动的标签，其实就是插入，插到老fiber的最后面，最后看老fiberMap中有剩余节点就删掉，新dom中在老fiber
    找不到的就插入

    更新两个阶段
    render  根据老的fiber树和新的vdom创建新的fiber树并找出差异，也就是diff的结果
    commit  根据diff结果更新真实DOM
    更新完了以后新的fiber树就成为fiberRoot.current
    commit阶段不能中断
    render阶段可以中断

    A B C D E   结束循环，遍历
    E A B C D
    移动4个

    首先从rootfiber开始向下优先遍历，为遍历到的每个fiber调用beginwork方法，根据diff算法判断是否是复用还是遍历还是删除，
    打上对应的flags，遍历到没有子节点时，如果没有子节点了，就走completework方法，并且在父fiber的effect链表上添加effect，
    如果父fiber已经有firstEffect了，就将父fiber的effect上放到链表的尾部，一直往上直到根节点，然后根据
    rootFiber上的effect链表去更新dom，把current指针指向构建完成的workingProgress树，也就是新的fiber树

    为什么删除的副作用会在最前面
    放到链表前面就先删除了，是怎么放的，那我就不知道了哈哈

    setState之后会发生什么
    对应的fiber节点上的updateQuene.shared.pending链表上会插入最新的update，shared.pending是一个单向的环状链表，
    此时shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面，updateQueue.baseUpdate链表，
    以fiber.updateQueue.baseState为初始state，依次与遍历到的每个Update计算并产生新的state，在遍历时如果有优先级低的Update
    会被跳过。当遍历完成后获得的state，就是该Fiber节点在本次更新的state（源码中叫做memoizedState）state的变化在
    render阶段产生与上次更新不同的vdom，通过Diff算法产生effectTag，在commit阶段渲染在页面上。渲染完成后workInProgress
    Fiber树变为current Fiber树，整个更新流程结束。

    react性能优化
      pureComponent  浅比较
      shouldComponentUpdate  可以自定义比较 
      React.memo 搭配 useMemo，useCallback  

    react组件通信

    react-router  useNavigator replace: true 会替换history当前的历史，之前的那个就没了，意味着无法用浏览器的返回按钮返回到之前的页面
    路由原理
      hash路由  
          我们可以通过hashchange事件来监听当url的hash值变化时做处理，搞一个对象存储相应的callback，key是路由的路径
          刷新页面不会出发hashChange，但是可以通过load事件来监听刷新页面后要做的事

          hash路由为什么刷新能保存状态，因为先把hash值和对应的事件存到routes对象里面了，取一下hash值执行router[hash]()就完事了
          
      history路由
          popstate只有history.go, back, forward时才会出发
          刷新状态也不会丢失，应该是匹配了一下路由执行了
    
    hash是在url上拼接/#url/，刷新页面不会有影响
    history是直接改变url，刷新页面会有影响，配置下nginx代理就行了，状态也不会丢失
    location / {
      try_files $uri $uri /index.html
    }

    react-router 都已经到6了  问到就是一个🐔

    react-router exact 
    <Route path="/" component={init} />
    <Route path="/about" component={About} />
    <Route path="/contact" component={Contact} />
    访问 "/" 会出来

    v5与v6的区别
    1.用<Routes> children形式替代<Switch>
    2.Route组件的render换为element
    3.去除Switch中的<Redirect>，用react-router-dom中的Redirect 替代，或者用 <Navigate> 实现
    4.子路由的渲染及Outlet的使用
    5.history对象废弃,路由跳转使用navigate代替
    6.删除match对象

工程化
    babel runtime
    webpack构建过程
        参数解析
        读取入口文件
        调用loader编译文件
        收集依赖，babel进行解析
        生成chunk
        输出文件

        // 具体一点
        将命令行参数与 webpack 配置文件 合并、解析得到参数对象。
        参数对象传给 webpack 执行得到 Compiler 对象。
        执行 Compiler 的 run方法开始编译。每次执行 run 编译都会生成一个 Compilation 对象。
        触发 Compiler 的 make方法分析入口文件，调用 compilation 的 buildModule 方法创建主模块对象。
        生成入口文件 AST(抽象语法树)，通过 AST 分析和递归加载依赖模块。
        所有模块分析完成后，执行 compilation 的 seal 方法对每个 chunk 进行整理、优化、封装。
        最后执行 Compiler 的 emitAssets 方法把生成的文件输出到 output 的目录中。

    webpack里面有哪些配置项
        entry 入口文件
        output 输入chunk
        devtool  生成source-map
          随着各种打包工具的星期，为了提高前端项目的性能和不同浏览器上的兼容性，我们线上环境的代码一般都要经过如下等处理：
          压缩混淆，减小体积
          多个文件合并，减少 HTTP 请求数
          将 es6+代码转换成浏览器能够识别的 es5 代码

          经过如上的步骤之后，我们代码的性能和兼容性提高了，然后由于转换后的代码和源代码的不同，会导致我们的开发调试变得很困难，SourceMap 的诞生就是为了解决如上问题的。
          简而言之，SourceMap 就是一个储存着代码位置信息的文件，转换后的代码的每一个位置，所对应的转换前的位置。有了它，点击浏览器的控制台报错信息时，
          可以直接显示出错源代码位置而不是转换后的代码。

          bundled: 模块未分离
          generated: 模块分离，未经loader处理的代码
          transformed: 模块分离，经loader处理过的代码
          original: 自己写的代码，定位精确到行、列
          original lines: 自己写的代码，定位只精确到行

          点击控制台显示的报错信息能否准确跳转到具体的代码位置，看到的代码是编译过的代码还是源代码
          （有没有sourceMap决定能否跳转对应的源码位置，cheap有sourcemap但跳到的的源码是经过loader处理过的），
          开发要打包速度快且调试方便，直接eval-cheap-module-source-Map，生产环境下，我们不必过多关注打包性能，
          主要考虑 quality 代码的保护性、出错的定位速度以及安全性等。
          none，source-map，hidden-source-map(能看到编译过后的代码)，nosources-source-map（啥都看不到），
          cheap-module-source-map（可以看到源代码）

        module loader webpack只识别js，用来处理其他文件，Loaders本身是一个函数，接受源文件作为参数，返回转换的结果。loader的执行顺序是 从下到上，
        从右到左 的顺序执行的，file-loader会把图片打成文件，但是url-loader会把图片打成base64写到js中，会导致js变大，使用limit
        常用的loader：style-loader（通过注入<style>标签将CSS插入到DOM中），
        css-loader（仅处理css的各种加载语法(@import和url()函数等),就像 js 解析 import/require() 一样），
        postcss-loader（PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 
        和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。
        PostCSS 在业界被广泛地应用。PostCSS 的 autoprefixer 插件是最流行的 CSS 处理工具之一。
        autoprefixer 添加了浏览器前缀，它使用 Can I Use 上面的数据。

        sass-loader（解析scss，转换为css），
        babel-loader，file-loader，url-loader
        url-loader也是处理图片类型资源，只不过它与file-loader有一点不同，url-loader可以设置一个根据图片大小进行不同的操作，如果该图片大小大于指定的大小，
        则将图片进行打包资源，否则将图片转换为base64字符串合并到js文件里

        plugin webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作
        常用的plugin：HtmlWebpackPlugin，生成html文件,为html引入外部资源如script、link，将entry配置的相关入口

        CleanWebpackPlugin
        默认情况下，这个插件会删除webpack的output.path中的所有文件，以及每次成功重新构建后所有未使用的资源。
        这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大。

        mini-css-extract-plugin
        本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件。
        需要搭配MiniCssExtractPlugin.loader使用，与style-loader冲突，style-loader会把文件里的css提取到style标签里
        use: [this.mode === 'dev' ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],
        plugins: [
          new MiniCssExtractPlugin({
            filename: '[name].css'
          })
        ],

        HotModuleReplacementPlugin 热更新

        DefinePlugin 创建一个在编译时可以配置的全局常量。这会对开发模式和生产模式的构建允许不同的行为非常有用 
        BundleAnalyzerPlugin 可以看到项目各模块的大小，可以按需优化.一个webpack的bundle文件分析工具

        externals 打包的时候从输出的 bundle 中排除依赖，不过需要从页面上加载进相应的资源文件，一个换成多个
        optimization minizer 压缩代码，比如CssMinimizerPlugin，TerserPlugin，splitChunks code split
        SplitChunksPlugin  代码分割

        BundleAnalyzerPlugin 体积分析插件
        SpeedMeasurePlugin 速度分析插件

        css压缩 CssMinimizerPlugin
        js压缩 TerserPlugin

        resolve
          resolve.extensions
            在导入语句没带文件后缀时，webpack 会自动带上后缀后去尝试询问文件是否存在，查询的顺序是按照我们配置 的 resolve.extensions 顺序从前到后查找，webpack 默认支持的后缀是 js 与  json。
            举个🌰：如果我们配置 resolve.extensions= ['js', 'json']，那么 webpack 会先找 xxx.js
          resolve.alias
            alias 的意思为 别名，能把原导入路径映射成一个新的导入路径。
            比如我们项目中可能会有一些相对路径的写法，就可以使用 alias 配置来减少查找过程；
            还比如我们经常使用的 react 库，其实我们可以直接使用其 dist 目录下打包好的 react.min.js，这样就能跳过耗时的模块解析

    webpack5 新特性
        tree shaking更加强大
        cache fileSystem本地 memory内存 支持持久化缓存，可显著提高构建速度

    babel是怎么编译的  AST   parse  transform  generate
    parse 阶段把代码从字符串转换为 AST（代码的树形结构），transform 阶段对 AST 做各种增删改，generate 阶段再把转换后的 AST 打印成目标代码并生成 sourcemap。
    babel-plugin 在aysnc函数里面插入try...catch，在try里面插入body里面的代码，然后生成AST节点替换原来的节点

    babel-preset  预设数组   @babel/preset-env  @babel/preset-react  @babel/preset-typescript
    babel-plugin  插件数组   @babel/plugin-transform-runtime   @babel/plugin-proposal-class-properties   @babel/plugin-syntax-dynamic-import
  
    preset-env preset-env 内部会自动引入相应的 plugin 来做 AST 的转换，主要是转移es6～es9的语法
    preset-env是ES语法插件的合集，官方已经不再推荐使用preset-201x之类的包，该包可以通过配置自动兼容代码，包括自动引入polyfill垫片处理新的API
    （例如：Promise,Generator,Symbol等）以及 实例方法（例如Array.prototype.includes等）。

    presets: ['@babel/preset-env',
      {
          targets: {
              browsers: ['> 5%', 'IE 10', 'iOS 7', 'Firefox > 20'],
          },
          useBuiltIns: 'usage', // 按需加载polyfill
          corejs: 2,
          modules: false,
      },
    ]
    useBuiltIns  entry, usage 和 false。
    false 只做了语法转换， entry 引入了所有的es扩展包，不管用不用得着一股脑都打包进来，只有 usage 会自动检测代码中用到的功能自动引入模块（注：
    babel默认不会检测第三方依赖包代码，所以使用 usage 时，可能会出现引入第三方的代码包未注入模块而引发bug）。
    所以，这里如果不考虑代码包大小，你可以选择 entry 方式。而如果你需要代码尽可能的精简，则使用 usage，这也是官方推荐的用法。

    我们知道，ES+中不仅包含新增的语法（如箭头函数、类），还有一些实例的扩展（Array.prototype.includes等），以及很多内置函数（如Promise、Symbol）。
    然而preset-env在不引入polyfill时，对于处理这些应用场景是无能为力的。而为了解决这样的问题，我们通常有两种方法：使用 Polyfill 或 Babel-runtime 
    进行功能填充。接下来我们会举例说明两者的优缺点以及应用场景。(其实useBuiltIns设置成usage就可以自动引入需要的polifill了)

    @babel/plugin-transform-runtime
    babel-runtime 开发类库/工具（生成不污染全局空间和内置对象原型的代码）, 借助 @babel/runtime 中帮助函数（helper function）移除冗余工具函数
    Babel >= 7.4.0  安装 core-js 替代 babel-polyfill ，而 regenerator-runtime 会在我们安装 @babel/runtime 时自动安装，所以不必单独安装了。
    Babel <= 7.4.0  开发类库, 选择 @babel/runtime, 内部项目，@babel/polyfill

    结合一下代码我们可以看出，corejs: false 其实等同于使用 @babel/polyfill 时的 useBuiltIns: false，只对ES语法进行了转换。corejs：2 等同于 Babel 6时的 polyfill: true ，
    它们都会为代码创建一个沙盒环境，为 core-js 提供假名，这样就做到了不污染全局空间。corejs: 3 是在 corejs: 2的基础上进而解决了之前无法实例方法的窘况，同时也保持了不污染全局空间，简直完美~

性能优化
    减少回流重绘
    什么是回流
    改变元素大小或者位置时会导致重新生成renderTree
    什么是重绘
    将renderTree绘制到屏幕上
    重绘不一定会回流，比如改变字体颜色   

    js放在底部： 为什么js要放在底部，JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建，
    js使用defer或者async
    defer 异步加载，延迟执行，像下面就能保证执行顺序，执行时机是在等dom加载完
    (DOMContentLoaded | document.ready)后执行
    <script src="a.js" defer />
    <script src="b.js" defer />
    async 异步加载，加载完就执行，不能保证加载顺序，执行时机完全看有没有加载完，加载完就执
    行，可能在DOMContentLoaded触发之
    前或之后执行，但一定是在onload之前执行
    <script src="a.js" async />
    <script src="b.js" async />

    DOMContentLoaded = document.ready 在dom加载完成后，会执行 
    window.onload 所有资源加载完成后，会执行

    css 执行会阻塞渲染，阻止 JS 执行 css标签放在头部, 为什么，css不是会阻塞渲染吗，因为不放在头部的话，先加载html会让客户看到一个特别丑的页面
    静态资源使用cdn
    雪碧图
    preload预加载 Prefetch
      Preload来告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级。
      对于那些本来请求优先级较低的关键请求，我们可以通过设置Prefetch来提升这些请求的优先级。
      Prefetch来告诉浏览器用户将来可能在其他页面（非本页面）可能  使用到的资源（脚本js文件，图片，样式css文件），在当前页面加载完成后，就去预先加载这些资源放在http缓存内，
      最常见的dns-prefetch。比如，当我们在浏览A页面，如果会通过A页面中的链接跳转到B页面，而B页面中我们有些资源希望尽早提前加载，
      那么我们就可以在A页面里添加这些资源Prefetch，那么当浏览器空闲时，就会去加载这些资源

    dns-prefetch是指在当前页面加载完成后，提前解析某些域名的DNS信息，以缩短后续请求的连接时间。这样就可以减少用户等待页面响应的时间，更快地展示页面内容。
    <link rel="dns-prefetch" href="//www.google.com">  使用DNS预解析来提前查询Google的DNS记录并缓存到本地
    <link rel="prefetch" href="https://www.google-analytics.com/analytics.js">  当浏览器遇到以下代码时，会预加载Google Analytics脚本：
    <link rel="preload" href="/path/to/myScript.js" as="script（css这里是style）">  在上述代码中，我们将一个JavaScript文件设置为preload资源，并且将as属性设置为"script"，这样浏览器就会将它作为JavaScript文件进行预加载。
    preload预加载js文件不会堵塞HTML解析。相反，它可以提高HTML解析的速度和性能。
    当浏览器遇到预加载的js文件时，它会立即发起资源请求并开始下载，而不会等到HTML解析完成。浏览器会在后台下载js文件，不会阻塞HTML解析和加载过程。当js文件下载完成后，浏览器会立即缓存并执行它。
    因此，preload预加载js文件可以提高页面性能和速度，并且不会影响HTML解析和加载过程。当HTML解析完成后，预加载的js文件也已经准备好了，可以立即执行，提高用户的体验。

    虚拟列表原理
      可视区域

    http缓存
      强缓存
        请求某个文件时，会看看请求头里面的expires和cache-control里去浏览器缓存中找，首先看expires
        过期时间，如果还没过期，那就直接拿浏览器缓存，不过有问题，expires是取客户端的本地时间，可以手动
        更改，改了就过期了，或者是cache-control里的max-age去控制过期时长
      协商缓存
        第一次请求的时候服务器返回的时候会有一个last modifed，后面请求的时候请求头会带上if-modified-since
        这个字段去和服务器对比更新的时间，时间不一样就是更新了，就返回更新的资源（200和新数据），
        如果时间一样就返回304， 并且会显示一个 Not Modified 的字符串，告诉浏览器使用本地缓存;
        不过因为是绝对时间，最小单位是秒导致有误差

        第二种方案
        etag和if-none-match 和第一种一样，不过是hash值，就不会存在误差了

    gzip压缩

    webpack的性能优化
      打包速度优化
        减少查找过程
        缩小构建目标
          排除 Webpack 不需要解析的模块，即使用 loader 的时候，在尽量少的模块中去使用。
          我们可以借助 include 和 exclude 这两个参数，规定 loader 只在那些模块应用和在哪些模块不应用。
          我们修改公共配置文件 webpack.common.js
        缓存 Cache 相关
        合理使用 sourceMap
        externals
          其实就是可以让你的依赖包不用被打入bundle.js中，你可以在html里面引用对应的cdnjs，然后你在代码仍然可以使用import,require等各种规范
          key同package.json文件中的dependencies对象的key一样  
          value第三方依赖编译打包后生成的js文件，然后js文件执行后赋值给window的全局变量名称

      tree-shaking
      code-split
      代码压缩  css压缩 CssMinimizerPlugin  js压缩 TerserPlugin

typescript
    typescript是什么，ts是一个编程语言，可以说是js的一个超集，你可以在其中写任何js的代码，编译时会被编译成js
    更好的可维护性和可读性
    引入了静态类型声明，不需要太多的注释和文档，大部分的函数看类型定义就知道如何使用了
    在编译阶段就能发现大部分因为变量类型导致的错误

    类型声明，interface，泛型(generics)

    在 TypeScript 中，实用类型（Utility Types）是定义好的一些通用类型，可以用来快速定义其他类型
    pick，omit，exclude，extract
      如果你要用的

      pick只要某个属性
      interface UserInfo {
        name:string;
        age:number;
      }

      // 这时候我们只需要 UserInfo 的 name和age 属性。
      type UserInfoT = Pick<UserInfo, "name">  用type
      interface UserInfoT extends Pick<UserInfo, 'name' | 'age'> {}  用interface

      omit排除某个属性
      interface UserInfo {
          name:string;
          age:number;
      }
      // 这时候我们不需要 UserInfo 的 name和age 属性。
      type UserInfoT = Omit<UserInfo, 'name' | 'age'>

      Exclude 和omit类似，针对的是联合类型
      type User = 'name' | 'age' | 'gender'
      type ExcludeType = Exclude<User, 'gender'>;
      // 相当于
      type ExcludeType = 'name' | 'age' 

      extract 和pick类似，针对的是联合类型
      type User = 'name' | 'age' | 'gender'
      type ExcludeType = Exclude<User, 'name' | 'work'>;
      // 相当于
      type ExcludeType = 'name'

      interface和type的区别
      相同之处
        两者都可以用来描述对象或函数,但语法不同:

        type Point = {
          x: number;
          y: number;
        };

        type SetPoint = (x: number, y: number) => void;

        interface Point {
          x: number;
          y: number;
        }

        interface SetPoint {
          (x: number, y: number): void;
        }

        二者都可以被继承

        interface 继承 interface
        interface Person{
            name:string
        }

        interface Student extends Person { stuNo: number }

        interface 继承 type
        type Person{
          name:string
        }

        interface Student extends Person { stuNo: number }


        type 继承 type
        type Person{
          name:string
        }

        type Student = Person & { stuNo: number }

        type 继承 interface
        interface Person{
          name:string
        }

        type Student = Person & { stuNo: number }
    不同之处
        type可以定义基本类型别名, 但是interface无法定义
        // 声明一个布尔类型
        type MyBoolean = boolean;

        type可以声明联合类型
        type name = 'zzp' | 'zzl';
        type MyUnion = string | number === let myVar: string | number;

        type可以申明 元组类型
        type MyTuple = [string, number, boolean];
        let myTuple: MyTuple = ['hello', 123, true];

        声明合并
        interface Person { name: string }
        interface Person { age: number }

        let user: Person = {
            name: "Tolu",
            age: 0,
        };

        type Person { name: string }; 

        // Error: 标识符“Person”重复。ts(2300)
        type Person { age: number }

        官方推荐用 interface，其他无法满足需求的情况下用 type
      
        d.ts声明文件  有时，我们不免会引入外部的 JS库，这时TS就对引入的JS文件里变量的具体类型不明确了，为了告诉TS变量的类型，因
        此就有了.d.ts (d即declare)，ts的声明文件。“d.ts”文件用于为 TypeScript 提供有关用 JavaScript 编写的 API 的类型信息
        这个时候你不能用TS重写主流的库，这个时候我们只需要编写仅包含类型注释的 d.ts 文件，然后从您的 TS 代码中，可以在仍然使用纯 JS 库的同时，获得静态类型检查的 TS 优势。

项目/业务
    ahooks原理
        有用过哪些ahooks，useRequest 
        swr是什么， 如果设置了 options.cacheKey，useRequest 会将当前请求成功的数据缓存起来。下次组件初始化时，如果有缓存数据，
        我们会优先返回缓存数据，然后在背后发送新请求，也就是 SWR 的能力。
        
        useRequest很强大，const {loading, params(参数缓存，可以获取上一次请求用的条件), run, runAsync, cancel} = useRequest(url, {
          manual: true,  // 手动触发
          pollingInterval: 3000,  // 轮询，可以通过 cancel 来停止轮询，通过 run/runAsync 来启动轮询。
          refreshDeps: []  // 依赖项，当依赖项的值变化，便会重新发起请求，屌爆了
          debounceWait: 300,  // 防抖
          throttleWait: 300,  // 节流
          cacheKey: 'cacheKey-demo',  // SWR
          staleTime: 5000,    // 缓存数据保持新鲜时间。在该时间间隔内，认为数据是新鲜的，不会重新发请求，如果设置为 -1，则表示数据永远新鲜
          cacheTime: 0,  // 设置缓存数据回收时间。默认缓存数据 5 分钟后回收, 如果设置为 -1, 则表示缓存数据永不过期

          setCache: (data) => localStorage.setItem(cacheKey, JSON.stringify(data)),
          getCache: () => JSON.parse(localStorage.getItem(cacheKey) || '{}'),

          retryCount: 3, // 通过设置 options.retryCount，指定错误重试次数，则 useRequest 在失败后会进行重试。
        });

        const [userId, setUserId] = useState('1');
        const { data, run } = useRequest(() => getUserSchool(userId), {
          refreshDeps: [userId],
        });
        上面的示例代码，useRequest 会在初始化和 userId 变化时，触发函数执行。
        与下面代码实现功能完全一致
        const [userId, setUserId] = useState('1');
        const { data, refresh } = useRequest(() => getUserSchool(userId));
        useEffect(() => {
          refresh();
        }, [userId]);

        run(params[0])  // 能够获取缓存的参数

        cacheTime到底是啥玩意，有什么用，和staleTime的区别是啥
        其他的hooks

    qiankun
        为什么是qiankun而不是iframe
        iframe的优点
          非常简单，无需任何改造
          完美隔离，JS、CSS 都是独立的运行环境
          不限制使用，页面上可以放多个 iframe 来组合业务

        iframe的缺点
          无法保持路由状态，刷新后路由状态就丢失（这点也不是完全不能解决，可以将路由作为参数拼接在链接后，刷新时去参数进行页面跳转）
          完全的隔离导致与子应用的交互变得极其困难
          iframe 中的弹窗无法突破其本身
          整个应用全量资源加载，加载太慢
    
    qiankun原理
        当路由切换的时候（劫持路由），去下载对应应用的代码，然后跑在容器里，qiankun 只是对 single-spa 的升级。
        比如 single-spa，它做的就是监听路由变化，路由切换的时候加载、卸载注册的应用的代码。
        只不过 single-spa 的入口是一个 js 文件，需要代码里手动指定要加载啥 js、css 等，不方便维护。
        qiankun 只是对 single-spa 的升级。

        它升级了啥东西呢？第一个就是入口，改为了 html 作为入口，解析 html，从中分析 js、css，然后再加载，这个是
        import-html-entry 这个包实现的。所以你在 qiankun 的 package.json 里可以看到 single-spa 和 
        import-html-entry 这俩依赖。加载之后呢？自然是放容器里运行呀。这个容器 single-spa 也没做，qiankun 做了。
        它是把 js 代码包裹了一层 function，然后再把内部的 window 用 Proxy 包一层，
        这样内部的代码就被完全隔离了，这样就实现了一个 JS 沙箱。就是 function 包裹了一层，所以代码放在了单独作用域跑，
        又用 with 修改了 window，所以 window 也被隔离了。

        得看看跑在代码里的是什么玩意
    
    qiankun坑点
        样式隔离方案有问题
        shadow-dom 主应用的样式和使用了strictStyleIsolation的子应用样式互不影响但是会导致弹窗的样式挂掉，
        因为弹窗默认是挂在 body 上的，也就不在 shadow dom 里了，那 shadow dom 里给它加的样式自然就不生效了。

        scoped css 也就是对所有样式加了一层 data-qiankun=“应用名” 的选择器来隔离：弹窗样式还是会挂，没有global可以支持控制
        因为react 和 vue 项目本身都会用 scoped css 或者 css modules 的组件级别样式隔离方案，这俩方案都支持传递样式给子元素、设置全局样式等，
        只是实现和使用方式不同。
        global是什么，因为scoped css和css modules都会生成前缀，如果你想影响外面的组件，比如外面组件某个样式是 outside，你写样式控制他会被加前后缀导致
        控制不到外部组件，用global，被包裹在global里的样式就不会被加前后缀

        所以就是不用qiankun的样式隔离，自己做好父子应用间的样式隔离

    ssr
        SSR 普通的CSR就是单页面应用带来的问题，服务端请求到html时，是空白的html，这时候的页面就会出现白屏，
        如果是用SSR，会有一层中间层可以拿到已经渲染出来的html片段
        reactdomServer.renderToString
网络
    http状态码
        3xx 重定向  304协商缓存  没有更新  、
        301 表示永久重定向，302 表示临时重定向。
        如果浏览器收到的是 301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。
        但如果浏览器收到的是 302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。
        因此，301 适合地址永久转移的场景，比如域名变更；而 302 适合临时转移的场景，比如首页临时跳转到活动   页

        4xx  400 客户端请求报文有语法错误  401 需要有通过 HTTP 认证  403 禁止访问   404 找不到 
        405 不允许使用该方法访问  access-control-allow-Methods
        500 服务端报错

    get和post的区别  
        get不安全（其实都不安全，不过get直接裸露在Url上就显得更不安全了），有大小限制是因为url浏览器有长度限制
        get一般会有缓存，因为它是去服务器获取东西
        post不会有，因为它是去服务器改东西，缓存也没有意义

        浏览器在发送 GET 请求时，不会附带请求体
        刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。
        GET 请求的地址可以被保存为浏览器书签，POST 不可以

    http有哪些请求 get post put delete head   

    cdn是什么
      请求一个网站的请求过程 
      没有cdn的过程
        用户在自己的浏览器中输入要访问的网站域名。
        浏览器向本地DNS服务器请求对该域名的解析。
        本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。
        本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以迭代方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。
        浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址 。
        浏览器获取IP地址之后，经过标准的TCP握手流程，建立TCP连接。
        浏览器向服务器发起HTTP请求。服务器将用户请求内容传送给浏览器。
        经过标准的TCP挥手流程，断开TCP连接。

      引入了cdn的过程
        当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，
        则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。
        CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。
        用户向CDN的全局负载均衡设备发起URL访问请求。
        CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。
        基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的IP地址，
        最终将得到的IP地址返回给全局负载均衡设备：根据用户IP地址，判断哪一个边缘节点距用户最近；根据用户所请求的URL中携带的内容名称，
        判断哪一个边缘节点上有用户所需内容；查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。
        全局负载均衡设备把服务器的IP地址返回给用户。
        用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，
        而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

      cdn的组成
        中心节点
          中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理。

        边缘节点
          CDN边缘节点主要指异地分发节点，由负载均衡设备、高速缓存服务器两部分组成。
          中心节点就像仓配网络中负责货物调配的总仓，而边缘节点就是负责存储货物的各个城市的本地仓库。

设计模式
    发布订阅模式
        就是会有事件调度中心，然后会有订阅者会在什么订阅事件，发布者会发布事件，然后事件调度中心回去通知你，订阅者和发布者之间不会有任何联系

        class PubSub {
            constructor() {
                this.subscribers = [];
            }
            
            subscribe(topic, callback) {
                let callbacks = this.subscribers[topic];
                if (!callbacks) {
                    this.subscribers[topic] = [callback];
                } else {
                    callbacks.push(callback);
                }
            }
            
            publish(topic, ...args) {
                let callbacks = this.subscribers[topic] || [];
                callbacks.forEach(callback => callback(...args));
            }
        }
        
        // 创建事件调度中心，为订阅者和发布者提供调度服务
        let pubSub = new PubSub();
        // A订阅了SMS事件（A只关注SMS本身，而不关心谁发布这个事件）
        pubSub.subscribe('SMS', console.log);
        // B订阅了SMS事件
        pubSub.subscribe('SMS', console.log);
        // C发布了SMS事件（C只关注SMS本身，不关心谁订阅了这个事件）
        pubSub.publish('SMS', 'I published `SMS` event');

    观察者模式
        被观察触发事件时，会去通知所有的观察者去更新，观察者想要订阅目标事件，只能将自己添加到被观察者中去进行管理，观察者和被观察者之间有很强的依赖关系
        class Subject {
            constructor() {
                this.observers = [];
            }
        
            add(observer) {
                this.observers.push(observer);
            }
        
            notify(...args) {
                this.observers.forEach(observer => observer.update(...args));
            }
        }
        
        class Observer {
            update(...args) {
                console.log(...args);
            }
        }
        
        // 创建观察者ob1
        let ob1 = new Observer();
        // 创建观察者ob2
        let ob2 = new Observer();
        // 创建目标sub
        let sub = new Subject();
        // 目标sub添加观察者ob1 （目标和观察者建立了依赖关系）
        sub.add(ob1);
        // 目标sub添加观察者ob2
        sub.add(ob2);
        // 目标sub触发SMS事件（目标主动通知观察者）
        sub.notify('I fired `SMS` event');
    
    单例模式
        class Singleton {

          constructor(name) {
            this.name = name
            this.instance = null
          }

          getName() {
            alert(this.name)
          }

          static getInstance(name) {
            if (!this.instance) {
              this.instance = new Singleton(name)
            }
            return this.instance
          }
        }

        const instanceA = Singleton.getInstance('seven1')
        const instanceB = Singleton.getInstance('seven2')

    工厂模式  
        将 new 操作单独封装，只对外提供相应接口；
        遇到new 时，就要考虑是否应该使用工厂模式；

        比如你现在有一个汽车有很多零件，轮胎，方向盘，那你需要用new很多个类，这时候你就可以用工厂模式，直接封装好，就不用在外面new了

        // 定义产品
        class Product {
            constructor(name) {
                this.name = name;
            }
            init() {
                console.log('初始化产品')
            }
        }

        // 定义工厂
        class Factory {
            create(name) {
                return new Product(name); // 核心思想
            }
        }

        let c = new Factory(); 
        let p = c.create('p1');
        p.init();


    装饰者模式  有点像高阶函数和es7的decorator，其实就是再不改变原来类的情况下， 对这个类进行增强
        class Circle {
            draw() {
                console.log('画一个圆形');
            }
        }

        class Decorator {
            constructor(circle) {
                this.circle = circle;
            }
            draw() {
                this.circle.draw();
                this.setRedBorder(circle);
            }
            setRedBorder(circle) {
                console.log('画一个红色边框');
            }
        }

        let circle = new Circle();
        let decorator = new Decorator(circle);
        decorator.draw(); //画一个圆形，画一个红色边框

项目/业务
    能大概讲一下你的项目吗
    要不要写lazada的项目，纠结

数据结构
    线性结构
        数组
          是一个连续的结构，靠下标查找速度会比较快，时间复杂度O(1)
          插入和删除会比较慢，因为需要移动元素，时间复杂度O(N)


        栈
          后进先出
          栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。
          从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端（栈顶）插入（push）和删除（pop）数据。
          薯片罐，薯片先扔进去的在栈底

          // Stack类
          function Stack() {
            this.items = [];

            // 添加新元素到栈顶
            this.push = function(element) {
              this.items.push(element);
            };
            // 移除栈顶元素，同时返回被移除的元素
            this.pop = function() {
              return this.items.pop();
            };
            // 查看栈顶元素
            this.peek = function() {
              return this.items[this.items.length - 1];
            };
            // 判断是否为空栈
            this.isEmpty = function() {
              return this.items.length === 0;
            };
            // 清空栈
            this.clear = function() {
              this.items = [];
            };
            // 查询栈的长度
            this.size = function() {
              return this.items.length;
            };
            // 打印栈里的元素
            this.print = function() {
              console.log(this.items.toString());
            };
          }

          // 创建Stack实例
          var stack = new Stack();
          console.log(stack.isEmpty()); // true
          stack.push(5); // undefined
          stack.push(8); // undefined
          console.log(stack.peek()); // 8
          stack.push(11); // undefined
          console.log(stack.size()); // 3
          console.log(stack.isEmpty()); // false
          stack.push(15); // undefined
          stack.pop(); // 15
          console.log(stack.size()); // 3
          stack.print(); // 5,8,11
          stack.clear(); // undefined
          console.log(stack.size()); // 0

        队列
          先进先出
          队列在尾部添加新元素，并从顶部移除元素。
          最新添加的元素必须排在队列的末尾。
          队列只有 入队 enqueue(向队列尾部添加新项) 出队 dequeue pop(移除队列的第一项，并返回被移除的元素)。

          // Queue类
          function Queue() {
            this.items = [];

            // 向队列尾部添加元素
            this.enqueue = function(element) {
              this.items.push(element);
            };

            // 移除队列的第一个元素，并返回被移除的元素
            this.dequeue = function() {
              return this.items.shift();
            };

            // 返回队列的第一个元素
            this.front = function() {
              return this.items[0];
            };

            // 判断是否为空队列
            this.isEmpty = function() {
              return this.items.length === 0;
            };

            // 获取队列的长度
            this.size = function() {
              return this.items.length;
            };

            // 清空队列
            this.clear = function() {
              this.items = [];
            };

            // 打印队列里的元素
            this.print = function() {
              console.log(this.items.toString());
            };
          }

          // 创建Queue实例
          var queue = new Queue();
          console.log(queue.isEmpty()); // true
          queue.enqueue('John'); // undefined
          queue.enqueue('Jack'); // undefined
          queue.enqueue('Camila'); // undefined
          queue.print(); // "John,Jack,Camila"
          console.log(queue.size()); // 3
          console.log(queue.isEmpty()); // false
          queue.dequeue(); // "John"
          queue.dequeue(); // "Jack"
          queue.print(); // "Camila"
          queue.clear(); // undefined
          console.log(queue.size()); // 0

        链表
          是一个不连续的结构，只能遍历查找速度会比较慢，时间复杂度O(N)
          插入和删除会比较快，不需要移动元素，只需要考虑相邻结点的指针改变，时间复杂度O(1)

          class LinkList {
            constructor() {

            }
            #head = null;
            #length = 0;
            #Node = class{
                constructor(element) {
                    this.element = element;
                    this.next = null;
                }
            }

            append = (element) => {
                const node = new this.#Node(element);
                let currentNode = this.#head;
                if(this.#head){
                    while(currentNode.next){
                        currentNode = currentNode.next;
                    }
                    currentNode.next = node;
                } else{
                    this.#head = node;
                }
                this.#length++;
            }

            insert = (position, element) => {
                if(position < 0 || position >= this.#length){
                    return false;
                }
                const node = new this.#Node(element);
                let previousNode;
                let currentNode = this.#head;
                
                if(position === 0){
                    node.next = this.#head;
                    this.#head = node;
                }
                for(let i = 0; i < position; i++){
                    previousNode = currentNode;
                    currentNode = currentNode.next;
                }

                previousNode.next = node;
                node.next = currentNode;

                this.#length ++;
            }

            // 从链表的特定位置移除一项
            removeAt = (position) => {
                if ((position < 0 && position >= this.#length) || this.#length === 0) {
                        // 越界
                        return false;
                } else {
                        var currentNode = this.#head;
                        var previousNode;

                        if (position === 0) {
                                this.#head = currentNode.next;
                        } else {
                                // 循环找到位置

            for(let i = 0; i < position; i++){
                previousNode = currentNode;
                currentNode = currentNode.next;
            }
                                // 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点
            previousNode.next = currentNode.next;
                        }

                        this.#length--;
                }
            };

            // 从链表中移除指定项
            remove = (element) => {
                var index = this.indexOf(element);
                return this.removeAt(index);
            };

            list = () => {
                return this.#head;
            };

            // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值
            toString = () => {
                var currentNode = this.#head;
                var string = '';

                while (currentNode) {
                        string += ',' + currentNode.element;
                        currentNode = currentNode.next;
                }

                return string.slice(1);
            };

            // 打印链表数据
            print = () => {
                console.log(this.toString());
            };


            // 返回元素在链表的索引，如果链表中没有该元素则返回 -1
            indexOf = (element) => {
                var currentNode = this.#head;
                var index = 0;

                while (currentNode) {
                        if (currentNode.element === element) {
                                return index;
                        }

                        index++;
                        currentNode = currentNode.next;
                }

                return -1;
            };
          }

          const linkList = new LinkList();

          linkList.append('Tom');
          linkList.append('Peter');
          linkList.append('Paul');

          linkList.insert(1, 'Jack');
          linkList.print(); // "Tom,Jack,Peter,Paul"

    非线性结构
        堆
        二叉树
        图

算法
    基本排序算法
        冒泡排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898b4742e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function bubleSort(arr) {
            var len = arr.length;
            for (let outer = len ; outer >= 2; outer--) {
                for(let inner = 0; inner <=outer - 1; inner++) {
                    if(arr[inner] > arr[inner + 1]) {
                        [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]
                    }
                }
            }
            return arr;
        }
        选择排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc899fabfa0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function selectSort(arr) {
            var len = arr.length;
            for(let i = 0 ;i < len - 1; i++) {
                for(let j = i ; j<len; j++) {
                    if(arr[j] < arr[i]) {
                        [arr[i],arr[j]] = [arr[j],arr[i]];
                    }
                }
            }
            return arr
        }
        插入排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898df137f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function insertSort(arr) {
            for(let i = 1; i < arr.length; i++) {  //外循环从1开始，默认arr[0]是有序段
                for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中
                    if(arr[j] < arr[j-1]) {
                        [arr[j],arr[j-1]] = [arr[j-1],arr[j]];
                    } else {
                        break;
                    }
                }
            }
            return arr;
        }
    高级排序算法
        快速排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898c22284~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function quickSort(arr) {
            if(arr.length <= 1) {
                return arr;  //递归出口
            }
            var left = [],
                right = [],
                current = arr.splice(0,1); //注意splice后，数组长度少了一个
            for(let i = 0; i < arr.length; i++) {
                if(arr[i] < current) {
                    left.push(arr[i])  //放在左边
                } else {
                    right.push(arr[i]) //放在右边
                }
            }
            return quickSort(left).concat(current,quickSort(right)); //递归
        }
        希尔排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898c88c5f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        insertSort(arr,[3,2,1]);
          function shellSort(arr,gap) {
              console.log(arr)//为了方便观察过程，使用时去除
              for(let i = 0; i<gap.length; i++) {  //最外层循环，一次取不同的步长，步长需要预先给出
                  let n = gap[i]; //步长为n
                  for(let j = i + n; j < arr.length; j++) { //接下类和插入排序一样，j循环依次取后面的数
                      for(let k = j; k > 0; k-=n) { //k循环进行比较，和直接插入的唯一区别是1变为了n
                          if(arr[k] < arr[k-n]) {
                              [arr[k],arr[k-n]] = [arr[k-n],arr[k]];
                              console.log(`当前序列为[${arr}] \n 交换了${arr[k]}和${arr[k-n]}`)//为了观察过程
                          } else {
                              continue;
                          }
                      }
                  }
              }
              return arr;
        }

其他
    输入一个url
      dns解析，找到对应ip
      TCP三次握手四次挥手建立连接
      从服务器请求资源 https
      请求到html
      dom tree，cssom tree  
      render Tree
      js 加载 加载完之后渲染页面

      浏览器自动补全协议、端口
      浏览器自动完成url编码
      浏览器根据url地址查找本地缓存，根据缓存规则看是否命中缓存，若命中缓存则直接使用缓存，不再发出请求
      通过DNS解析找到服务器的IP地址
      浏览器向服务器发出建立TCP连接的申请，完成三次握手后，连接通道建立
      若使用了HTTPS协议，则还会进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2
      浏览器决定要附带哪些cookie到请求头中
      浏览器自动设置好请求头、协议版本、cookie，发出GET请求
      服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。
      浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接。
      浏览器根据响应状态码决定如何处理这一次响应
      浏览器根据响应头中的Content-Type字段识别响应类型，如果是text/html，则对响应体的内容进行HTML解析，否则做其他处理
      浏览器根据响应头的其他内容完成缓存、cookie的设置
      浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源
      解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），随后对渲染树中的每个节点计算位置和大小（reflow），最后把每个节点利用GPU绘制到屏幕（repaint）
      在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件

    nginx

    async await 原理
    其实就是 

    工作中遇到的问题
        load chunk failed  没有增量更新，删除了老的文件，那怎么解决呢
        监听报错事件，如果error报错信息里有loading chunk的字眼，就刷新页面
          window.addEventListener(
          'error',
          function (event) {
            if (
              event.message &&
              String(event.message).includes('Loading chunk') &&
              String(event.message).includes('failed')
            ) {
              window.location.reload();
            }
          },
          true,
        );
        css样式命名规范(css隔离问题)   BEM   模块+元素+修饰
        巨石应用构建问题   只构建需要构建的部分，可以用git检测更新的部分
        页面卡顿排查，内存泄漏排查问题（memory，performance）   
          performance分析有任务因为js中的两个计算量都很大，所以有两个long task的提示，我们的目标就是去优化掉long task
          memory中可以看有没有占用内存大小特别高的变量
        nodejs断点  
          使用node --inspect-brk 和 chrome devTool 结合使用
          或者 vscode
          vscode需配置 .vscode/launch.json

    文件上传如何做断点续传
        客户端将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时附带其序号。
        服务器接收到每片数据时，将其保存成一个临时文件，并记录每个文件的 hash 和序号。
        若上传中止，将来再次上传时，可以向服务器索要已上传的分片序号，客户端仅需上传剩余分片即可。
        当全部分片上传完成后，服务器按照分片的顺序组装成完整的文件，并删除分片文件。

    webSocket
        websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，
        然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。
        首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，
        请求行中的 path 需要使用ws:开头的地址，请求头中要分别加入upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version标记
        然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含Switching Protocols，
        同时响应头中包含upgrade、connection、Sec-WebSocket-Accept标记
        当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。

        webSocket 与传统的 http 有什么优势
        当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成:
        第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据
        第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。
        响应后，客户端立即又发起一次请求，重复整个流程。
        无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，
        无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。
        websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，
        服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。
