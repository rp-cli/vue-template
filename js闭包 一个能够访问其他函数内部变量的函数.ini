js闭包  一个能够访问其他函数内部变量的函数
最常见的方式  函数里面return一个新的函数

闭包的弊端  内存泄漏，函数执行完之后，内部的变量应该被销毁，但是闭包使变量不会被销毁，从而造成内存泄漏
闭包的作用  方法和属性的私有化


this指向，到这个函数的直接调用位置

由new调用：绑定到新创建的对象
由call或apply、bind调用：绑定到指定的对象
由上下文对象调用：绑定到上下文对象
默认：全局对象

箭头函数 继承外层函数调用的this绑定

原型链 如果你有一个对象，你想使用一个它的属性，如果你找不到这个属性，就会_proto这个属性找到它的构造函数的protoType这个对象上去查找这个属性
parent._proto = Parent.prototype;
js中万物皆对象  分为普通对象和函数对象  普通对象的构造函数是Object，函数对象的构造函数是Function，原型链的顶端Object.prototype._proto = null

继承 
1.call apply  使用call或apply方法，将父对象的构造函数绑定在子对象上
2.将构造函数的prototype执行要继承的构造函数的实例，然后改一下constructor
3.将构造函数的prototype直接指向要继承的构造函数
4.拷贝继承

事件循环 eventLoop js是单线程，如果没有eventLoop就发生堵塞，执行栈执行为同步任务后，会去检查微任务队列是否为空，如果微任务队列不为空，就执行完所有的
微任务，然后再去查看宏任务队列，执行完单个宏任务之后，再去检查微任务队列

pwa 
渐进式编程 
网页只有两个线程，js线程和GUI渲染线程，这两个线程是互斥的，为了在高耗时js运算时，UI页面仍可用，得额外开辟一个js线程来运行这些高耗时的代码，这就是web worker


web worker 
  new worker(url)
  message和postMessage
  只服务于注册它的页面，不同页面之间不能共享
  页面关闭时，该页面新建的web worker也会关闭，不会留在浏览器中

service worker 问到代码实现可能直接扑街
  navigator.register(url)
  不同页面之间可以共享，遵从同源策略
  注册的页面关闭也不会中断，会长留在浏览器中

es6有哪些用过的语法
const, let 暂时性死区，没有声明之前不能先使用
箭头函数  继承外层函数调用的this绑定
promise
async await
class
Map，Set  
Set是一种叫做无序且唯一集合的数据结构，使用场景 数组去重
Map是一种叫做字典的数据结构，使用场景 数据存储  键值对存储的方式  Map的key可以是任意值

WeakSet和set类似，也是不重复的值的集合，区别
  WeakSet 的成员只能是对象，而不能是其他类型的值
  WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
  应用场景：储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。用set或者其他数组之类的就不行，比如一个场景，你定义一个set去存储dom节点，如果这两个dom节点被删掉了，你需要手动把
  set dom的引用手动删除掉，如果你用weakSet，删除dom的时候便会自动删除

WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。

WeatMap和Map类似
  WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
  WeakMap的键名所指向的对象，不计入垃圾回收机制。
  应用场景：WeakMap 应用的典型场合就是 DOM 节点作为键名

  let myWeakmap = new WeakMap();
​
  myWeakmap.set(
   document.getElementById('logo'),
    {timesClicked: 0})
  ;
  ​
  document.getElementById('logo').addEventListener('click', function() {
   let logoData = myWeakmap.get(document.getElementById('logo'));
   logoData.timesClicked++;
  }, false);

这里这个dom要是被清掉了，那weakMap中这个对象就没了

因为WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历

WeakMap  

Symbol 是一种原始数据类型，表示独一无二的值。当你需要一个独一无二的值，就不需要去声明一些奇怪的字符串，可以用symbol代替，不说了，有点傻逼


css篇

react篇
react是什么，为什么要用react  react是前端现在比较流行的一个js库，不用手动操作dom，组件化，有成熟的生态
