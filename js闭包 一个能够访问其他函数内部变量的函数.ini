
待办
pmp是啥玩意
monorepo
虚拟列表实现
tree shaking 的实现
封装过的组件，上传组件  
写代码：求平均数
ES6，promise 链式调用如何实现；promise.then().catch().then().catch()

vite你还没看呢

h5真机调试 数据mock 抓包  vconsole  吗的都是集成的，搞屁
rem还是不懂啊  根元素字体大小怎么算
css变量居然可以用style或者class来控制碉堡了
 
--slide-size: 100%;
.adm-swiper-vertical{
  height: var(--slide-size);
}

JSBridge
需要native同学把东西注入到window上，然后前端同学去调用就完事了，windvane

hooks原理感觉还是不大清晰

alternate是干嘛的

requestIdleCallback window.requestIdleCallback() 方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，
如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。

IdleDeadline.timeRemaing
IdleDeadline 接口上的 timeRemaining() 方法返回当前空闲期间剩余的估计毫秒数。回调函数可以在任何时候调用此方法，以确定在必须返回之前它可以继续工作多长时间。
例如，如果回调完成了一个任务，并且有另一个任务要开始，它可以调用 timeRemaining() 来查看是否有足够的时间来完成下一个任务。如果没有，回调函数可以立即返回，或者用剩余的时间寻找其他合适的工作。
当 timeRemaining() 达到 0 时，建议回调应该将控制权返回给用户代理的事件循环。

算法  
小程序生命周期

本地有改动的时候想拉代码，本来必须得提交一下代码，才能pull代码
用这个可以先存起来本地的改动，pop是恢复，应该就是弄个栈存了一下
git stash
git stash pop

css背景图片拉伸 background repeat

移动端千万别用骚样式，出bug你就裂开了
JSBridge 蓝牙功能

aria-hidden="true"
svg use

javascript篇
    js闭包  一个能够访问其他函数内部变量的函数
    最常见的方式  函数里面return一个新的函数

    闭包的弊端  内存泄漏，函数执行完之后，内部的变量应该被销毁，但是闭包使变量不会被销毁，从而造成内存泄漏
    闭包的作用  方法和属性的私有化


    this指向，到这个函数的直接调用位置

    由new调用：绑定到新创建的对象
    由call或apply、bind调用：绑定到指定的对象
      fn.call(obj, arg1, arg2);
      fn.apply(obj, [arg1, arg2]);
      const fn = fn.bind(obj, arg1, arg2)  fn()

    new做了什么
    生一个空对象
    将构造函数的原型挂载在空对象的__proto__上
    构造函数在空对象的上下文中执行
    执行结果如果不是对象则返回上面生成的对象；

    function _new(constructor, ...args) {
        const context = Object.create(null, constructor.prototype)
        const result = constructor.apply(context, args);
        return typeof result === 'object' ? result : context;
    }

    由上下文对象调用：绑定到上下文对象
    默认：全局对象

    箭头函数 继承外层函数调用的this绑定

    原型链 如果你有一个对象，你想使用一个它的属性，如果你找不到这个属性，就会通过_proto这个属性找到它的构造函数的protoType这个
    对象上去查找这个属性
    parent._proto = Parent.prototype;
    js中万物皆对象  分为普通对象和函数对象  普通对象的构造函数是Object，函数对象的构造函数是Function，原型链的顶端
    Object.prototype._proto = null

    继承 
    1.call apply  使用call或apply方法，将父对象的构造函数绑定在子对象上
    2.将构造函数的prototype执行要继承的构造函数的实例，然后改一下constructor
    3.将构造函数的prototype直接指向要继承的构造函数
    4.拷贝继承

    事件循环 eventLoop js是单线程，如果没有eventLoop就发生堵塞，执行栈执行为同步任务后，会去检查微任务队列是否为空，
    如果微任务队列不为空，就执行完所有的
    微任务，然后再去查看宏任务队列，执行完单个宏任务之后，再去检查微任务队列

    节流  彻底懂了，为了让他最后一次执行才设置的定时器
    function throttle(fun, delay) {
        let last, deferTimer
        return function (args) {
            let that = this
            let _args = arguments
            let now = +new Date()
            if (last && now < last + delay) {
                clearTimeout(deferTimer)
                deferTimer = setTimeout(function () {
                    last = now
                    fun.apply(that, _args)
                }, delay)
            }else {
                last = now
                fun.apply(that,_args)
            }
        }
    }
    const fuck = debounce(console.log, 200);
    window.addEventListener('scroll', () => fuck(1,2,3))

    防抖
    function debounce(fn, delay){
      let timer;
      return function(...arg){
        if(timer) clearTimeout(timer);
        timer = setTimeout(function(){
          fn.call(this, ...arg)
        },delay)
      }
    }

    const fuck = debounce(console.log, 200);
    window.addEventListener('scroll', () => fuck(1,2,3))

    js深拷贝拷贝的是存于内存中的真正的值，浅拷贝拷贝的是地址引用（指针）
    基本数据类型和引用数据类型
    栈内存一般储存基础数据类型
    堆内存一般储存引用数据类型

    类型判断
    Object.prototype.toString.call()

    pwa 
    渐进式编程 
    网页只有两个线程，js线程和GUI渲染线程，这两个线程是互斥的，为了在高耗时js运算时，UI页面仍可用，
    得额外开辟一个js线程来运行这些高耗时的代码，这就是web worker
    pwa 使用场景

    web worker 
      new worker(url)
      message和postMessage
      只服务于注册它的页面，不同页面之间不能共享
      页面关闭时，该页面新建的web worker也会关闭，不会留在浏览器中

    service worker 问到代码实现可能直接扑街
      navigator.register(url)
      不同页面之间可以共享，遵从同源策略
      注册的页面关闭也不会中断，会长留在浏览器中

    前端如何解决跨域问题
    什么是跨域
      一个域名分为  https://www.baidu.com:8080/xxx.json
      协议 子域名 主域名 端口号  资源地址（这个不同不算跨域哈）
      baidu.com 主域名（一级域名）  www.baidu.com 子域名（二级域名）

    跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
    所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script就可以跨域，
    因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，
    浏览器认为这不安全，所以拦截了响应。
    
    服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。感觉这个比较存疑，就不说了

    怎么解决跨域问题
      开发代理  什么是开发代理，利用webpack的proxy，或者是whistle之类的ip映射到域名上的操作
      jsonp  什么是jsonp，就是利用script标签可以跨域的原理，在服务端根据客户端传来的信息，查找数据库，然后返回
      一份可执行的javascript代码，
      客户端直接解析执行代码(因为是用script标签，所以返回来的javascript字符串就会被解析执行)，即调用 
      jsonpCallback() 函数，彻底懂了
    nginx代理跨域  反向代理

    cors 服务器设置相应头  好像前三个是一定要设置的
    Access-Control-Allow-Origin   允许访问的域名
    Access-Control-Allow-Method  允许访问的方法
    Access-Control-Allow-Headers  允许哪个头访问我
    Access-Control-Allow-Credentials  允许携带cookie
    Access-Control-Max-Age  预检的存活时间
    Access-Control-Expose-Headers  允许返回的头

    网络安全
    xss攻击就是脚本跨站攻击
    存储型 XSS  存到数据库里，比如评论区留言，留言个<script>alert</script>
    反射型 XSS  服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
    dom型 XSS  url上面参数搞个<script>alert</script>，前端直接拿参数

    前端做转义  对一些标签<>等特殊字符进行转义，服务端检测url中是否带有恶意代码，比如javascript script
    ; const escapeChar = unsafe => {
    ;   return unsafe
    ;       .replace(/</g, '&lt;')
    ;       .replace(/>/g, '&gt;')
    ;       .replace(/"/g, '&quot;');
    ;   };
    避免使用  dangerouslySetInnerHTML

    csrf
    csrf其实就是一个跨域请求，但是他攻击你访问过的网站能带上对应的cookie，一般就是表单提交资源嵌入
    大概过程就是：1.登陆www.A.com，浏览器有了cookie
                2.不小心访问了危险网站www.B.com,然后B发了一个请求给A，你这个请求的域名是www.A.com/xxxx，就是同源，所以能拿到A的cookie，
                然后就炸开了

    怎么防止csrf
    同源检测，请求中在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
    Origin Header
    Referer Header
    这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 
    服务器可以通过解析这两个Header中的域名，确定请求的来源域。
    cookie的同源策略  只要你请求某个域名，就会带上某个域名的cookie，可以用samesite去限制（就是跨域请求的时候不会带上cookie）
    cookie属性 domain path http-only secure samesite  expires/max-age  name value
    使用token，不用cookie

    为什么csrf其实是跨域请求，那却能成功，因为我们要正确的理解跨域请求是什么
    跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
    所以一些像表单提交（写入操作，比如表单提交，或者是资源嵌入，比如jsonp用的script）（csrf）就可以跨域，
    因为不用获取新的内容，ajax就会跨域，因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。

    es6有哪些用过的语法
    模块化 import/export
    模板字符串
    函数参数默认值
    解构赋值

    直接交换变量，交换两杯牛奶，一般需要第三个杯
    let x = 1;
    let y = 2;
    [x, y] = [y, x];

    扩展运算符(...)
    const, let 暂时性死区，没有声明之前不能先使用
    箭头函数  继承外层函数调用的this绑定
    includes；Object.values()；Object.entries()
    promise
    Promise.resolve().then(function() {
      console.log('promise1'); 
      //这里使用了链式调用，就算不return一个promise，它也能往下跑，因为then就是一个promise
      return Promise.resolve('我是value');
      // return '我是value'  // 等同于上面的效果
    }).then(function(value) {
      console.log('promise2');
      console.log(value, 'value');
    });

    输出
    promise1
    promise2
    我是value

    那then在没有返回值的情况下能返回一个fulfilled的promise, catch呢，我们试试吧
    居然和then是一个效果，我惊了，也不是不返回任何值的情况返回的是一个fulfilled的promise
    有一个很炫酷的东西，promise的值穿透

    Promise.resolve(1)
    .then(2)
    .then(Promise.resolve(3))
    .then(console.log)

    Promise.resolve(1)会返回一个promise对象并且会将1当做then的参数。而.then 或者 .catch 的参数期望是函数，
    传入非函数则会发生值穿透。所以最后会输出：1。

    // Promise.all
    export const all = (promiseArr) => {
      let result = [];
      let count = 0;
      return new myPromise((resolve, reject) => {
        for (let i = 0; i < promiseArr.length; i++) {
          Promise.resolve(promiseArr[i]).then(
            (res) => {
              result[i] = res;
              count++;
              // 全部promise执行成功之后才resolve
              if (count === promiseArr.length) {
                resolve(result);
              }
            },
            (err) => {
              reject(err);
            }
          );
        }
      });
    };

    // Promise.race
    export const race = (promiseArr) => {
      return new myPromise((resolve, reject) => {
        for (let i = 0; i < promiseArr.length; i++) {
          Promise.resolve(promiseArr[i]).then(
            (res) => {
              // 只要有任何一个f状态变更就resolve
              resolve(res);
            },
            (err) => {
              reject(err);
            }
          );
        }
      });
    };

    接口超过多少秒就报错，就可以用race
    promise.all 和 promise.race 最本质的差别，race只比谁快，快的先出来，不管你是resolve，还是reject
    promise.all 是只要有人报错，就会报错，不管那个错在前面还是在后面，不管是2s还是4s出错，出错的时候就弹出错误

    promise foreach无法串行，for循环，for of循环，reduce都可以，reduce初始值Proimse.resolve(), await prev, await cur就可以了

    async await Generator（yield，next） 的语法糖
    class //super作为对象在普通方法中调用时，指向的是父类的原型对象

    class Parent{  
        constructor(x,y){  this.x = x;
          this.y = y;
          this.p = 3;
        }
        toString(){
          return this.p;
        }
    }

    class Child extends Parent{  
        constructor(x, y, color) {
            super(x, y); // 调用父类的constructor(x, y)   
            //相当于 A.prototype.constructor.call(this)
            this.color = color;
        }  
        toString() {
            return this.color + super.p + ' ' + super.toString(); // 调用父类的toString()  
            //super作为对象在普通方法中调用时，指向的是父类的原型对象
            //super作为对象在静态方法中调用时，指向父类
        }
    }

    Map，Set  
    Set是一种叫做无序且唯一集合的数据结构，使用场景 数组去重
    Map是一种叫做字典的数据结构，使用场景 数据存储  键值对存储的方式  Map的key可以是任意值

    WeakSet和set类似，也是不重复的值的集合，区别
      WeakSet 的成员只能是对象，而不能是其他类型的值
      (Set里面的值可以是数组，只要是有iterable接口的数据接口，比如new Set([1,2,3]), 但是这里weakSet的值只能是对象，比如
      let ws = new WeakSet() ws.add({name: 'zzp'});)
      WeakSet 中的对象都是弱引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
      应用场景：储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。用set或者其他数组之类的就不行，比如一个场景，
      你定义一个set去存储dom节点，如果这两个dom节点被删掉了，你需要手动把
      set dom的引用手动删除掉，如果你用weakSet，删除dom的时候便会自动删除

      let obj1 ={name:"leslie1"};
      let obj2 ={name:"leslie2"};
      let ws = new WeakSet();
      let s = new Set();
      ws.add(obj1);
      s.add(obj2);
      // console.log(ws);
      // console.log(s);
      obj1=null;
      obj2=null;
      console.log(ws);  WeakSet里没有obj1了
      console.log(s);  Set里还有obj2

      let btn2 = document.getElementById('btn2');
      const ws = new WeakSet();
      ws.add(btn2);

    WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。

    WeatMap和Map类似
      WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
      WeakMap的键名所指向的对象，不计入垃圾回收机制。
      应用场景：WeakMap 应用的典型场合就是 DOM 节点作为键名

      let myWeakmap = new WeakMap();
    ​
      myWeakmap.set(
       document.getElementById('logo'),
        {timesClicked: 0})
      ;
      ​
      document.getElementById('logo').addEventListener('click', function() {
       let logoData = myWeakmap.get(document.getElementById('logo'));
       logoData.timesClicked++;
      }, false);

    这里这个dom要是被清掉了，那weakMap中这个对象就没了

    因为WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历

    WeakMap  

    Symbol 是一种原始数据类型，表示独一无二的值。当你需要一个独一无二的值，就不需要去声明一些奇怪的字符串，可以用symbol代替，不说了，有点傻逼
    Symbol.for  typeof 就是用的symbol

    js数组别忘了哟
    1.1 push  往数组的最后加入元素，改变原数组，返回新数组的长度
    1.2 unshift 往数组的开头加入元素，改变原数组，返回新数组的长度  
    1.3 pop 删除数组的最后一个元素，改变原数组，返回被删除的元素
    1.4 shift 删除数组的第一个元素，改变原数组，返回被删除的元素
    1.5 splice(index, count, value1, value2...) 删除数组中某个元素，改变原数组
    1.6 slice(start, end) 获取子数组，包含原数组索引start的值到索引end的值，不包含end，返回获取的子数组，不改变原数组
    1.7 includes 这个有，数组和字符串都可以用
    1.8 contains 没有contains这个玩意哈

    canvas  动画堵塞
    用过canvas 大概说一下画一个canvas的过程
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    // 清除画布
    ctx.clear();

    // 绘制直线
    ctx.moveTo(50, 50);
    ctx.lineTo(200, 200);
    ctx.stroke();

    // 绘制一个三角形
    ctx.moveTo(50, 50);
    ctx.lineTo(200, 200);
    ctx.lineTo(200, 50);
    ctx.lineTo(50, 50);
    ctx.stroke();

    // 绘制一个矩形边框
    ctx.strokeRect(50, 50, 200, 100);

    // 绘制一段圆弧
    ctx.arc(60, 60, 50, 0, Math.PI, false);
    ctx.stroke();

    // 画出一个半圆和一个整圆，关闭路径就不会连接起来
    ctx.beginPath() // 开启路径
    ctx.arc(60, 60, 50, 0, Math.PI, false);
    ctx.stroke();
    ctx.closePath() // 闭合路径
    // 绘制一个圆弧
    ctx.beginPath() // 开启路径
    ctx.arc(200, 60, 50, 0, Math.PI*2, false);
    ctx.stroke();
    ctx.closePath() // 闭合路径

    // 绘制椭圆
    ctx.ellipse(100, 150, 50, 100, 0, 0, 2 * Math.PI);
    ctx.stroke();

    // 贝塞尔曲线，其实就是画不规则的曲线，不是只能画圆


    // 二次贝塞尔曲线，只能弯曲一次的曲线
    ctx.moveTo(50, 50);
    // quadraticCurveTo(cp1x, cp1y, x, y)，其中cp1x和cp1y为一个控制点，x和y为结束点。
    ctx.quadraticCurveTo(200, 200, 350, 50);
    // 绘制
    ctx.stroke();

    // 三次贝塞尔曲线，能弯曲两次的曲线
    ctx.moveTo(50, 200);
    // ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x, y)，其中cp1x和cp1y为一个控制点，cp2x和cp2y为第二个控制点，x和y为结束点。
    ctx.bezierCurveTo(150, 50, 250, 350, 350, 200);
    // 绘制
    ctx.stroke();

    // 多次弯曲曲线，两条三次贝塞尔曲线拼起来就ok啦，只要不closepath就会连接起来，太牛逼了
    ctx.beginPath();
    ctx.moveTo(50, 50); // 起点位置
    ctx.bezierCurveTo(80, 0, 120, 100, 150, 50); // 前半段控制点和终点位置
    ctx.bezierCurveTo(180, 0, 220, 100, 250, 50); // 后半段控制点和终点位置
    ctx.stroke();

    // 绘制文本，stroke和fill的区别你肯定知道咯，这个就不多扯皮了
    ctx.strokeText(text, x, y, maxWidth)
    ctx.fillText(text, x, y, maxWidth)

    // 绘制图片
    ctx.drawImage(img, dx, dy);

    // 状态的保存和恢复
    // Canvas的状态是存储在栈中的，每次调用save()方法后，当前的状态都会被推送到栈中保存起来。薯片，后进先出，restore就会弹出，和pop一样，删除顶上的元素（和数组的删除最后一个元素一致）
    ctx.fillStyle = "#cccccc";
    ctx.fillRect(10, 10, 300, 100);
    ctx.save(); // 保存状态
    ctx.fillStyle = "#ee7034";
    ctx.fillRect(10, 150, 300, 100);
    ctx.restore(); // 还原到上次保存的状态
    ctx.fillRect(10, 300, 300, 100);

    // 

    svg

    // 画圆
    <svg>
      <circle cx="100" cy="100" r="100"/>  坐标，半径
    </svg>

    // 矩形
    <svg width="300" height="300">
      <rect x="0" y="0" rx="5" ry="5" width="300" height="200"/>
    </svg>

    // 椭圆
    <svg width="300" height="300">
      <ellipse cx="100" cy="100" rx="100" ry="50"/>
    </svg>

    // 画直线，这个比canvas简单
    <svg width="300" height="300">
      <!-- 不设置样式属性 style 是看不出效果的 -->
      <line x1="50" x2="50" y1="200" y2="50" style="stroke: #000000;"/>
    </svg>

    // 画折现，和canvas画三角形一个原理
    <svg width="300" height="300">
      <!-- 不设置样式属性style是看不出效果的 并且polyline默认为填充需要把fill属性设置为none -->
      <polyline points="0 0, 20 40, 70 80, 100 90, 200 30, 250 50" fill="none" style="stroke: #000000;" />
    </svg>

    // 多边形 polygon标签和polyline标签类似，都是由很多个点链接在一起的。但不同的是polygon路径中的最后一个点和第一个点是默认闭合的。
    <svg width="300" height="300">
      <!-- 不设置样式属性style是看不出效果的 并且polygon默认为填充需要把fill属性设置为none -->
      <polygon points="0 0, 20 40, 70 80, 100 90, 200 30, 250 50" fill="none" style="stroke: #000000;" />
    </svg>

    // path 路径  这个玩法和canvas的path差不多啊，Z表示是否闭合路径
    M = Move to
    L = Line to
    H = Horizontal Line to
    V = Vertical Line to
    Q = Quadratic Bezier Curve to  二次贝塞尔曲线
    T = Smooth Quadratic Bezier Curve to
    C = Curve to  三次贝塞尔曲线
    S = Smooth Curve to
    A = Elliptical Arc  A命令用于画弧形，它可以截取圆或椭圆的弧形成的曲线
    Z = close path

    <!-- 从起始点（50， 20）画一条到（250， 20）的直线 -->
    <path d="M50 20 L250 20" style="stroke: #000000;"/>

    <!-- 从起始点（50， 20）画一条X轴为250的水平直线 -->
    <path d="M50 20 H250" style="stroke: #000000;"/>

    <!-- 从起始点（50， 20）画一条Y轴为250的垂直直线 -->
    <path d="M50 20 V250" style="stroke: #000000;"/>

    注意连续的H命令和V命令取大值，200生效
    <path d="M50 20 H200 100" style="stroke: #000000;"/>
    <path d="M50 20 V200 100" style="stroke: #ff0000;"/>

    Z命令是一个闭合命令，他会从当前点画一条直线到路径的起始点。
    Z命令因为没有参数所以Z和z效果一样，所以不区分大小写，
    和canvas的closePath一个意思
    <path d="M50 20 H200 V200 Z" fill="none" style="stroke: #000000;"/>  

    Q x1 y1, x y 或者 q x1 y1, x y
    参数：x、y为终点位置，x1、y1为控制点。
    <path d="M50 100 Q 175 200 300 100" fill="none" style="stroke: #ff0000;"/> 

    C x1 y1, x2 y2, x y 或者 c x1 y1, x2 y2, x y
    参数：x、y为终点位置，x1、y1为曲线起始点的控制点，x2、y2为曲线终止的控制点。
    <path d="M50 50 C 100 100, 200 100, 250 50" fill="none" style="stroke: #000000;"/>

    A命令用于画弧形，它可以截取圆或椭圆的弧形成的曲线
    <path d="M10 100 50 100  A 30 50 0 0 1 150 100 L 200 100" fill="none" style="stroke: #ff0000"/>

    添加文字
    <svg width="300" height="300">
      <text x="50" y="50">Hello Svg !</text>
    </svg>

    x，y  字体坐标 可以是一个队列，控制每个字体
    <svg width="300" height="300">
      <text 
        x="30 60 90 120 150 180 210 240 270" 
        y="60 90 120 150 180 150 120 90 60"
        fill="#f00" 
        stroke="#0f0" 
        font-size="50"
        font-weight="bold" >
        Hello Svg !
      </text>
    </svg>

    dx，dy  相对于当前位置的偏移量 可以是一个队列，控制每个字体
    rotate  旋转  可以是一个队列，控制每个字体

    基础动画
    和css的transform差不多 translate  scale  rorate  skew
    <rect x="0" y="0"  width="100" height="50" fill="#ff770f" transform="translate(100, 50)"/>
    <rect x="0" y="100"  width="100" height="100" fill="#183c78"  transform="scale(1.5)"/>
    
    js控制 就是搞原生的dom操作，去setAttribute
    工具 greensock  gsap

    svg和canvas对比
    优点：
    svg与其他图片格式对比
    SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。
    SVG 支持文本渲染，canvas其实也支持...
    SVG可在图像质量不下降的情况下被放大和缩小
    svg可以通过可以通过css和js来控制，比如事件监听，css修改样式
    svg的动画可以通过css或者js来实现，canvas只能通过setInterval，setTimeout，requestAnimationFrame来实现

    缺点：
    SVG复杂度越高渲染速度就会越慢，在处理大型或复杂的图像时，SVG 可能会变得缓慢或卡顿。（任何过度使用DOM的应用都不快）
    SVG不适合游戏应用，只能结合Canvas来实现
    与 Canvas 相比，使用 SVG 可能需要更多的代码和工作量来实现相同的效果。

    canvas -> webgl -> three.js

    优点:
    处理大型或复杂的图像时性能更好

    缺点:
    位图，不能缩放
    不支持文本渲染，支持的好吧
    Canvas 不支持添加交互元素和动画效果，因此无法提供与 SVG 相同的用户体验。（
    可以说是不支持吧，但通过setInterval，setTimeout，requestAnimationFrame来重复清空画布，清空之前保存状态，然后恢复状态再绘制的方式，就是一帧一帧绘制上去，是可以实现动画的）

    ES6modules AMD,CMD,commonjs
    编译，执行 commonjs 就是nodejs那一套，modules.export, require, 用同步的方式读取（在执行代码的时候才去加载），
    因为是在服务器端，文件都在本地，所以没有问题
    AMD RequireJs  CMD seaJs
    AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。比如require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码
    而CMD则是在使用的时候就近定义 https://github.com/muwoo/blogs/issues/28
    ES6 modules import export,编译的时候直接就把对应的代码加载进来，执行的时候就不会有问题

css篇
    bfc  什么是bfc，块级格式化上下文
      如何生成BFC
      1、float：设置浮动
      2、overflow：auto，hidden
      3、position：设置absolute或者fixed
      4、display：inline-block、flex、inline-flex、table-cell、table-caption、


    权重
    flex: 1   flex-grow: 1  flex-shrink: 1  flex-basis: 0%
    剩余空间占多少
    压缩多少
    算完flex-basis再根据剩余空间来分配，有剩余按照flex-grow，长度不够按照flex-shrink（flex-basis不是auto的时候会覆盖width，是auto的时候则是width生效）

    css3新特性
      背景
      渐变
      转换和变形
      媒体查询
      动画：keyframes，过渡：transition

      @keyframes slidein {
          from { transform: translateX(-100%); }
          to { transform: translateX(0); }
      }

      @keyframes fadeout {
          from { opacity: 1; }
          to { opacity: 0; }
      }

      div.slidein {
          animation-name: slidein;
          animation-duration: 2s;
      }

      p.fadeout {
          animation-name: fadeout;
          animation-duration: 1s;
          animation-delay: 2s;
      }

    移动端方案
      淘宝方案  1rem等于根元素字体大小 缺点 字体也会跟着缩放  移动端方案
      const oHtml = document.getElementsByTagName('html')[0]
      const width = oHtml.clientWidth;
      // 320px的屏幕基准像素为12px
      oHtml.style.fontSize = 12 * (width / 320) + "px";
      或者直接width/ 10 直接暴力除以10就完事了

      一行css适配rem
      750是设计稿的宽度：之后的单位直接1:1使用设计稿的大小，单位是rem
      html{ font-size: calc(100vw / 750); }

      vw, vh  100vw就是整个屏幕大小，什么叫dpi，苹果的屏幕的1px相当于两2px，所以出图的话是乘以2出的
      不然图片放到苹果上面会模糊，自己要将像素除以2，除非是矢量图，就不会模糊，不然会模糊

      px2rem
      在 postcss.config.js 配置文件
      postcss-plugin-px2rem
       [
          'postcss-plugin-px2rem',
          {
              rootValue: 100,
              unitPrecision: 5,
              propWhiteList: [],
              propBlackList: [],
              exclude: ['/node_modules/'],
              selectorBlackList: ['noRem'],
              ignoreIdentifier: false,
              replace: true,
              mediaQuery: false,
              minPixelValue: 10
          }
       ]

      module.exports = {
        // 其他配置...
        plugins: {
          'postcss-px-to-viewport': {
            viewportWidth: 750, // 设计稿宽度
            unitToConvert: 'px', // 需要转换的单位，默认为"px"
            viewportUnit: 'vw', // 转换后的单位，默认为"vw"
            selectorBlackList: ['.ignore', '.hairlines'], // 不需要转换的类名
            minPixelValue: 1, // 最小的转换单位值
            mediaQuery: false,  // 控制是否允许将媒体查询中的 px 单位进行转换为 vw/vh 单位。
            exclude: [/(\/|\\)(node_modules)(\/|\\)/] // 排除第三方模块中的样式
          }
      }

      2倍图，3倍图

    scss 语法 &-  var.scss

    h5兼容性解决 

    吸顶效果（各机型兼容，比如刘海屏）
    直接可以用 position: sticky 粘性定位去实现，当离顶部还剩88px（为了不挡住顶部的导航栏）时，
    头部就会转变为 position: fixed 固定在头部
    .free-gift-header {
      position: sticky;
      top: 88px;
    }
    这里在部分有刘海屏的苹果机子上会有问题，需要做一个兼容
    .free-gift-header {
      position: sticky;
      top: 88px;
      top: calc(88px + constant(safe-area-inset-top)) ;
      top: calc(88px + env(safe-area-inset-top)) ;
    }
    env()和constant()，是IOS11新增特性，Webkit的css函数，用于设定安全区域与边界的距离

    clientWidth = width + padding  即f12显示的宽度 - border - scroll
    offsetWidth = width + padding + border + scroll（滚动条的宽度） 即f12显示的宽度  平时设置的宽度就是offsetWidth

    box-sizing 元素的高度包括边框和内边距。
    
    h5 头部 iphonex 适配
    刘海屏
    meta标签 content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    只有设置了 viewport-fit=cover，才能使用 env()。

    这两个是一个作用，渐进式兼容
    padding-top: constant(safe-area-inset-top);  /* 兼容 iOS < 11.2 */ 
    padding-top: env(safe-area-inset-top);  /* 兼容 iOS >= 11.2 */

    h5遇到的一些兼容问题
    1.样式设置overflow：scroll/auto时，IOS的滑动会卡顿
    -webkit-overflow-scrolling:touch

    1.5 还有一个 &::-webkit-scrollbar {
        display: none;
      }  
    可以隐藏滚动条

    2.ios input按钮设置了disabled属性为true时显示异常
    input[type=button]{
      opacity: 1
    }

    3.安卓手机下取消语音输入按钮
    input::-webkit-input-speech-button{
      display: none
    }

    4.安卓使用 line-height 实现文字垂直居中，发现文字偏上
    采用 flex 布局，align-items: center 来替代，兼容性更高

    5.一进页面就调用 focus()方法或者设置 autofocus 属性，输入框没有自动聚焦
    无解，在 iOS 系统中自动聚焦不被允许

    6.将日期（yyyy-mm-dd HH:mm:ss）转换成时间戳报错
    const date = '2022-09-22 12:00:00';
    // 下面写法iOS会报错无法解析
    const timeStamp = new Date(date).getTime();
    // 兼容写法如下，将横杠转换成斜杠
    const timeStamp = new Date(date.replace(/\-/g, '/')).getTime();

    7.经典1px解决方案 
    好像是安卓设别识别不了0.5px，稿子是要求1px
    1.直接写 0.5px  border:0.5px solid #E5E5E5
    2.用图片代替边框  border: 1px solid transparent；border-image: url('xxx.jpg') 2 repeat;
    3.伪元素先放大后缩小
    1px方案放大两倍是怎么搞的  缩放原点 0 0 没什么好疑问的
    目前大部分移动端UI采用该方案，全机型兼容。  
    在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，
    然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，
    把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。

    这有两种情况
    按钮边框  是一个正方形的，包裹起来的边框
    .button {
      padding: 0 12px;
      height: 30px;
      cursor: pointer;
      border: 1px solid #aaa;
      border-radius: 3px;
    }

    .button1::after {
      content: " ";
      width: 200%;
      height: 200%;
      position: absolute;
      top: 0;
      left: 0;
      border: 1px solid #aaa;
      transform: scale(.5);
      transform-origin: 0 0;
      box-sizing: border-box;
      border-radius: 6px;
    }

    一条0.5px的线，比如上边框
    .hairline{
      position: relative;
      &::after{
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        height: 1px;
        width: 100%;
        transform: scaleY(0.5);
        transform-origin: 0 0;
        background-color: #EDEDED;
      }
    }

    4.viewport + rem + js
    var viewport = document.querySelector("meta[name=viewport]");
    //下面是根据设备像素设置viewport
    if (window.devicePixelRatio == 1) {
        viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no');
    }
    if (window.devicePixelRatio == 2) {
        viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no');
    }
    if (window.devicePixelRatio == 3) {
        viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no');
    }
    var docEl = document.documentElement;
    var fontsize = 32* (docEl.clientWidth / 750) + 'px';
    docEl.style.fontSize = fontsize;


react篇
    react是什么，为什么要用react  react是前端现在比较流行的一个js库，不用手动操作dom，组件化，有成熟的生态

    react生命周期
    初始化阶段 
    comnentwillmount(废弃警告)（getDerivedStateFromProps）
      当父组件传递给子组件的props发生变化时，子组件可以通过getDerivedStateFromProps方法更新自己的state，以便重新渲染。
      
      很简单，就是更新的时候跑不到constructor里面去，就可以用这个getDerivedStateFromProps，以前我也用过componentWillReceiveProps
      实现过类似的功能

      constructor(props) {
        super(props);
        this.state = { count: props.value };
      }
      static getDerivedStateFromProps(props, state) {
        if (props.value !== state.count) {
          return { count: props.value };
        }
        return null;
      }
      static不能访问this

    render
    componentDidmount 

    更新阶段
    componentWillReceiveProps(废弃警告)(getDerivedStateFromProps)
    shouldComponentUpdate(nextProps, nextState)
    componentWillUpdate(废弃警告)
    render
    getSnapshotBeforeUpdate

    getSnapshotBeforeUpdate是一个在组件更新（即state或props发生变化）之后、
      它的返回值将作为componentDidUpdate方法的第三个参数传递进来。在 render 之后，即将对组件进行挂载时调用。
      理解getSnapshotBeforeUpdate的最常见应用场景是：当组件的某些 DOM 节点在更新前后发生了变化，我们需要获取这些变化前后的状态并进行一些操作。
      下面是一个例子，假设我们有一个聊天室应用，其中有一个聊天记录组件：

      class ChatLog extends React.Component {
        constructor(props) {
          super(props);
          this.chatLog = React.createRef();
        }

        getSnapshotBeforeUpdate(prevProps) {
          // 当消息列表发生变化时，获取当前滚动位置并保存
          if (prevProps.messages.length < this.props.messages.length) {
            const chatLog = this.chatLog.current;
            return chatLog.scrollHeight - chatLog.scrollTop;
          }
          return null;
        }

        componentDidUpdate(prevProps, prevState, snapshot) {
          // 当更新完成后，将滚动位置调整到之前保存的位置
          if (snapshot !== null) {
            const chatLog = this.chatLog.current;
            chatLog.scrollTop = chatLog.scrollHeight - snapshot;
          }
        }

        render() {
          return (
            <div className="chat-log" ref={this.chatLog}>
              {this.props.messages.map((message, index) => (
                <div key={index} className="message">
                  <div className="username">{message.username}</div>
                  <div className="content">{message.content}</div>
                </div>
              ))}
            </div>
          );
        }
      }

      export default ChatLog;
      
      在这个例子中，我们在组件的constructor方法中创建了一个ref，
      用来引用聊天记录组件的DOM节点。在getSnapshotBeforeUpdate方法中，
      我们判断了聊天记录组件的消息列表是否发生变化，如果是的话，我们就获取当前的滚动位置并保存。
      在componentDidUpdate方法中，我们将滚动位置调整到之前保存的位置。

      这样，当我们向聊天室中发送一条新消息时，聊天记录组件的高度将发生变化，
      getSnapshotBeforeUpdate方法将获取当前的滚动位置并保存，
      componentDidUpdate方法将滚动位置调整到之前保存的位置，从而实现了更好的用户体验。

    componentDidUpdate

    卸载阶段
    componentWillUnMount

    错误捕获
    static getDerivedStateFromError 在errorBoundary中使用，子组件崩溃了的情况（就是子组件的render报错了，子组件的dom都没了的那种
    ）会进到这个生命周期，你可以在这个生命周期返回hasError: true，如果hasError是true
    返回错误信息，是false，正常返回this.props.childrenss，注意：错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。
    生命周期和构造函数中 throw new Error也能捕获到

    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }

      static getDerivedStateFromError(error) {
        // 更新 state 使下一次渲染能够显示降级后的 UI 
        return { hasError: true };
      }

      componentDidCatch(error, errorInfo) {
        // 你同样可以将错误日志上报给服务器
        console.log(error, 'error');
        console.log(errorInfo, 'errorInfo');
      }

      render() {
        if (this.state.hasError) {
          // 在 render 函数中显示出错信息
          return <h1>Something went wrong.</h1>;
        }

        return this.props.children;
      }
    }

    class MyComponent extends React.Component {
      constructor(props) {
        super(props);
        this.state = { count: { num: 0 } };
        this.handleClick = this.handleClick.bind(this);
      }

      handleClick() {
        // 制造一个错误
        this.setState({ count: 1 });
      }

      render() {
        console.log(this.state.count, 'this.state.count');  
        return (
          <div>
            <h1>Count: {this.state.count.num.sth}</h1>
            <button onClick={this.handleClick}>Click Me</button>
          </div>
        );
      }
    }

    function App() {
      return (
        <ErrorBoundary>
          <MyComponent />
        </ErrorBoundary>
      );
    }

    export default App;

    componentDidCatch

    错误边界无法捕获以下场景中产生的错误：
      事件处理  比如点击事件中抛个error，自己用try。。。catch兜了
      异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）, 生命周期中使用就不行了，但是setTimeout setState可以
      服务端渲染
      它自身抛出来的错误（并非它的子组件）
    
    为什么要使用fiber架构
    react16使用了新的fiber架构，react15在reconciler是递归处理虚拟dom的，递归过程是不能中断的。如果组件树的层级很深，
    递归会占用线程很多时间，
    造成卡顿。
    react16的reconciler是可中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。
    react16还多了一个Scheduler调度器，当浏览器有剩余时间时通知我们，同时调度任务的优先级，高优任务优先进入Reconciler，
    react15中reconciler和rerender之前是交替工作的，
    react16 Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，
    Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，整个
    Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

    什么是fiber架构
    React16的Reconciler基于Fiber节点实现， fiber 架构是 React 在 16 以后引入的，之前是直接递归渲染 vdom，
    现在则是多了一步 vdom 转 fiber 的 reconcile，在 reconcile 
    的过程中创建 dom 和做 diff 并打上增删改的 effectTag，然后一次性 commit。这个 reconcile 是可被打断的，
    可以调度，也就是 fiber 的 schedule。
    fiber 节点由三个属性，children，return和sibling，是一个树状链表，每次中断都可以通过这个三个属性去继续更新
    作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
    作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

    react setState是同步还是异步
    react 16,17 
    在合成事件和钩子函数中是异步的，在原生和setTimeout中不是批量异步的
    异步不是说像setTimeout和Promise的那种异步，而是调用顺序的问题，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马
    拿到更新后的值
    react 18 createRoot全部是异步批量更新  

    const container = document.getElementById('root');
    const root = createRoot(container);
    const element1 = <MyComponent1 />;
    const element2 = <MyComponent2 />;
    root.render(element1, element2);

    react setState为什么有时是同步的，有时是异步的，其实和react的事件机制有关，react有一个legacy事件处理系统，
    batchedEventUpdates为批量更新的主要函数，
    React通过开关isBatchingEventUpdates来控制是否启用批量更新。但是如果是发生在setTimeout中,由于eventLoop 放在了下一次事件循环中执行，
    此时 batchedEventUpdates 中已经执行完isBatchingEventUpdates = false，所以批量更新被打破，我们就可以直接访问到最新变化的值了。

    react16事件机制
    react事件合成， onClick还是click，onChange变成change，blur，keydown，keyup
    react事件绑定  原本的dom上会绑定一个noop函数，即空函数，document上会绑定真正的函数（事件委托）
    // document.addEventListener('click',listener,false)
    react事件触发  大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如scroll事件），冒泡到document，
    document上绑的是dispatchEvent，点击就是调用dispatchEvent，点击的dom上获取原生时间，通过原生dom找到对应的fiber对象，
    fiber对象上的memoizedProps 和 pendingProps保存了我们的事件，将事件传到dispatchEvent里面触发

    /* 获取原生事件 e.target */
    const nativeEventTarget = getEventTarget(nativeEvent)
    /* 获取当前事件，最近的dom类型fiber ，我们 demo中 button 按钮对应的 fiber，我的理解应该是从fiber找到要执行的事件，
    fiber对象上的memoizedProps 和 pendingProps保存了我们的事件 */
    let targetInst = getClosestInstanceFromNode(nativeEventTarget); 
    /* 重要：进入legacy模式的事件处理系统 */
    dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst);

    如何通过原生的dom找到对应的fiber对象，react初始化的时候，用一个随机的 key internalInstanceKey 
    指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。

    react17
    1 事件统一绑定container上，ReactDOM.render(app， container)，而不是document上，这样好处是有利于微前端的，
    微前端一个前端系统中可能有多个应用，
    如果继续采取全部绑定在document上，那么可能多应用下会出现问题。
    2 取消事件池 React 17 取消事件池复用

    react为什么要用这种事件合成模式呢
    一方面，将事件绑定在document统一管理，防止很多事件直接绑定在原生的dom元素上。造成一些不可控的情况，比如批量更新
    另一方面， React 想实现一个全浏览器的框架， 为了实现这种目标就需要提供全浏览器一致性的事件系统，以此抹平不同浏览器的差异。

    1 我们写的事件是绑定在dom上么，如果不是绑定在哪里？   不是，是绑定在document上的
    2 为什么我们的事件不能绑定给组件？  
    3 为什么我们的事件手动绑定this(不是箭头函数的情况)
    4 为什么不能用 return false 来阻止事件的默认行为？  
    合成事件中React 会对大多数事件执行用的 document.addEventListener()，
    所以不能用return false，需要用e.preventDefault()
    5 react怎么通过dom元素，找到与之对应的 fiber对象的？  React 在初始化真实 dom 的时候，用一个随机的 key
     internalInstanceKey 指针指向了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。
    6 onClick是在冒泡阶段绑定的？ 那么onClickCapture就是在事件捕获阶段绑定的吗？   
    是。 不是。 捕获是在事件插件系统的核心extractEvents中模拟的。

    js事件机制  事件捕获  事件冒泡
    假设现在的事件是点击上图中蓝色的<td>。
    那么当td的click事件发生时，会先走红色的「capture phase」：
    Document
    <html>
    <body>
    <table> 
    <tbody>
    <tr>
    <td> (实际被点击的元素)
    由上而下依序触发它们的click事件。

    然后到达「Target phase」后再继续执行绿色的「bubble phase」，反方向由<td>一路往上传至Document，整个事件流到此结束。

    addEventListener()基本上有三个参数，分别是「事件名称」、「事件的处理程序」(事件触发时执行的function)，以及一个「Boolean」值，
    由这个Boolean决定事件是以（true）「捕获」还是（false）「冒泡」机制执行，
    若不指定则预设为「冒泡」。和监听的顺序无关，就是从上到下，先捕获在冒泡

    如果想阻止冒泡，需要在儿子这一层设置stopPropagation(),因为是往上， 如果想阻止捕获，需要在父亲这一层设置stopPropagation()，因为是往下

    react和vue的区别
    模版不同
    react组件直接import，vue需要注册
    react推崇函数式，immutable，数据不可变
    vue不需要fiber，因为vue可以精确更新（因为它的观察者模式，vue使用 object.defineProperty 在 getter的时候进行依赖收集，
    将所有watcher对象的实例放到dep中
    在setter的时候调用dep的notify方法通知内部所有的watcher对象调用对应的update进行视图更新），react自顶向下更新
    vue是数据可变的，双向绑定，声明式的写法

    vue diff和react diff的区别
    react 从左到右
    vue2  首尾交叉对比
    vue3  首尾对比往中间收缩，最长递增子序列算法

    react受控组件与非受控组件  可以通过value和onchange去控制的组件，比如一个input框，选中失焦效果，这种就是非受控

    什么情况下要使用hooks，有些过哪些自定义hooks
    和状态有关系可以封装成一个hooks，useScroll下拉加载

    react有用过哪些hooks，useState，useMemo, useCallback, useEffect, useReducer
    useMemo可以返回一个缓存过的值， useCallback返回一个缓存过的回调函数，搭配React.memo做性能优化

    useLayoutEffect 和 useEffect

    useEffect 只会在render之后才会调用，也就是在浏览器绘制完后才调用，而且 useEffect 还是异步执行的，这就保证了不会阻塞浏览器的渲染过程。

    useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题,
    比如你点击一个按钮改变状态，然后在useEffect依赖这个状态，再次改变这个状态，很明显页面就会闪动，因为
    useEffect是在渲染之后异步加载的，很明显状态改动两次就会闪烁，useLayoutEffect是在渲染之前同步加载，
    所以你改变了第一次状态页面还没渲染之前，useLayoutEffect又改变了第二次状态，（堵塞了第一次状态改变之后的渲染），
    所以页面不会发生闪烁

    在useEffect中修改DOM相关的属性会看到页面有明显的闪动，和上面是一个意思
    useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。
    而 useLayoutEffect 就不一样，它会在渲染之前执行，而且是同步阻塞后面的流程。

    commit阶段有三个阶段，
    before mutation、
    mutation、React 会进行一系列的DOM节点更新
    layout
    具体操作 dom 的阶段是 mutation，操作 dom 之前是 before mutation，而操作 dom 之后是 layout。

    useReducer  const [state, dispatch] = useReducer();
    使用场景，但你一个操作需要更新多个state时，可以使用reducer，虽然useState可以放多个属性在一个状态里，但推荐你在一个 state 里放太多东西，
    因为它不会合并 state，用起来不方便

    react高阶组件  其实就是一个函数，返回一个增强过的组件，可以用来做组件复用

    为什么用hooks不用class component或者函数组件
    1.1 虽然React一直提倡的是我们能够函数组件，但是当我们发现函数组件中需要状态时，我们可能不得不将其改变成类组件
    1.2 在使用类组件时，我们不得不去通过箭头函数或者bind去绑定，而这又是比较消耗性能
    1.3 复杂的生命周期
    1.4 在复用组件时，难免要使用render Props或者HOC，这会使代码结构看起来极其复杂，HOC会让组件之间更多的嵌套

    key为什么不能是index  当同一层级的某个节点添加了对于其他同级节点唯一的key属性，当它在当前层级的位置发生了变化后。
    react diff算法通过新旧节点比较后，
    如果发现了key值相同的新旧节点，就会执行移动操作（然后依然按原策略深入节点内部的差异对比更新），而不会执行原策略的删除旧节点，创建新节点的操作。
    这无疑大大提高了React性能和渲染效率，
    但是如果key是index，如果出现顺序调换的问题，key值还是原来的key值，就不会进行移动操作，导致无法更新

    react diff算法是怎么样的
    如果是新的虚拟dom是单个节点，那就是直接去老的fiber里遍历，如果key相同，type相同，就搭上update标签，删掉其他的
    如果key不同，继续找下一个

    如果新的虚拟dom是多个节点，那就先进入第一轮遍历，遍历的时候一一对应，如果不能复用，就立马跳出第一轮循环，进入第二轮循环，
    将剩余的老fiber放入一个以老fiberkey或者索引为key，value为fiber节点的Map中，然后遍历新dom到map中去找有没有可以复用的节点，
    找到了就看这个节点的索引值是否大于lastplaceIndex，如果大就把lastplaceIndex置为这个fiber的索引，然后从map中删除该节点
    如果小于lastPlaceIndex，就打上移动的标签，(
      其实就是插入，插到父fiber的最后面，这里很神奇，比如你现在是
      <ul>
        <li>A</li>
        <li>B</li>
        <li>C</li>
      </ul>
      然后你用js获取<li>A</li>,然后ul.appendChild(liA),就会变成
      <ul>
        <li>B</li>
        <li>C</li>
        <li>A</li>
      </ul>，而不是
      <ul>
        <li>A</li>
        <li>B</li>
        <li>C</li>
        <li>A</li>
      </ul>

      Node.appendChild() || Node.insertBefore() 方法将一个节点附加到指定父节点的子节点列表的末尾处。如果将被插入的节点已经存在于当前文档的文档树中，
      那么 appendChild()  || Node.insertBefore() 只会将它从原先的位置移动到新的位置（不需要事先移除要移动的节点）。 
      原来如此  --- mdn

    )，最后看老fiberMap中有剩余节点就删掉，新dom中在老fiber
    找不到的就插入

    更新两个阶段
    render  根据老的fiber树和新的vdom创建新的fiber树并找出差异，也就是diff的结果
    commit  根据diff结果更新真实DOM
    更新完了之后新的fiber树就成为fiberRoot.current
    commit阶段不能中断
    render阶段可以中断

    A B C D E   结束循环，遍历
    E A B C D
    移动4个，老fiber只会右移，不会左移，或者最靠谱就是根据lastPlaceIndex来判断

    首先从rootfiber开始向下优先遍历，为遍历到的每个fiber调用beginwork方法，根据diff算法判断是否是复用还是遍历还是删除，
    打上对应的flags，遍历到没有子节点时，如果没有子节点了，就走completework方法，并且在父fiber的effect链表上添加effect，
    如果父fiber已经有firstEffect了，就将父fiber的effect上放到链表的尾部，一直往上直到根节点，然后根据
    rootFiber上的effect链表去更新dom，把current指针指向构建完成的workingProgress树，也就是新的fiber树
    为什么删除的副作用会在最前面
    放到链表前面就先删除了，是怎么放的，那我就不知道了哈哈

    补全从触发状态更新到render阶段的路径。
    有几种方法可以触发react的更新
    ReactDOM.render —— HostRoot   这个其实也是在 pending里面放了update，不过update.payload 是 element
    this.setState —— ClassComponent   这个其实也是在 pending里面放了update，不过update.payload 是 this.setState的第一个传参
    this.forceUpdate —— ClassComponent
    useState —— FunctionComponent
    useReducer —— FunctionComponent

    这里讲的是ClassComponent的setState
      setState之后会发生什么
      对应的fiber节点上的updateQuene.shared.pending链表上会插入最新的update，shared.pending是一个单向的环状链表，
      此时shared.pending的环被剪开并连接在updateQueue.baseUpdate后面，接下来遍历updateQueue.baseUpdate链表，
      以fiber.updateQueue.baseState为初始state，依次与遍历到的每个Update计算并产生新的state，在遍历时如果有优先级低的Update
      会被跳过。当遍历完成后获得的state，就是该Fiber节点在本次更新的state（源码中叫做memoizedState）state的变化在
      render阶段产生与上次更新不同的vdom（jsx通过babel被编译成javascript对象，这里需要配置@babel/preset-react，这里面有将jsx
      编译成javascript的babel插件！！这里有疑问，应该是babel把jsx转移成React.createElement('div', { key: 'title', id: 'title'
      }),然后在createElement再搞成虚拟dom，这里createElement其实也是react实现的，也就是vdom也是react实现的，并不是插件实现的），
      通过Diff算法产生effectTag，在commit阶段渲染在页面上。渲染完成后workInProgress
      Fiber树变为current Fiber树，整个更新流程结束。 

      update的结构长这样，
      const update: Update<*> = {
        eventTime,
        lane,  // 优先级
        suspenseConfig,
        tag: UpdateState,
        payload: null,  更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参。
        callback: null,
        next: null,
      };

      react update的优先级是怎么决定的
      React中更新的优先级是通过“调度器”控制的。调度器使用优先级队列来按优先级排序和处理更新。不同类型的更新具有不同的优先级，
      例如用户交互更新（如点击按钮）的优先级比后台数据更新的优先级更高。当有多个更新需要处理时，React会使用优先级队列按照优先级顺序进行处理。
      这样可以确保高优先级更新尽快被处理，从而提高应用程序的性能和响应速度。

    下面讲一下hook的useState和useReducer
      hooks原理

      啊哈哈，老子终于知道怎么玩了
      hooks其实就是一个funcition Component嘛，当遇到这里是一个Function Component，就执行updateFunctionComponent
      （如果是原生组件就是执行updateHostComponent，还有classComponent，每种组件都有对应的标识，
      HostComponent是6，FunctionComponent是0）
      然后就是把这个function Component当成一个函数来执行，里面的钩子其实也是一个函数而已

      fiber tree上每个fiber节点都放了一个memorizeState去存储hook信息，是一个通过next串联的链表，这就是不能在if判断语句中使用hooks的原因
      每个节点的 memorizedState 属性上存放了对应的数据，
      然后不同的 hooks api 使用对应的数据（应该是遍历这个链表去拿对应的数据）来完成不同的功能。
      链表自然有个创建阶段，也就是 mountXxx，之后就不需要再 mount 了，只需要 update
      。所以每个 useXx 的实现其实都是分为了 mountXxx 和 updateXxx 两部分的。
      第一次执行 useXxx 的 hook 会走 mountXxx 的逻辑来创建 hook 链表，之后会走 updateXxx 的逻辑。

      const [name, setName] = useState("guang");
      useState('dong');
      const handler = useCallback((evt) => {
          setName('dong');
      },[1]);
      fiber: {
        memorizedState: {
          baseState: 'guang',
          memorizedState: 'guang',
          quene: {
            pending: // 和uploadPayload.shared.pending 一样，是环状链表，链接一个个update
          },
          next: {
            baseState: 'dong',
            memorizedState: 'dong',
            next: {
              memorizedState: [(evt) => {setName('dong')}, [1]]
              next: ...
            }
          },
        }
      }

      update的结构长这样，和classComponent的update不太一样哦
      const update = {  
        action,
        next: null
      }

      实际上hooks的setState实际调用的是dispatchAction.bind(null, hook.queue)

      function dispatchAction(queue, action) {
        // 创建update
        const update = {
          eventTime: eventTime,
          lane: lane,
          suspenseConfig: suspenseConfig,
          action: action,
          eagerReducer: null,
          eagerState: null,
          next: null
        }

        // 环状单向链表操作
        if (queue.pending === null) {
          update.next = update;
        } else {
          update.next = queue.pending.next;
          queue.pending.next = update;
        }
        queue.pending = update;

        // 模拟React开始调度更新
        schedule();
      }

      在schedule中，将workInProgressHook重置为fiber保存的第一个Hook，在组件render时，每当遇到下一个hooks，
      我们移动workInProgressHook的指针，只要每次组件render时useState的调用顺序及数量保持一致，那么始终可以通过workInProgressHook
      找到当前useState对应的hook对象。反正最后也是算出state，然后render阶段产生最新的vdom
      比如你的函数组件是这样的

      function test(){
        const [a, setA] = useState(0);
        const [b, setB] = useState(1);
        const [state, dispatch] = useReducer(reducer, { count: 0 });
      }

      遇到第一个hooks useState，看看fiber里有没有 memorizeState，没有就建一个 memorizeState: { memorizeState: 0, next: null}，
      然后加进去，然后将workInProgressHook指向这个memorizeState，此时workInProgressHook={ memorizeState: 0, next: null}
      到了第二hooks，因为fiber里已经有memorizeState了，就直接把workInProgressHook的next变成 { memorizeState: 1, next: null}，
      然后指向这个 { memorizeState: 1, next: null}，然后就调用scheduleUpdateOnFiber，找到根节点开始从上到下构建新的fiber tree
      
      其实useState就是调用的useReducer  useState = useReducer(null, initialState)
      useState的setXXX就是调用dispatchReducerAction，判断下reducer是不是空，不是空就memorizedState就等于reducer(hook.memorizedState, action)，
      因为 dispatch（action）
      是空就是返回isFn(action)? action(): action，因为setXXX可以传值也可以传函数

      useReducer是接受一个reducer和一个initialState，返回state和dispatch
      一开始的时候就是返回initialState，即memorizeState=initialState
      然后dispatch action会触发memorizeState改变

      useRef  将传进来的value包装成了一个拥有current属性的对象，冻结了一下，并将其放在memorizeState上， 
      update ref还是返回原来的对象，memoizedState保存{current: 1}
      useCallback memorizeState存储了一个数组，一个是传入的回调函数，一个是传入的dep，会将dep进行比较
      useMemo  useCallback保存的是callback函数本身，而useMemo保存的是callback函数的执行结果

      useEffect 的 hook 在 render 阶段会把 effect 放到 fiber 的 updateQueue 中，
      这是一个  next 串联的环形链表，lastEffect指向最后一个effect
      ，然后 commit 阶段会异步执行所有 fiber 节点的 updateQueue 中的 effect。
      useLayoutEffect 和 useEffect 中的effect存在两个不同的链表里
      useLayoutEffect 和 useEffect 差不多，区别只是它是在 commit 阶段的 layout 阶段同步执行所有 fiber 节点的 updateQueue 中的 effect。
      因为useEffect是在react组件render之后才会执行，所以在useEffect获取的状态一定是最新的，
      memoizedState保存包含useEffect回调函数、依赖项等的链表数据结构effect，effect链表同时会保存在fiber.updateQueue中
      为什么我们已经拥有hook链表了，为什么还要维护一个effect链表？
      是因为我们的hook链表不止包括useEffect还有其它hook，如果不引入这个链表的话，我们可能会多很多无用的遍历，故而再次又维护了一个effect对象的链表。
      这个链表结构是这样的
      const effect = {
        tag,  // 用来标志useEffect或者useLayoutEffect
        create,  // create是你传入的函数,deps是依赖项，next是下一个effect。
        destory,  // create是你传入的函数，destroy是create函数的返回值，可能是undefined
        deps,  // deps是依赖项
        next  // next是下一个effect。
      }

      useState 同样分为 mountState 和 updateState 两个阶段：
      mountState 会返回 state 和 dispatch 函数，dispatch 函数里会记录更新到 hook.queue，
      然后标记当前 fiber 到根 fiber 的 lane 需要更新，
      之后调度下次渲染。
      再次渲染的时候会执行 updateState，会取出 hook.queue，根据优先级确定最终的 state 返回，这样渲染出的就是最新的结果。
      memoizedState保存state的值

    function Greeting(props) {
      return (
        <div className="greeting">
          <h1>Hello, {props.name}!</h1>
          <p>Welcome to my website.</p>
        </div>
      );
    }

    Babel会将它转换成下面的JavaScript代码：
    function Greeting(props) {
      return React.createElement(
        "div",
        { className: "greeting" },
        React.createElement(
          "h1",
          null,
          "Hello, ",
          props.name,
          "!"
        ),
        React.createElement(
          "p",
          null,
          "Welcome to my website."
        )
      );
    }

    react再转成vdom， vdom长这样
    {
      "$$typeof": Symbol(react.element)
      "type": "ul",
      "key": "ul",
      "ref": null,
      "props": {
          "children": [
              {
                  "type": "li",
                  "key": "A",
                  "ref": null,
                  "props": {
                      "children": "A"
                  },
                  "_owner": null,
                  "_store": {}
              },
              {
                  "type": "li",
                  "key": "B",
                  "ref": null,
                  "props": {
                      "id": "B",
                      "children": "B"
                  },
                  "_owner": null,
                  "_store": {}
              },
              {
                  "type": "li",
                  "key": "C",
                  "ref": null,
                  "props": {
                      "children": "C"
                  },
                  "_owner": null,
                  "_store": {}
              }
          ]
      },
      "_owner": null,
      "_store": {}
    }


    react性能优化
      pureComponent  浅比较
        有一个很有意思的东西
        下面代码如果子组件使用了PureComponent，但是因为父组件传了一个函数过去，这个函数如果你是直接在onClick通过箭头函数或者bind(this)去传递函数，就会导致子组件重新渲染，即使
        子组件使用了pureComponent，如果你是在construtor中bind(this)，就不会，这说明了其实父组件rerender的时候只会跑更新时候的生命周期，不会去重新创建handleClick函数

        pureComponent不止可以浅比较props，还可以浅比较组件自身的state，比如我有一个PureComponent，里面有个
        state是1，如果是一般的classComponent，我只要setstate 1，就会rerender，但是PureComponent浅比较之后
        是原来的值，就不会rerender了，浅比较就是比较内存地址，原理应该是 利用 shouldComponentUpdate

        如果是在hooks里，就只能搭配 useCallback + React.memo 去进行优化了

          import React from 'react'

          class Child extends React.PureComponent {
            constructor(props) {
              super(props)
            }
            render() {
              console.log('child-re-render');
              return (
                <span onClick={this.props.onClick}>111</span>
              )
            }
          }

          class App extends React.Component {
            constructor(props) {
              super(props)
              this.state = {
                  count: 0
              }
              this.handleClick = this.handleClick.bind(this);
            }

            handleClick() {
              this.setState({
                  count: this.state.count + 1
              })
            }
            
            render() {
              return (
                <div>
                  {this.state.count}
                  <Child onClick={this.handleClick}/>
                  {/* <Child onClick={this.handleClick.bind(this)}/> */}  // 这两种方式都会导致子组件rerender
                  {/* <Child onClick={() => this.handleClick()}/> */}
                </div>
              )
            }
          }
          export default App;

      shouldComponentUpdate  可以自定义比较
      React.memo 搭配 useMemo，useCallback

    react组件通信
      父子 
      子父
        eventBus  
          import { EventEmitter } from "events";
          const eventBus = new EventEmitter();

          // 其实和dispatchEvent很像，都是一个玩法 
          eventBus.emit("childClick", "Hello World");
          eventBus.on("childClick", handleChildClick);

    hooks模拟classComponent生命周期
    模拟componentdidmount
    useEffect(() => {

    }, [])

    模拟componentDidUpdate
    const flag = useRef(false); 
    useEffect(() => {
      flag.current = true; 
      if(flag){
        // doSth
      }
    })

    模拟componentWillUnmount
    useEffect return
    即使组件没有卸载，cleanup 逻辑也会运行
    cleanup 函数不仅在卸载期间运行，也在每个依赖项变更的重新渲染前运行。

    首先import可以异步加载组件，也就是将这个Demo组件的js从main.js拆分出来，形成一个新的bar.js，
    webpackChunkName可以配置文件的名字
    和React-loadable好像一个意思
    
    const [Demo, setDemo] = useState(null);
    import(/* webpackChunkName: "bar" */ './useLayoutEffect').then((Module) => {
      console.log(Module, 'module');
      setDemo(() => Module.default);
    });

    react.lazy
    react suspense
    lazy一定要和suspense搭配才能使用，不然会报错，也会从把这个组件的js从main.js拆分出来，形成一个新的
    src_client_vitualListWithNoHeight_tsx.js
    const VirListNoHeight = lazy(() => import('./vitualListWithNoHeight'));
    <Suspense>
      <VirListNoHeight />
    </Suspense>

    suspense原理
    wookLoop的时候，检测到workInprogress是Suspense，进入beginwork方法中的updateSuspenseComponent，

    react-router  useNavigator replace: true 会替换history当前的历史，之前的那个就没了，
    意味着无法用浏览器的返回按钮返回到之前的页面，就是replaceState
    路由原理
      hash路由  
          hash路由通过a标签去跳转，因为是hash，页面不会刷新
          我们可以通过hashchange事件来监听当url的hash值变化时做处理，搞一个对象存储相应的callback，key是路由的路径
          刷新页面不会出发hashChange，但是可以通过load事件来监听刷新页面后要做的事

          hash路由为什么刷新能保存状态，因为先把hash值和对应的事件存到routes对象里面了，取一下hash值执行router[hash]()就完事了
          
      history路由
          history路由通过 history.pushState 去改变url，页面不会刷新，和a标签没有任何关系哈
          到现在还还没想明白，我晕....
          popstate只有history.go, back, forward时才会出发
          刷新状态也不会丢失，应该是匹配了一下路由执行了
    
    hash是在url上拼接/#url/，刷新页面不会有影响
    history是直接改变url，刷新页面会有影响，配置下nginx代理就行了，状态也不会丢失
    location / {
      try_files $uri $uri /index.html
    }

    react-router 都已经到6了  问到就是一个🐔

    react-router exact 
    <Route path="/" component={init} />
    <Route path="/about" component={About} />
    <Route path="/contact" component={Contact} />
    访问 "/" 会出来

    v5与v6的区别
    1.用<Routes> children形式替代<Switch>
    2.Route组件的render换为element
    3.去除Switch中的<Redirect>，用react-router-dom中的Redirect 替代，或者用 <Navigate> 实现
    4.子路由的渲染及Outlet的使用
    5.history对象废弃,路由跳转使用navigate代替
    6.删除match对象

    redux
      redux-thunk 本来action只能返回一对象，使用了之后可以返回一个函数，而且可以拿到dispatch和getState
        export const addTodo = (text) =>
          (dispatch, getState) => {  
              setTimeout(() => {    
                  dispatch({      type: 'ADD_TODO',      id: nextTodoId++,      text    })  }, 
          1000)}
        dispatch(addTodo('11'));

        export const addTodo = (text) => ({type： 'add', text})
        setTimeout(() => dispatch(addTodo('11')))

      redux-saga
        generator 问到就扑街

      immutable immer
      immutable 使用fromJS，改值用setIn，取值用getIn，immutable 有自己的数据结构，
      修改数据的时候会创建新的节点连接之前的节点组成新的数据结构。
      immer直接produce + draft搞定，心智负担没那么大，immer 没有自己的数据结构，
      它只是通过 Proxy 实现了代理，内部自动创建新的对象

      从性能上来说，如果有特别大的 state 的话，immutable 会好一些，因为他用的是专用数据结构，
      做了专门的优化，除此以外，immer 更好一些。
      
      ClassComponent
      immutable  挖草，看下面不怎么好用啊这个
      constructor(){
        this.state = {
          a: fromJS({
            b: 1
          })
        }
      }

      // 为什么要 sate.a 用 fromJS 转成 immutable，而不是整个 state 呢？
      因为 react 内部也会用到这个 state 呀，就比如上面那个浅比较那里，
      pureComponent的浅比较会比较state和props，然后是通过遍历新老状态的key去对比
      但是如果你用formJS包了一整个state，等下拿值需要用getIn去拿，那么浅比较会失效
      如果是在hooks里 就可以

      即为什么不是 this.state = formJs({
        a: {
          b：1
        }
      })
      
      xxx(){
        this.setState({
          a: this.state.a.setIn(['b'], 2)
        })
      }

      render(){
        return <div>{this.state.a.get('b')}</div>
      }

      immer 看起来香的一批啊，直接produce梭哈
      constructor(){
        this.state = {
          a: {
            b: 1
          }
        }
      }
      
      xxx(){
        this.setState((produce(this.state, (draft) => {
          draft.a.b = 2
        })))
      }

      render(){
        return <div>{this.state.a.b}</div>
      }

      FunctionComponent  // 这里就直接包了一整个状态
      immutable
      const [state, setState] = useState(fromJS({
        a: {
          b: 1
        }
      }))

      setState(state.setIn('a', 'b'), 2);

      return <div>{state.getIn('a', 'b')}</div>

      immer
      const [state, setState] = useState({
        a: {
          b: 1
        }
      })

      setState((produce(state, (draft) => {
          draft.a.b = 2
      })));

      return <div>{state.a.b}</div>

      redux
      immutable

      const initialState = fromJS({})

      function reducer(state = initialState, action) {
        switch (action.type) {
          case SET_NAME:
            return state.set('name', 'guang')
          default:
            return state
        }
      }
      // 取 store 的 state 要用 getIn 或 get：
      function mapStateToProps(state) {
        return {
          xxxx: state.getIn(['guangguang', 'guang']),
          yyyy: state.getIn(['dongdong', 'dong'])
        }
      }

      import { increment, decrement } from './actions';
      function mapDispatchToProps(dispatch) {
        return {
          onIncrement: () => {
            dispatch(increment());
          },
          onDecrement: () => {
            dispatch(decrement());
          }
        };
      };

      props中就能拿到xxxx，yyyy这两个状态和onIncrement，onDecrement这两个方法


      immer
      const reducer = (state = initialState, action) => {
        return produce(state, draft => {
          switch (action.type) {
            case 'SET_NAME':
              draft.name = 'guang';
              break;
            default:
              return draft;
          }
        });
      };

      function mapStateToProps(state) {
          return {
            xxxx: state.guangguang,
            yyyy: state.dongdong
          }
      }

      或者hooks中直接使用 
      const xxxx = useSelector(() => state.guangguang);
      const yyyy = useSelector(() => state.dongdong);

      搞清楚一个东西哈，useReducer是hooks中自带的hooks，它的正确用法是
      const [state, dispatch] = useReducer(reducer, { count: 0 });
      本来在传统classComponent中，reducer一般是要和redux，react-redux一起使用，但是hooks中不用这两个东西也能直接使用
      
      useSelector和useDispatch是react-redux中的东西，等同于classComopnent中的connent和mapStateToProps和mapDispatchToProps
      const count = useSelector(state => state.count);
      const dispatch = useDispatch();
      自己去dispatch action

      immer真香
      useImmer + immer  // 可以去掉produce了
      import { useImmer } from 'use-immer'；
      const [state, setState] = useImmer({
        a: {
          b: 1
        }
      })
      const [age, setAge] = useImmer(20); // 简单的基本类型还是和useState一样，不用draft了

      setState((draft) => {
          draft.a.b = 2
      }));

      setAge(age + 1);

      return <div>{state.a.b}</div>

      redux
      useImmerReducer
      import React from "react";
      import { useImmerReducer } from "use-immer";

      const initialState = { count: 0 };

      function reducer(draft, action) {
        switch (action.type) {
          case "reset":
            return initialState;
          case "increment":
            return void draft.count++;
          case "decrement":
            return void draft.count--;
        }
      }

      function Counter() {
        const [state, dispatch] = useImmerReducer(reducer, initialState);
        return (
          <>
            Count: {state.count}
            <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
            <button onClick={() => dispatch({ type: "increment" })}>+</button>
            <button onClick={() => dispatch({ type: "decrement" })}>-</button>
          </>
        );
      }

      hooks中rerender的条件是 使用Object.is判断
      Object.is() 也不等价于 === 运算符。Object.is() 和 === 之间的唯一区别在于它们处理带符号的 0 和 NaN 值的时候。
      === 运算符（和 == 运算符）将数值 -0 和 +0 视为相等，
      但是会将 NaN 视为彼此不相等。

      react中如何setState之后获取最新的状态！！！！！！！！！
      暂时只有下面这几种，或者就是把改变之后的值定义个变量直接传参到func里，简单粗暴
      function handleClick1() {
        const newCount = count + 1
        setCount(newCount);
        func(newCount)
      }

      const func = (newCount) => {
        console.log(newCount);
      };

        方案1 useEffect中一定可以
        方案2 setCount(prevCount => prevCount + 1);  // 只有在有闭包和竞态条件等问题时才需要使用
          多次使用 setCount的时候可以用到   这个是异步的问题
          setInterval的时候可以用到  这个是闭包导致的问题？感觉异步和闭包都有啊
          这个例子感觉像是异步的问题
          useEffect(() => {
            setInterval(() => {
              setCount((count) => count + 1);
            }, 500);
          }, []);
        
        方案3 
          import { useEffect, useState, useCallback } from 'react';
          const useSyncCallback = (callback: () => void) => {
            const [proxyState, setProxyState] = useState({ current: false });

            const Func = useCallback(() => {
              setProxyState({ current: true });
            }, [proxyState]);

            useEffect(() => {
              if (proxyState.current === true) setProxyState({ current: false });
            }, [proxyState]);

            useEffect(() => {
              proxyState.current && callback();
            });

            return Func;
          };

          export default useSyncCallback;

          const func = useSyncCallback(() => {
            console.log(count);
          });

          function handleClick1() {
            setCount(count + 1);
            func()
          }


      react闭包问题！！！！！！！！这应该是两个不同的问题，一般好像是定时器里会出现这种问题
        方案1 useRef
        // 这种就是闭包的问题了，你在外部setA，他还是一直console原来的值，解决
          useEffect(() => {
            setInterval(() => {
                console.log("hook state:", a)
            }, 1000)
          }, [])

        使用useRef解决
        const [a, setA] = useState(1)
        const ref = useRef()
        ref.current= a;
        
        useEffect(() => {
            setInterval(() => {
                console.log("hook state:", ref.current)
            }, 1000)
        }, [])

        方案2 useLatest

        const [a, setA] = useState(1);
        const latestARef = useLatest(a);

        useEffect(() => {
          setInterval(() => {
            console.log('Ahook state:', latestARef.current);
          }, 1000);
        }, []);

        方案3 使用组件之外的变量(跟useRef一个道理)

工程化篇
    Webpack是一个开源的JavaScript模块打包工具，它可以将多个JavaScript模块打包成一个或多个捆绑包，以便在浏览器中使用。
    Webpack的主要功能是对模块进行打包和优化，可以将各种类型的模块（包括JavaScript、CSS、图片、字体等）转换为浏览器可以识别的静态资源，
    并且可以通过插件机制进行扩展，实现更多的自定义功能。
    
    webpack构建过程
        参数解析
        读取入口文件
        调用loader编译文件
        收集依赖，babel进行解析
        生成chunk
        输出文件

        // 具体一点
        将命令行参数与 webpack 配置文件 合并、解析得到参数对象。
        参数对象传给 webpack 执行得到 Compiler 对象。
        执行 Compiler 的 run方法开始编译。每次执行 run 编译都会生成一个 Compilation 对象。
        触发 Compiler 的 make方法分析入口文件，调用 compilation 的 buildModule 方法创建主模块对象。
        生成入口文件 AST(抽象语法树)，通过 AST 分析和递归加载依赖模块。
        所有模块分析完成后，执行 compilation 的 seal 方法对每个 chunk 进行整理、优化、封装。
        最后执行 Compiler 的 emitAssets 方法把生成的文件输出到 output 的目录中。

    webpack里面有哪些配置项
        entry 入口文件
        output 输入chunk
        devtool  生成source-map
          随着各种打包工具的兴起，为了提高前端项目的性能和不同浏览器上的兼容性，我们线上环境的代码一般都要经过如下等处理：
          压缩混淆，减小体积
          多个文件合并，减少 HTTP 请求数
          将 es6+代码转换成浏览器能够识别的 es5 代码

          经过如上的步骤之后，我们代码的性能和兼容性提高了，然后由于转换后的代码和源代码的不同，会导致我们的开发调试变得很困难，SourceMap 的诞生就是为了解决如上问题的。
          简而言之，SourceMap 就是一个储存着代码位置信息的文件（并不是源码啊，只是一个存储着代码位置的文件），转换后的代码的每一个位置，所对应的转换前的位置。有了它，点击浏览器的控制台报错信息时，
          可以直接显示出错源代码位置而不是转换后的代码。

          bundled: 模块未分离
          generated: 模块分离，未经loader处理的代码
          transformed: 模块分离，经loader处理过的代码
          original: 自己写的代码，定位精确到行、列
          original lines: 自己写的代码，定位只精确到行

          点击控制台显示的报错信息能否准确跳转到具体的代码位置，看到的代码是编译过的代码还是源代码
          （有没有sourceMap决定能否跳转对应的源码位置，cheap有sourcemap但跳到的的源码是经过loader处理过的），
          开发要打包速度快且调试方便，直接eval-cheap-module-source-Map，生产环境下，我们不必过多关注打包性能，
          主要考虑 quality 代码的保护性、出错的定位速度以及安全性等。
          none，source-map，hidden-source-map(能看到编译过后的代码)，nosources-source-map（啥都看不到），
          cheap-module-source-map（可以看到源代码）

          sourceMap原理
          可以看到尾部有这句注释：
          //# sourceMappingURL=main.js.map
          正是因为这句注释，标记了该文件的 Source Map 地址，浏览器才可以正确的找到源代码的位置。sourceMappingURL 指向 Source Map 文件的 URL 。

        module loader webpack只识别js，用来处理其他文件，Loaders本身是一个函数，接受源文件作为参数，返回转换的结果。
        loader的执行顺序是 从下到上，
        从右到左 的顺序执行的，file-loader会把图片打成文件，但是url-loader会把图片打成base64写到js中，会导致js变大，使用limit
        常用的loader：style-loader（通过注入<style>标签将CSS插入到DOM中），
        css-loader（仅处理css的各种加载语法(@import和url()函数等),就像 js 解析 import/require() 一样），
        postcss-loader（PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 
        和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。
        PostCSS 在业界被广泛地应用。PostCSS 的 autoprefixer 插件是最流行的 CSS 处理工具之一。
        autoprefixer 添加了浏览器前缀，它使用 Can I Use 上面的数据。
        先postcss-loader，然后在less-loader/sass-loader,（这里说的是从上到下写，当然调用的时候是从下到上，也就是先调用了less-loader，然后再postcss-loader）
        官方是这么推荐的，

        module.exports = {
          ident: 'postcss',
          plugins: [
              // 解决flexbugs
              require('postcss-flexbugs-fixes'),
              require('autoprefixer')({
                  overrideBrowserslist: [
                      'Android 4.1',
                      'iOS 7.1',
                      'Chrome > 31',
                      'ff > 31',
                      'ie >= 8',
                      '> 1%', // 必须大于 1% 用户使用的浏览器
                      //'last 2 versions', // 所有主流浏览器最近的 2个版本
                  ],
                  grid: true,
              }),
          ],
          sourceMap: process.env.NODE_ENV === 'development',
        };

        sass-loader（解析scss，转换为css），
        babel-loader，file-loader，url-loader
        url-loader也是处理图片类型资源，只不过它与file-loader有一点不同，url-loader可以设置一个根据图片大小进行不同的操作，
        如果该图片大小大于指定的大小，
        则将图片进行打包资源，否则将图片转换为base64字符串合并到js文件里
        就不要file-loader了，url-loader设置大小，可以分别打到文件里或者打到资源里

        url-loader test: /\.(ttf|woff|woff2|eot|otf)$/,

        Webpack 5引入了Asset Modules，可以用于处理图片、字体等文件。Asset Modules会自动根据文件类型选择合适的处理方式，
        例如对于图片文件会使用"asset/resource"进行处理，对于字体文件会使用"asset/inline"，将文件转换成base64编码的格式。
        这个asset也可以把文件打成base64，和url-loader差不多，配置dataUrlCondition属性
        这个asset module可以打包几乎所有类型的文件
        {
            test: /\.png|jpg|gif|jpeg|svg/,
            type: 'asset',
            parser: {
                dataUrlCondition: {
                    maxSize: 10 * 1024,
                },
            },
            generator: {
                filename: 'images/[base]',
            },
        },

        Base64编码的图片具有以下优点和缺点：
          优点：
            可以直接将编码后的图片数据作为文本传输，避免了二进制数据传输可能出现的兼容性问题。
            Base64编码后的图片数据可以直接嵌入HTML、CSS或JavaScript代码中，无需使用img标签或CSS背景图等方式进行引用
            （还是需要的哈，src=“data:image/png;base64,iVBORw0KGgoAAAANSU...”）。
            使用Base64编码的图片可以减少HTTP请求次数，从而加快网页的加载速度。

          缺点：
            Base64编码后的图片数据会比原始的二进制数据增大约1/3左右，因此会增加网页的文件大小，如果图片过大，则会导致网页加载速度变慢。
            使用Base64编码的图片无法实现图片的懒加载和缓存功能，因为它们是以文本形式直接嵌入在代码中的，无法被浏览器识别和缓存。
            Base64编码的图片数据无法进行压缩和优化，因为它们已经是文本格式了，无法再进行压缩，而原始的二进制数据可
            以通过压缩算法进行压缩和优化。

        plugin webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作
        常用的plugin：HtmlWebpackPlugin，生成html文件,为html引入外部资源如script、link，将entry配置的相关入口

        CleanWebpackPlugin
        默认情况下，这个插件会删除webpack的output.path中的所有文件，以及每次成功重新构建后所有未使用的资源。
        这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，
        导致文件夹非常庞大。

        mini-css-extract-plugin
        本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件。
        需要搭配MiniCssExtractPlugin.loader使用，与style-loader冲突，style-loader会把文件里的css提取到style标签里
        use: [this.mode === 'dev' ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader'],
        plugins: [
          new MiniCssExtractPlugin({
            filename: '[name].css'
          })
        ],

        HotModuleReplacementPlugin 热更新

        DefinePlugin 创建一个在编译时可以配置的全局常量。这会对开发模式和生产模式的构建允许不同的行为非常有用 

        这两个都是看开发或者生产环境才使用的
        开发可以开，生产不开
        BundleAnalyzerPlugin 体积分析插件
          new BundleAnalyzerPlugin({
              analyzerMode: 'disabled', // 不启动展示打包报告的HTTP服务器
              generateStatsFile: false, // 要生成stats.json文件
          })
        "generateAnalyzFile": "webpack --profile --json > dist/stats.json", // 生成分析文件
        "analyz": "webpack-bundle-analyzer --port 8888 ./dist/stats.json" // 启动展示打包报告的http服务器
        
        开发可以开，生产不开
        SpeedMeasurePlugin 速度分析插件
        const smp = new SpeedMeasurePlugin()
        const isSmp = process.env.NODE_ENV === 'smp';
        isSmp ? smp.wrap(config) : config;

        "add": "ci add",
        "list": "ci list",
        "delete": "ci delete",
        "select": "ci select",
        "lint": "eslint src --max-warnings 0",
        "lint:quiet": "eslint --ext .ts,.tsx,.js,.jsx src --quiet",
        "stylelint": "stylelint --fix \"**/*.{css,scss}\" src",
        "prettier": "prettier src --write",
        "build": "NODE_ENV=production webpack --config ./config/webpack.prod.js",
        "dev": "NODE_ENV=development webpack-dev-server --open --config ./config/webpack.dev.js",
        "serve:smp": "NODE_ENV=smp node ./config/server.js",
        "serve": "NODE_ENV=development node ./config/server.js",
        "serve:s": "NODE_ENV=development DEV_ENV=entry.json node ./config/server.js",
        "analyzer": "webpack-bundle-analyzer --port 8888 ./build/stats.json",
        "webpack": "node --trace-deprecation node_modules/webpack/bin/webpack.js",
        "precommit-msg": "echo 'Pre-commit checks...' && exit 0"

        externals 打包的时候从输出的 bundle 中排除依赖，不过需要从页面上加载进相应的资源文件，一个换成多个

        optimization里面用的plugin
        optimization minizer 压缩代码，比如CssMinimizerPlugin，TerserPlugin
        SplitChunksPlugin  代码分割
        css压缩 CssMinimizerPlugin  
        js压缩 TerserPlugin

        resolve
          resolve.extensions
            在导入语句没带文件后缀时，webpack 会自动带上后缀后去尝试询问文件是否存在，查询的顺序是按照我们配置 的 resolve.extensions 顺序从前到后查找，webpack 默认支持的后缀是 js 与  json。
            举个🌰：如果我们配置 resolve.extensions = ['js', 'json']，那么 webpack 会先找 xxx.js
          resolve.alias
            alias 的意思为 别名，能把原导入路径映射成一个新的导入路径。     
            比如我们项目中可能会有一些相对路径的写法，就可以使用 alias 配置来减少查找过程；
            还比如我们经常使用的 react 库，其实我们可以直接使用其 dist 目录下打包好的 react.min.js，这样就能跳过耗时的模块解析
    
    webpack5 新特性
        tree shaking更加强大
        cache fileSystem本地 memory内存 支持持久化缓存，可显著提高构建速度

        output: {},
        cache: {
          type: 'memory', // 默认是memory
        },

    这两个应该是预加载webpack打包生成的文件
    webpack prefetch
    import(/* webpackPrefetch: true */ './path/to/LoginModal.js');

    webpack preload
    import(/* webpackPreload: true */ 'ChartingLibrary');

    用这个插件ResourceHintWebpackPlugin可以在html中插入外链，不需要是webpack打包生成的文件
    确保 webpack 的版本在 5 以上，并且正在使用 html-webpack-plugin。
    new ResourceHintWebpackPlugin([{
      rel: 'dns-prefetch',
      include: {
        hosts: ['//fonts.googleapis.com']
    }])

    babel是怎么编译的  AST   parse  transform  generate
    parse 阶段把代码从字符串转换为 AST（代码的树形结构），transform 阶段对 AST 做各种增删改，
    generate 阶段再把转换后的 AST 打印成目标代码并生成 sourcemap。
    babel-plugin 在aysnc函数里面插入try...catch，在try里面插入body里面的代码，然后生成AST节点替换原来的节点

    babel-preset  预设数组   @babel/preset-env  @babel/preset-react  @babel/preset-typescript
    babel-plugin  插件数组   @babel/plugin-transform-runtime   @babel/plugin-proposal-class-properties   
    @babel/plugin-syntax-dynamic-import
  
    preset-env preset-env 内部会自动（根据targets）引入相应的 plugin 来做 AST 的转换，主要是转换es6～es9的语法
    preset-env是ES语法插件的合集，官方已经不再推荐使用preset-201x之类的包，该包可以通过配置自动兼容代码，包括自动引入polyfill垫片
    处理新的API（例如：Promise,Generator,Symbol等）以及 实例方法（例如Array.prototype.includes等）。

    presets: ['@babel/preset-env',
      {
          targets: {
              browsers: ['> 5%', 'IE 10', 'iOS 7', 'Firefox > 20'],
          },
          useBuiltIns: 'usage', // 按需加载polyfill
          corejs: 2,
          modules: false,  // 是否将语法转化为es6module（modules.export）,默认转化为Commonjs语法
      },
    ]
    useBuiltIns  entry, usage 和 false。
    false 只做了语法转换， entry 引入了所有的es扩展包，不管用不用得着一股脑都打包进来，只有 usage 会自动检测代码中用到的功能
    自动引入模块（注：
    babel默认不会检测第三方依赖包代码，所以使用 usage 时，可能会出现引入第三方的代码包未注入模块而引发bug）。
    所以，这里如果不考虑代码包大小，你可以选择 entry 方式。而如果你需要代码尽可能的精简，则使用 usage，这也是官方推荐的用法。

    我们知道，ES+中不仅包含新增的语法（如箭头函数、类），还有一些实例的扩展（Array.prototype.includes等），以及很多内置函数
    （如Promise、Symbol）。
    然而preset-env在不引入polyfill时，对于处理这些应用场景是无能为力的。而为了解决这样的问题，我们通常有两种方法：
    使用 Polyfill 或 Babel-runtime 
    进行功能填充。接下来我们会举例说明两者的优缺点以及应用场景。(其实useBuiltIns设置成usage就可以自动引入需要的polifill了)

    @babel/plugin-transform-runtime
    babel-runtime 开发类库/工具（生成不污染全局空间和内置对象原型的代码）, 借助 @babel/runtime 中帮助函数
    （helper function）移除冗余工具函数
    Babel >= 7.4.0  安装 core-js 替代 babel-polyfill ，而 regenerator-runtime 会在我们安装 @babel/runtime 
    时自动安装，所以不必单独安装了。
    Babel <= 7.4.0  开发类库, 选择 @babel/runtime, 内部项目，@babel/polyfill

    结合一下代码我们可以看出，corejs: false 其实等同于使用 @babel/polyfill 时的 useBuiltIns: false，
    只对ES语法进行了转换。corejs：2 等同于 Babel 6时的 polyfill: true ，
    它们都会为代码创建一个沙盒环境，为 core-js 提供假名，这样就做到了不污染全局空间。corejs: 3 是在 corejs: 2
    的基础上进而解决了之前无法实例方法的窘况（corejs3会polyfill实例方法），同时也保持了不污染全局空间，简直完美~

    是的 [赞]，preset env 的 entry 只过滤 targets 这个维度，usage 再加上用到的这个维度，而 transform runtime 
    插件是独立的，没有 targets 配置，corejs 有什么转什么

    @babel/preset-env + entry = 注入语法的下限是 target 浏览器，上限是当前版本 core-js
    @babel/preset-env + usage = 注入语法的下限是 target 浏览器，上限是源代码与当前版本 core-js 交集
    @babel/plugin-transform-runtime = 当前版本整个 core-js

    babel配置就是配置一下presets，使用@babel/preset-env，配置相应的target，根据target来引入相应的plugin） ，
    配置语法然后useBuiltIns用usage，corejs配置下版本，一般选择3，然后为了生成不污染全局空间和内置对象原型的代码
    在plugin里面在配置个@babel/plugin-transform-runtime

性能优化篇
    减少回流重绘
    什么是回流
    改变元素大小或者位置时会导致重新生成renderTree
    什么是重绘
    将renderTree绘制到屏幕上
    重绘不一定会回流，比如改变字体颜色

    js放在底部： 为什么js要放在底部，JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建，
    js使用defer或者async
    defer 异步加载，延迟执行，像下面就能保证执行顺序，执行时机是在等dom加载完
    (DOMContentLoaded | document.ready)后执行
    <script src="a.js" defer />
    <script src="b.js" defer />
    async 异步加载，加载完就执行，不能保证加载顺序，执行时机完全看有没有加载完，加载完就执
    行，可能在DOMContentLoaded触发之
    前或之后执行，但一定是在onload之前执行
    <script src="a.js" async />
    <script src="b.js" async />
    DOMContentLoaded = document.ready 在dom加载完成后，会执行 
    window.onload 所有资源加载完成后，会执行

    css 执行会阻塞渲染，阻止 JS 执行 css标签放在头部, 为什么，css不是会阻塞渲染吗，因为不放在头部的话，
    先加载html会让客户看到一个特别丑的页面
    
    静态资源使用cdn

    雪碧图，图片懒加载，图片压缩，svg

    WebP格式：使用WebP格式的图片，这种格式的图片体积更小，加载速度更快。    
    在图片加载期间，浏览器会停止渲染页面，等待图片加载完成后才会继续渲染

    JavaScript库来动态检测设备的类型和浏览器是否支持WebP格式，如果支持就加载WebP图片，否则加载备用的JPEG或PNG格式图片。常用的库包括Modernizr和Detector。
    或者用picture标签
    <picture class="pic">
        <source type="image/webp" srcset="a.webp"> 
        <img class="img" src="a.jpg">
    </picture>

    这个picture标签配合 media媒体查询简直屌炸天
    这个根据像素密度比来判断适用几倍图
    <picture>
      <source media="(min-device-pixel-ratio: 2)" srcset="image@2x.png">
      <source media="(min-device-pixel-ratio: 3)" srcset="image@3x.png">
      <img src="image.png" alt="Image">
    </picture>

    canvas.toDataURL(type, quality) 可以通过toDataURL()方法将canvas图像转换为base64编码的字符串，然后通过ajax或表单提交到后台进行保存。

    preload预加载 Prefetch
      Preload来告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级。
      对于那些本来请求优先级较低的关键请求，我们可以通过设置Preload来提升这些请求的优先级。

      preload 主要用于加速当前页面的关键资源加载，而 prefetch 主要用于优化未来页面加载的性能。
      
      Prefetch来告诉浏览器用户将来可能在其他页面（非本页面）可能  使用到的资源（脚本js文件，图片，样式css文件），
      在当前页面加载完成后，就去预先加载这些资源放在http缓存内，
      最常见的dns-prefetch。比如，当我们在浏览A页面，如果会通过A页面中的链接跳转到B页面，而B页面中我们有些资源希望尽早提前加载，
      那么我们就可以在A页面里添加这些资源Prefetch，那么当浏览器空闲时，就会去加载这些资源

    dns-prefetch是指在当前页面加载完成后，提前解析某些域名的DNS信息，以缩短后续请求的连接时间。这样就可以减少用户等待页面响应的时间，更快地展示页面内容。
    <link rel="dns-prefetch" href="//www.google.com">  使用DNS预解析来提前查询Google的DNS记录并缓存到本地
    <link rel="prefetch" href="https://www.google-analytics.com/analytics.js">  
    当浏览器遇到以下代码时，会预加载Google Analytics脚本：
    <link rel="preload" href="/path/to/myScript.js" as="script（css这里是style）">  
    在上述代码中，我们将一个JavaScript文件设置为preload资源，
    并且将as属性设置为"script"，这样浏览器就会将它作为JavaScript文件进行预加载。
    preload预加载js文件不会堵塞HTML解析。相反，它可以提高HTML解析的速度和性能。
    当浏览器遇到预加载的js文件时，它会立即发起资源请求并开始下载，而不会等到HTML解析完成。浏览器会在后台下载js文件，
    不会阻塞HTML解析和加载过程。当js文件下载完成后，浏览器会立即缓存并执行它。
    因此，preload预加载js文件可以提高页面性能和速度，并且不会影响HTML解析和加载过程。当HTML解析完成后，
    预加载的js文件也已经准备好了，可以立即执行，提高用户的体验。

    图片懒加载，IntersectionObserver，svg
    原理，判断图片是否出现在浏览器可视区域，如果是的话才开始把img里的src替换成data-src，即替换成真正的图片

    那么如何判断图片是否出现在可视区域

    图片距离浏览器可视区域的顶部 小于浏览器的的可视区域高度，即该图片已经被滑到过可视区域过，也可能被继续往上滑滑出可视区域
    按照图片懒加载的逻辑，这里就应该加载了这张图片

    可是虚拟列表是要清除滑出可视区域的数据的，就是只展示可视区域内的数据，这里要加多一个判断，也就是真正判断是否在可视区域内
    document.body.clientHeight 可以获取 可视区域高度， element.getBoundingClientRect().top 可以获取该元素距离可视区域
    顶部的距离，（指的就是）element.height 可以获取元素的高度，如果  top < clientHeight && top > 负的 element.height， 则该元素在
    可视区域内 

    IntersectionObserver 原理
    目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），
    另一次是完全离开视口（开始不可见）。

    实现优先级：
      若浏览器支持原生loading="lazy"则使用原生浏览器懒加载；
      若浏览器支持IntersectionObserver属性，则通过该属性实现；
      否则使用原生js执行懒加载（scroll 事件等）；

    虚拟列表原理
      原理比较复杂，
      那种固定宽度的挺好理解
      不固定宽度的有点难理解

    判断元素是否在可视区域（只有一部分在可视区域也算）
    const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) >= 0);

    http缓存
      强缓存（比如你第一次请求demo.js，服务器会返回文件，并且响应头里设置exprires或者cache-control并放到缓存里
            然后你第二请求demo.js, 浏览器会去缓存里面找demo.js看看之前的响应头事件有没有过期，没过期就直接使用，
            不会去请求服务器端了）

        请求某个文件时，会看看响应头里面的expires和cache-control里去浏览器缓存中找，首先看expires
        过期时间，如果还没过期，那就直接拿浏览器缓存，不过有问题，expires是一个缓存到期时间（和食品有没有过期一个意思，
        和本地时 相比，如果当前的本地时间比这个时间大，就是过期了，不过本地时间可以改，如果你改成比
        expires大就过期了，就过期了，或者是cache-control里的max-age去控制过期时长

      协商缓存
        第一次请求的时候服务器返回的时候响应头会有一个last-modifed，后面请求的时候请求头会自动带上(前端不用设置，会自己带上)
        if-modified-since（就是之前返回的last-modifed），
        这个字段去和服务器对比更新的时间，时间不一样就是更新了，就返回更新的资源（200和新数据），
        如果时间一样就返回304， 并且会显示一个 Not Modified 的字符串，告诉浏览器使用本地缓存;
        不过因为是绝对时间，最小单位是秒导致有误差，也就是说如果我短时间内资源发生了改变，Last-Modified 并不会发生变化
        周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为。

        第二种方案
        etag和if-none-match 和第一种一样，不过是hash值，就不会存在误差了
        Last-Modified 和 Etag 是可以同时设置的，服务器会优先校验 Etag，
        如果 Etag 相等就会继续比对 Last-Modified，最后才会决定是否返回 304

        max-age: 缓存过期时间，是一个相对时间
        public: 表示客户端和代理服务器都会缓存
        private: 表示只在客户端缓存
        no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商，告诉浏览器不要直接使用缓存的资源，需要先向服务器验证该资源是否有更新。  //这里存疑
        解疑，就是这样的，chrome的禁用缓存，就是通过设置 Cache-Control 为 no-Cache
        一般我们都会用强制刷新，也就是 command + shift + R。（其实也是让强缓存失效变成协商缓存），这个功能和禁用缓存是一样的，其实浏览器的强制刷新，就是协商缓存
        还有个清空缓存并硬性重新加载  就是你不是和服务器协商了吗，但是如果协商完后服务器让你用本地的缓存，但你不想用，就像让服务器更新，这时候你就可以用这个咯

        入口 html 文件是绝对不能强缓存的，不然就更新不了了，因为你强缓存了，要是有更新就再也到不了服务器，就再也更新不了了，所以html绝对不能强缓存
        但是html里面的资源都做了强缓存，那万一资源有更新怎么办呢？
        这种只要更新入口 html 就好了，业务资源文件名字里是有 hash 的，新的 html 引用不同 hash 的资源即可

        这种入口 html 文件设置 no-cache，其他资源文件设置 max-age 的缓存方式算是最佳实践了，你随便找一个网站看看都是这种方式。

        no-store: 表示文件不会被缓存

    gzip压缩

    webpack的性能优化
      打包速度优化
        减少查找过程
        缩小构建目标
          排除 Webpack 不需要解析的模块，即使用 loader 的时候，在尽量少的模块中去使用。
          我们可以借助 include 和 exclude 这两个参数，规定 loader 只在那些模块应用和在哪些模块不应用。
          我们修改公共配置文件 webpack.common.js
        缓存 Cache 相关
        合理使用 sourceMap
        externals
          其实就是可以让你的依赖包不用被打入bundle.js中，你可以在html里面引用对应的cdnjs，然后你在代码仍然可以使用import,require等各种规范
          key同package.json文件中的dependencies对象的key一样  
          value第三方依赖编译打包后生成的js文件，然后js文件执行后赋值给window的全局变量名称

        多进程打包 happypack
        const HappyPack = require('happypack');
        const os = require('os');
        // 开辟一个线程池，拿到系统CPU的核数，happypack 将编译工作利用所有线程
        const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });

        plugins: [
          new HappyPack({
            id: 'happybabel',
            loaders: ['babel-loader'],
            threadPool: happyThreadPool
          })
        ]

      DLL
        DLL 其实就是缓存，就是事先把常用但又构建时间长的代码提前打包好，取个名字叫dll，
        后面再打包的时候就跳过原来的未打包代码，直接用 dll。构建时间就会缩短，提高 webpack 打包速度。

        其实就是个缓存，对比一下dll和缓存的区别就知道了
        
        DLL	缓存
        1.把公共代码打包为 DLL 文件存到硬盘里	1.把常用文件存到硬盘/内存里
        2.第二次打包时动态链接 DLL 文件，不重新打包	2.第二次加载时直接读取缓存，不重新请求
        3.打包时间缩短	3.加载时间缩短

        配置太多步记不住，直接用AutoDllPlugin

      tree-shaking
      ES6模块静态化和静态分析是Tree shaking的基础。 静态分析就是不执行代码，在编译时从字面量上对代码进行分析从而正确判断到底加载了哪些模块 。 再分析程序流， 判断哪些变量未被使用引用，进而删除对应代码。
      所以在webpack中，由webpack通过静态分析标记出模块导出值中哪些没有被用过 ， 然后利用插件 uglify（代码压缩优化工具）进行清除，删掉这些没被用到的方法。

      生产环境会默认启动{usedExports: true}和压缩代码（treser-plugin 这个会删除无用代码，或者可以自己再配置），
      如下：
      optimization: {
        minimize: true,
        minimizer: [
            new CssMinimizerPlugin({
                minimizerOptions: {
                    preset: 'advanced', // 需额外安装
                },
            }),
            new TerserPlugin({
                terserOptions: {
                    toplevel: true, // 最高级别，删除无用代码
                    ie8: true,
                    safari10: true,
                    compress: {
                        drop_console: true,
                    },
                },
                extractComments: false,
            }),
        ],
      },
      看看需不需要配置sideEffects
      开发环境配置optimization: {usedExports: true, minimize: true,} 
      (usedExports的作用是标记无用代码，minimize去掉无用代码) 然后sideEffects看看怎么配置，

      code-split
      代码压缩  css压缩 CssMinimizerPlugin  js压缩 TerserPlugin

      webpack模块联邦

      服务端渲染
        这个很简单了，原理就是我们的正常应用都是最后一开始的html是空的，然后去请求到对应的js资源去填充页面，那肯定是白屏
        服务端渲染就是先让服务端给我们返回一个有填充过内容的html，就不会白屏了
        这个玩意怎么部署在服务器上的，晚上得用虚拟机玩一下才行

      骨架屏
        骨架屏应该是代码逻辑去实现的，和loading态是一个道理
      
      按需加载，逻辑后移，优先保证首屏内容渲染
      复杂计算使用web worker
      接口缓存

      react性能优化

typescript篇
    typescript是什么，ts是一个编程语言，可以说是js的一个超集，你可以在其中写任何js的代码，编译时会被编译成js
    更好的可维护性和可读性
    引入了静态类型声明，不需要太多的注释和文档，大部分的函数看类型定义就知道如何使用了
    在编译阶段就能发现大部分因为变量类型导致的错误

    类型声明，interface，泛型(generics)

    在 TypeScript 中，实用类型（Utility Types）是定义好的一些通用类型，可以用来快速定义其他类型，工具类，工具泛型
    pick，omit，exclude，extract，Partial required
      如果你要用的

      pick只要某个属性
      interface UserInfo {
        name:string;
        age:number;
      }

      // 这时候我们只需要 UserInfo 的 name和age 属性。
      type UserInfoT = Pick<UserInfo, "name">  用type
      interface UserInfoT extends Pick<UserInfo, 'name' | 'age'> {}  用interface

      omit排除某个属性
      interface UserInfo {
          name:string;
          age:number;
      }
      // 这时候我们不需要 UserInfo 的 name和age 属性。
      type UserInfoT = Omit<UserInfo, 'name' | 'age'>

      Exclude 和omit类似，针对的是联合类型
      type User = 'name' | 'age' | 'gender'
      type ExcludeType = Exclude<User, 'gender'>;
      // 相当于
      type ExcludeType = 'name' | 'age' 

      extract 和pick类似，针对的是联合类型
      type User = 'name' | 'age' | 'gender'
      type ExcludeType = Exclude<User, 'name' | 'work'>;
      // 相当于
      type ExcludeType = 'name'

      interface和type的区别
      相同之处
        两者都可以用来描述对象或函数,但语法不同:

        type Point = {
          x: number;
          y: number;
        };

        type SetPoint = (x: number, y: number) => void;

        interface Point {
          x: number;
          y: number;
        }

        interface SetPoint {
          (x: number, y: number): void;
        }

        二者都可以被继承

        interface 继承 interface
        interface Person{
            name:string
        }

        interface Student extends Person { stuNo: number }

        interface 继承 type
        type Person{
          name:string
        }

        interface Student extends Person { stuNo: number }


        type 继承 type
        type Person{
          name:string
        }

        type Student = Person & { stuNo: number }

        type 继承 interface
        interface Person{
          name:string
        }

        type Student = Person & { stuNo: number }

    不同之处
        type可以定义基本类型别名, 但是interface无法定义
        // 声明一个布尔类型
        type MyBoolean = boolean;

        type可以声明联合类型
        type name = 'zzp' | 'zzl';
        type MyUnion = string | number === let myVar: string | number;

        type可以申明 元组类型
        type MyTuple = [string, number, boolean];
        let myTuple: MyTuple = ['hello', 123, true];

        声明合并
        interface Person { name: string }
        interface Person { age: number }

        let user: Person = {
            name: "Tolu",
            age: 0,
        };

        type Person { name: string }; 

        // Error: 标识符“Person”重复。ts(2300)
        type Person { age: number }

        官方推荐用 interface，其他无法满足需求的情况下用 type
      
        d.ts声明文件  有时，我们不免会引入外部的 JS库，这时TS就对引入的JS文件里变量的具体类型不明确了，为了告诉TS变量的类型，因
        此就有了.d.ts (d即declare)，ts的声明文件。“d.ts”文件用于为 TypeScript 提供有关用 JavaScript 编写的 API 的类型信息
        这个时候你不能用TS重写主流的库，这个时候我们只需要编写仅包含类型注释的 d.ts 文件，然后从您的 TS 代码中，
        可以在仍然使用纯 JS 库的同时，获得静态类型检查的 TS 优势。

    2. Types or Interfaces？
    我们可以使用types或者Interfaces来定义类型吗，那么该如何选择他俩呢？建议如下：

    在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；
    在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。

    interface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type 可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：
    typescript复制代码interface Animal {
      name: string
    }

    // 可以继续在原属性基础上，添加新属性：color
    interface Animal {
      color: string
    }

    type Animal = {
      name: string
    }
    // type类型不支持属性扩展
    // Error: Duplicate identifier 'Animal'
    type Animal = {
      color: string
    }

    type对于联合类型是很有用的，比如：type Type = TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。

    情况不对就类型断言
    const getLength = (target: string | number): number => {
      if (target.length) { // error 类型"string | number"上不存在属性"length"
        return target.length; // error  类型"number"上不存在属性"length"
      } else {
        return target.toString().length;
      }
    };

    const getStrLength = (target: string | number): number => {
      if ((target as string).length) {      
        return (target as string).length; 
      } else {
        return target.toString().length;
      }
    };

    什么场景会使用泛型

    方法参数返回值一致
    function a<T>(value: T): T {
      return value;
    }

    function fetchData<T>(url: string): Promise<T> {
      return fetch(url).then((res) => res.json());
    }

    interface User {
      name: string;
    }

    fetchData<User>('https://api.example.com/users/1')
      .then((user) => console.log(user.name));

    接口返回promise类型的数据如何声明
    interface Result {
      name: string;
    }
    async function getName(): Promise<Result> {
      return Promise.resolve({
        name: "zzp",
      });
    }

    const getName = (): Promise<Result> =>
      Promise.resolve({
        name: "zzp",
      });

    typescript in React
    类组件
    interface IProps {
      name: string;
    }

    interface IState {
      count: number;
    }

    class App extends React.Component<IProps, IState> {}

    那如果定义时候我们不知道组件的props的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：
    这里才体现了泛型的作用，和上面的fetch泛型是一个意思
    class MyComponent<P> extends React.Component<P> {
      internalProp: P;
      constructor(props: P) {
        super(props);
        this.internalProp = props;
      }
      render() {
        return (
          <span>hello world</span>
        );
      }
    }

    // 使用组件
    type IProps = { name: string; age: number; };

    <MyComponent<IProps> name="React" age={18} />;          // Success
    <MyComponent<IProps> name="TypeScript" age="hello" />;  // Error

    函数组件
    const App = (props: IProps) => {}
    const App: React.FC<IProps> = (props) => {}

    jsxElement和React.element和React.ReactNode

    declare global {
      namespace JSX {
        interface Element extends React.ReactElement<any, any> { }
      }
    }

    JSX.Element是ReactElement的子类型，它没有增加属性，两者是等价的。也就是说两种类型的变量可以相互赋值。
    JSX.Element 可以通过执行 React.createElement 或是转译 JSX 获得：
    const jsx = <div>hello</div>
    const ele = React.createElement("div", null, "hello");


    ReactElement是一个接口，包含type,props,key三个属性值。该类型的变量值只能是两种： null 和 ReactElement实例。​
    通常情况下，函数组件返回ReactElement（JXS.Element）的值

    React.ReactNode
    可以看到，ReactNode是一个联合类型，它可以是string、number、ReactElement、null、boolean、ReactNodeArray。
    由此可知。ReactElement类型的变量可以直接赋值给ReactNode类型的变量，但反过来是不行的。
    类组件的 render 成员函数会返回 ReactNode 类型的值


    function Heading(): React.ReactNode | JSX.element | ReactElement {
      return <h1>My Website Heading</h1>;
    }

    render(): React.ReactNode | JSX.element | ReactElement{
      
    }


    const [count, setCount] = useState<number>(1)
    如果state是一个对象，想要初始化一个空对象，可以使用断言来处理：

    const [count, setCount] = useState<number | null>(null); 

    const [user, setUser] = React.useState<IUser>({} as IUser);
    实际上，这里将空对象{}断言为IUser接口就是欺骗了TypeScript的编译器，由于后面的代码可能会依赖这个对象，
    所以应该在使用前及时初始化 user 的值，否则就会报错。

    const nameInput = React.useRef<HTMLInputElement | null>(null);

    // 常见标签类型
    a: HTMLAnchorElement;
    body: HTMLBodyElement;
    br: HTMLBRElement;
    button: HTMLButtonElement;
    div: HTMLDivElement;
    h1: HTMLHeadingElement;
    h2: HTMLHeadingElement;
    h3: HTMLHeadingElement;
    html: HTMLHtmlElement;
    img: HTMLImageElement;
    input: HTMLInputElement;
    ul: HTMLUListElement;
    li: HTMLLIElement;
    link: HTMLLinkElement;
    p: HTMLParagraphElement;
    span: HTMLSpanElement;
    style: HTMLStyleElement;
    table: HTMLTableElement;
    tbody: HTMLTableSectionElement;
    video: HTMLVideoElement;
    audio: HTMLAudioElement;
    meta: HTMLMetaElement;
    form: HTMLFormElement;

    const memoizedCallback = useCallback(
      (a: number) => {
        add(a, b);
      },
      [b]
    );
    const calculatedValue = useMemo<number>(() => a ** 2, [a]);

    interface IColor {
      color: string;
    }

    const ColorContext = React.createContext<IColor>({ color: "green" });

    import React, { useReducer } from "react";

    type ActionType = {
      type: "increment" | "decrement";
    };

    type State = { count: number };

    const Counter: React.FC = () => {
      const reducer: React.Reducer<State, ActionType> = (state, action) => {
        switch (action.type) {
          case "increment":
            return { count: state.count + 1 };
          case "decrement":
            return { count: state.count - 1 };
          default:
            throw new Error();
        }
      };

      const initialState: State = {count: 0}
      const [state, dispatch] = useReducer(reducer, initialState);

      return (
        <>
          Count: {state.count}
          <button onClick={() => dispatch({ type: "increment" })}>+</button>
          <button onClick={() => dispatch({ type: "decrement" })}>-</button>
        </>
      );
    };

    export default Counter;

项目/业务篇
    可以大概讲一下业务吗

    ahooks原理
        有用过哪些ahooks，useRequest，
        useLatest，返回当前最新值的 Hook，可以避免闭包问题。
        useGetstate
        useUpdateEffect
        使用上与 useEffect 完全相同，只是它忽略了首次执行，只在依赖项更新时执行。
        还有一些拖拉拽的交互 useDrag，useDrop的拖拉api

        swr是什么， 如果设置了 options.cacheKey，useRequest 会将当前请求成功的数据缓存起来。
        一般来说，组件重新挂载，不是重新渲染
        （重新挂载和重新渲染都搞不明白了，卧槽了）
        比如 {visible && <Article />} 这种
        就会重新发起请求，那么这个组件的data就会被重置成空的，导致页面空白
        swr就是用来解决这种问题，下次组件重新挂载时，如果有缓存数据，我们会优先返回缓存数据，然后在背后发送新请求，也就是 SWR 的能力。

        这里有个东西讲一下哈，重新挂载和重新渲染是不一样的哈
        重新挂载就会重新走组件初始化的流程，重新渲染是重新走组件更新的流程
        classComponent 重新渲染时，只会跑对应的生命周期
        hooks 重新渲染，会把function里面的逻辑全都重新跑一次，所以直接声明变量重新渲染就会被重置，
        要用useRef（相当于classComponent中constructor里this.的作用）
        useRef跨域hooks全部的生命周期，还有不能直接在hooks的函数体中直接setState，那就会死循环，
        hooks中的useRequest也只会在初始化的时候调一次，重新渲染不会再调
        （当然，useRequest中的refreshDep可以控制是否再次调用），其实useRequest就和我们的自定义hooks一样
        
        useRequest很强大，const {loading, params(参数缓存，可以获取上一次请求用的条件), run, runAsync, cancel} = useRequest(url, {
          manual: true,  // 手动触发
          pollingInterval: 3000,  // 轮询，可以通过 cancel 来停止轮询，通过 run/runAsync 来启动轮询。
          refreshDeps: []  // 依赖项，当依赖项的值变化，便会重新发起请求，屌爆了
          debounceWait: 300,  // 防抖
          throttleWait: 300,  // 节流
          cacheKey: 'cacheKey-demo',  // SWR，在组件第二次加载时，会优先返回缓存的内容，
          后在背后重新发起请求。你可以通过点击按钮来体验效果。
          staleTime: 5000,    // 缓存数据保持新鲜时间。在该时间间隔内，认为数据是新鲜的，
          不会重新发请求，如果设置为 -1，则表示数据永远新鲜
          cacheTime: 0,  // 设置缓存数据回收时间。默认缓存数据 5 分钟后回收, 如果设置为 -1,
           则表示缓存数据永不过期, cacheTime要是超时了，你的缓存就没了，就无法实现那种第二次加载的时候，
           优先返回缓存的内容，缓存的内容被清掉了

          setCache: (data) => localStorage.setItem(cacheKey, JSON.stringify(data)),
          getCache: () => JSON.parse(localStorage.getItem(cacheKey) || '{}'),

          retryCount: 3, // 通过设置 options.retryCount，指定错误重试次数，则 useRequest 在失败后会进行重试。
        });

        const [userId, setUserId] = useState('1');
        const { data, run } = useRequest(() => getUserSchool(userId), {
          refreshDeps: [userId],
        });
        上面的示例代码，useRequest 会在初始化和 userId 变化时，触发函数执行。
        与下面代码实现功能完全一致
        const [userId, setUserId] = useState('1');
        const { data, refresh } = useRequest(() => getUserSchool(userId));
        useEffect(() => {
          refresh();
        }, [userId]);

        run(params[0])  // 能够获取缓存的参数

    qiankun
        微前端是什么，为什么使用微前端
        主框架不限制接入应用的技术栈，微应用具备完全自主权
        微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
        在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，
        而微前端是一种非常好的实施渐进式重构的手段和策略
        每个微应用之间状态隔离，运行时状态不共享

        微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，
        从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。
        这类问题在企业级 Web 应用中尤其常见。

        为什么是qiankun而不是iframe
        iframe的优点
          非常简单，无需任何改造
          完美隔离，JS、CSS 都是独立的运行环境
          不限制使用，页面上可以放多个 iframe 来组合业务

        iframe的缺点
          无法保持路由状态，刷新后路由状态就丢失（这点也不是完全不能解决，可以将路由作为参数拼接在链接后，刷新时去参数进行页面跳转）
          完全的隔离导致与子应用的交互变得极其困难
          iframe 中的弹窗无法突破其本身
          整个应用全量资源加载，加载太慢
    
    qiankun原理
        当路由切换的时候（劫持路由），去下载对应应用的代码，然后跑在容器里，qiankun 只是对 single-spa 的升级。
        比如 single-spa，它做的就是监听路由变化，路由切换的时候加载、卸载注册的应用的代码。
        只不过 single-spa 的入口是一个 js 文件，需要代码里手动指定要加载啥 js、css 等，不方便维护。
        qiankun 只是对 single-spa 的升级。

        它升级了啥东西呢？第一个就是入口，改为了 html 作为入口，解析 html，(我的理解是把子应用的html搞到容器里，容器就是你在主应用中为
        字应用提供的容器，然后这个import-html-entry会把html中的js和css replace怎么处理的我也不知道了
        <!--  script http://localhost:8000/main.js replaced by import-html-entry -->
        )从中分析 js、css，然后再加载，这个是
        import-html-entry 这个包实现的。所以你在 qiankun 的 package.json 里可以看到 single-spa 和 
        import-html-entry 这俩依赖。加载之后呢？自然是放容器里运行呀。这个容器 single-spa 也没做，qiankun 做了。
        它是把 js 代码包裹了一层 function，然后再把内部的 window 用 Proxy 包一层，
        这样内部的代码就被完全隔离了，这样就实现了一个 JS 沙箱。就是 function 包裹了一层，所以代码放在了单独作用域跑，
        又用 with 修改了 window，所以 window 也被隔离了。子应用上的window可以用window.proxy访问
    
    qiankun坑点
        样式隔离方案有问题
        shadow-dom 主应用的样式和使用了strictStyleIsolation的子应用样式互不影响但是会导致弹窗的样式挂掉，
        因为弹窗默认是挂在 body 上的，也就不在 shadow dom 里了，那 shadow dom 里给它加的样式自然就不生效了。

        scoped css 也就是对所有样式加了一层 data-qiankun=“应用名” 的选择器来隔离：弹窗样式还是会挂，没有global可以支持控制
        因为react 和 vue 项目本身都会用 scoped css 或者 css modules 的组件级别样式隔离方案，这俩方案都支持传递样式给子元素、设置全局样式等，
        只是实现和使用方式不同。
        global是什么，因为scoped css和css modules都会生成前缀，如果你想影响外面的组件，比如外面组件某个样式是 outside，你写样式控制他会被加前后缀导致
        控制不到外部组件，用global，被包裹在global里的样式就不会被加前后缀

        所以就是不用qiankun的样式隔离，自己做好父子应用间的样式隔离

    ssr
        SSR 普通的CSR就是单页面应用带来的问题，服务端请求到html时，是空白的html，这时候的页面就会出现白屏，
        如果是用SSR，会有一层中间层可以拿到已经渲染出来的html片段
        reactdomServer.renderToString
        
    umi
        为什么使用umi

    首页异步加载
        import().then
        
网络篇
    http状态码
        3xx 重定向  304协商缓存  没有更新  
        301 表示永久重定向，302 表示临时重定向。
        如果浏览器收到的是 301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。

        比如你这次是 nginx 配置了 重定向，从 www.a.com 跳转到了 www.b.com，那永久重定向就是浏览器会缓存，你后面在访问 www.a.com
        直接就跳到www.b.com，这时你就算已经改了nginx的配置去掉了重定向到www.b.com这个配置，但是浏览器缓存也会让你跳到 www.b.com，
        因为你没有再去读nginx，但是临时重定向就不会缓存，还是会去请求nginx，这时候你已经改了配置，就不会重定向到www.b.com

        但如果浏览器收到的是 302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。
        因此，301 适合地址永久转移的场景，比如域名变更；而 302 适合临时转移的场景，比如首页临时跳转到活动页


        4xx  400 客户端请求报文有语法错误  401 需要有通过 HTTP 认证  403 禁止访问   404 找不到 
        405 不允许使用该方法访问  access-control-allow-Methods
        500 服务端报错

    get和post的区别  
        get不安全（其实都不安全，不过get直接裸露在Url上就显得更不安全了），有大小限制是因为url浏览器有长度限制
        get一般会有缓存，因为它是去服务器获取东西
        post不会有，因为它是去服务器改东西，缓存也没有意义

        浏览器在发送 GET 请求时，不会附带请求体
        刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。
        GET 请求的地址可以被保存为浏览器书签，POST 不可以

    http有哪些请求 get post put delete head

    cdn是什么 内容分发网络

      cdn的组成
        中心节点
          中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理。

        边缘节点
          CDN边缘节点主要指异地分发节点，由负载均衡设备、高速缓存服务器两部分组成。
          中心节点就像仓配网络中负责货物调配的总仓，而边缘节点就是负责存储货物的各个城市的本地仓库。

设计模式篇
    发布订阅模式
        就是会有事件调度中心，然后会有订阅者会在什么订阅事件，发布者会发布事件，然后事件调度中心会去通知你，
        订阅者和发布者之间不会有任何联系

        class PubSub {
            constructor() {
                this.subscribers = {};
            }
            
            subscribe(topic, callback) {
                let callbacks = this.subscribers[topic];
                if (!callbacks) {
                    this.subscribers[topic] = [callback];
                } else {
                    callbacks.push(callback);
                }
            }
            
            publish(topic, ...args) {
                let callbacks = this.subscribers[topic] || [];
                callbacks.forEach(callback => callback(...args));
            }
        }
        
        // 创建事件调度中心，为订阅者和发布者提供调度服务
        let pubSub = new PubSub();
        // A订阅了SMS事件（A只关注SMS本身，而不关心谁发布这个事件）
        pubSub.subscribe('SMS', console.log);
        // B订阅了SMS事件
        pubSub.subscribe('SMS', console.log);
        // C发布了SMS事件（C只关注SMS本身，不关心谁订阅了这个事件）
        pubSub.publish('SMS', 'I published `SMS` event');

    观察者模式
        被观察者触发事件时，会去通知所有的观察者去更新，观察者想要订阅目标事件，只能将自己添加到被观察者中去进行管理，
        观察者和被观察者之间有很强的依赖关系
        class Subject {
            constructor() {
                this.observers = [];
            }
        
            add(observer) {
                this.observers.push(observer);
            }
        
            notify(...args) {
                this.observers.forEach(observer => observer.update(...args));
            }
        }
        
        class Observer {
            update(...args) {
                console.log(...args);
            }
        }
        
        // 创建观察者ob1
        let ob1 = new Observer();
        // 创建观察者ob2
        let ob2 = new Observer();
        // 创建目标sub
        let sub = new Subject();
        // 目标sub添加观察者ob1 （目标和观察者建立了依赖关系）
        sub.add(ob1);
        // 目标sub添加观察者ob2
        sub.add(ob2);
        // 目标sub触发SMS事件（目标主动通知观察者）
        sub.notify('I fired `SMS` event');
    
    单例模式
        某个类只能有一个实例
        class Singleton {

          constructor(name) {
            this.name = name
            this.instance = null
          }

          getName() {
            alert(this.name)
          }

          static getInstance(name) {
            if (!this.instance) {
              this.instance = new Singleton(name)
            }
            return this.instance
          }
        }

        const instanceA = Singleton.getInstance('seven1')
        const instanceB = Singleton.getInstance('seven2')

    工厂模式  
        将 new 操作单独封装，只对外提供相应接口；
        遇到new 时，就要考虑是否应该使用工厂模式；

        比如你现在有一个汽车有很多零件，轮胎，方向盘，那你需要用new很多个类，这时候你就可以用工厂模式，直接封装好，就不用在外面new了

        // 定义产品
        class Product {
            constructor(name) {
                this.name = name;
            }
            init() {
                console.log('初始化产品')
            }
        }

        // 定义工厂
        class Factory {
            create(name) {
                return new Product(name); // 核心思想
            }
        }

        let c = new Factory(); 
        let p = c.create('p1');
        p.init();


    装饰者模式  有点像高阶函数和es7的decorator，其实就是再不改变原来类的情况下， 对这个类进行增强
        class Circle {
            draw() {
                console.log('画一个圆形');
            }
        }

        class Decorator {
            constructor(circle) {
                this.circle = circle;
            }
            draw() {
                this.circle.draw();
                this.setRedBorder(circle);
            }
            setRedBorder(circle) {
                console.log('画一个红色边框');
            }
        }

        let circle = new Circle();
        let decorator = new Decorator(circle);
        decorator.draw(); //画一个圆形，画一个红色边框



数据结构篇
    线性结构
        数组
          是一个连续的结构，靠下标查找速度会比较快，时间复杂度O(1)
          插入和删除会比较慢，因为需要移动元素，时间复杂度O(N)

        栈
          后进先出
          栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。
          从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端（栈顶）插入（push）和删除（pop）数据。
          薯片罐，薯片先扔进去的在栈底

          // Stack类
          function Stack() {
            this.items = [];

            // 添加新元素到栈顶
            this.push = function(element) {
              this.items.push(element);
            };
            // 移除栈顶元素，同时返回被移除的元素
            this.pop = function() {
              return this.items.pop();
            };
            // 查看栈顶元素
            this.peek = function() {
              return this.items[this.items.length - 1];
            };
            // 判断是否为空栈
            this.isEmpty = function() {
              return this.items.length === 0;
            };
            // 清空栈
            this.clear = function() {
              this.items = [];
            };
            // 查询栈的长度
            this.size = function() {
              return this.items.length;
            };
            // 打印栈里的元素
            this.print = function() {
              console.log(this.items.toString());
            };
          }

          // 创建Stack实例
          var stack = new Stack();
          console.log(stack.isEmpty()); // true
          stack.push(5); // undefined
          stack.push(8); // undefined
          console.log(stack.peek()); // 8
          stack.push(11); // undefined
          console.log(stack.size()); // 3
          console.log(stack.isEmpty()); // false
          stack.push(15); // undefined
          stack.pop(); // 15
          console.log(stack.size()); // 3
          stack.print(); // 5,8,11
          stack.clear(); // undefined
          console.log(stack.size()); // 0

        队列
          先进先出
          队列在尾部添加新元素，并从顶部移除元素。
          最新添加的元素必须排在队列的末尾。
          队列只有 入队 enqueue(向队列尾部添加新项) 出队 dequeue(移除队列的第一项，并返回被移除的元素)。

          // Queue类
          function Queue() {
            this.items = [];

            // 向队列尾部添加元素
            this.enqueue = function(element) {
              this.items.push(element);
            };

            // 移除队列的第一个元素，并返回被移除的元素
            this.dequeue = function() {
              return this.items.shift();
            };

            // 返回队列的第一个元素
            this.front = function() {
              return this.items[0];
            };

            // 判断是否为空队列
            this.isEmpty = function() {
              return this.items.length === 0;
            };

            // 获取队列的长度
            this.size = function() {
              return this.items.length;
            };

            // 清空队列
            this.clear = function() {
              this.items = [];
            };

            // 打印队列里的元素
            this.print = function() {
              console.log(this.items.toString());
            };
          }

          // 创建Queue实例
          var queue = new Queue();
          console.log(queue.isEmpty()); // true
          queue.enqueue('John'); // undefined
          queue.enqueue('Jack'); // undefined
          queue.enqueue('Camila'); // undefined
          queue.print(); // "John,Jack,Camila"
          console.log(queue.size()); // 3
          console.log(queue.isEmpty()); // false
          queue.dequeue(); // "John"
          queue.dequeue(); // "Jack"
          queue.print(); // "Camila"
          queue.clear(); // undefined
          console.log(queue.size()); // 0

        链表
          是一个不连续的结构，只能遍历查找速度会比较慢，时间复杂度O(N)
          插入和删除会比较快，不需要移动元素，只需要考虑相邻结点的指针改变，时间复杂度O(1)

          class LinkList {
            constructor() {

            }
            #head = null;
            #length = 0;
            #Node = class{
                constructor(element) {
                    this.element = element;
                    this.next = null;
                }
            }

            append = (element) => {
                const node = new this.#Node(element);
                let currentNode = this.#head;
                if(this.#head){
                    while(currentNode.next){
                        currentNode = currentNode.next;
                    }
                    currentNode.next = node;
                } else{
                    this.#head = node;
                }
                this.#length++;
            }

            insert = (position, element) => {
                if(position < 0 || position >= this.#length){
                    return false;
                }
                const node = new this.#Node(element);
                let previousNode;
                let currentNode = this.#head;
                
                if(position === 0){
                    node.next = this.#head;
                    this.#head = node;
                }
                for(let i = 0; i < position; i++){
                    previousNode = currentNode;
                    currentNode = currentNode.next;
                }

                previousNode.next = node;
                node.next = currentNode;

                this.#length ++;
            }

            // 从链表的特定位置移除一项
            removeAt = (position) => {
                if ((position < 0 && position >= this.#length) || this.#length === 0) {
                        // 越界
                        return false;
                } else {
                        var currentNode = this.#head;
                        var previousNode;

                        if (position === 0) {
                                this.#head = currentNode.next;
                        } else {
                                // 循环找到位置
                                for(let i = 0; i < position; i++){
                                    previousNode = currentNode;
                                    currentNode = currentNode.next;
                                }
                                // 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点
                                previousNode.next = currentNode.next;
                                            }

                        this.#length--;
              }
            };

            // 从链表中移除指定项
            remove = (element) => {
                var index = this.indexOf(element);
                return this.removeAt(index);
            };

            list = () => {
                return this.#head;
            };

            // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值
            toString = () => {
                var currentNode = this.#head;
                var string = '';

                while (currentNode) {
                        string += ',' + currentNode.element;
                        currentNode = currentNode.next;
                }

                return string.slice(1);
            };

            // 打印链表数据
            print = () => {
                console.log(this.toString());
            };


            // 返回元素在链表的索引，如果链表中没有该元素则返回 -1
            indexOf = (element) => {
                var currentNode = this.#head;
                var index = 0;

                while (currentNode) {
                        if (currentNode.element === element) {
                                return index;
                        }

                        index++;
                        currentNode = currentNode.next;
                }

                return -1;
            };
          }

          const linkList = new LinkList();

          linkList.append('Tom');
          linkList.append('Peter');
          linkList.append('Paul');

          linkList.insert(1, 'Jack');
          linkList.print(); // "Tom,Jack,Peter,Paul"

    非线性结构
        堆
        二叉树
        图

算法篇
    基本排序算法
        冒泡排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898b4742e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function bubleSort(arr) {
            var len = arr.length;
            for (let outer = len ; outer >= 2; outer--) {
                for(let inner = 0; inner <=outer - 1; inner++) {
                    if(arr[inner] > arr[inner + 1]) {
                        [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]
                    }
                }
            }
            return arr;
        }
        选择排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc899fabfa0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function selectSort(arr) {
            var len = arr.length;
            for(let i = 0 ;i < len - 1; i++) {
                for(let j = i ; j<len; j++) {
                    if(arr[j] < arr[i]) {
                        [arr[i],arr[j]] = [arr[j],arr[i]];
                    }
                }
            }
            return arr
        }
        插入排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898df137f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
        function insertSort(arr) {
            for(let i = 1; i < arr.length; i++) {  //外循环从1开始，默认arr[0]是有序段
                for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中
                    if(arr[j] < arr[j-1]) {
                        [arr[j],arr[j-1]] = [arr[j-1],arr[j]];
                    } else {
                        break;
                    }
                }
            }
            return arr;
        }
    高级排序算法
        快速排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898c22284~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)   
        function quickSort(arr) {
            if(arr.length <= 1) {
                return arr;  // 递归出口
            }
            var left = [],
                right = [],
                current = arr.splice(0,1); //注意splice后，数组长度少了一个
            for(let i = 0; i < arr.length; i++) {
                if(arr[i] < current) { 
                    left.push(arr[i])  //放在左边
                } else {  
                    right.push(arr[i]) //放在右边
                }
            }
            return quickSort(left).concat(current,quickSort(right)); // 递归 
        }

        希尔排序
        ![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/14/16538fc898c88c5f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
          function shellSort(arr,gap) {
              console.log(arr)//为了方便观察过程，使用时去除
              for(let i = 0; i<gap.length; i++) {  //最外层循环，一次取不同的步长，步长需要预先给出
                  let n = gap[i]; //步长为n
                  for(let j = i + n; j < arr.length; j++) { //接下类和插入排序一样，j循环依次取后面的数
                      for(let k = j; k > 0; k-=n) { //k循环进行比较，和直接插入的唯一区别是1变为了n
                          if(arr[k] < arr[k-n]) {
                              [arr[k],arr[k-n]] = [arr[k-n],arr[k]];
                              console.log(`当前序列为[${arr}] \n 交换了${arr[k]}和${arr[k-n]}`)//为了观察过程
                          } else {
                              continue;
                          }
                      }
                  }
              }
              return arr;
          }

    排序算法
                平均时间  复杂度最坏时间 复杂度空间 复杂度是否稳定
    冒泡排序      O(n²)     O(n²)         O(1)       是
    选择排序      O(n²)     O(n²)         O(1)      不是
    直接插入排序   O(n²)     O(n²)         O(1)      是
    快速排序     O(nlogn)   O(n²)       O(logn)     不是
    希尔排序     O(nlogn)   O(n^s)        O(1)      不是

    递归
    二分查找

      1到100猜一个数字
      const bindaryFind = (target, arr, low = 0, high = arr.length - 1) => {
        const midIndex = Math.floor(arr.length / 2);
        const cur = arr[midIndex];
        if (target === cur) {
          return '找到了';
        } else if (target < cur) {
          return bindaryFind(target, arr, low, midIndex - 1);
        } else if(target > cur){
          return bindaryFind(target, arr, midIndex + 1, high);
        }
      };

      const binaryFind = (arr, target) => {
        var low = 0,
            high = arr.length - 1,
            mid;
        while (low <= high) {
            mid = Math.floor((low + high) / 2);
            if (target === arr[mid]) {
                return `找到了${target},在第${mid + 1}个`
            }
            if (target > arr[mid]) {
                low = mid + 1;
            } else if (target < arr[mid]) {
                high = mid - 1;
            }
        }
        return -1
      }

    深度优先，广度优先
    const bt = {
      val: 'A',
      left: {
        val: 'B',
        left: { val: 'D', left: null, right: null },
        right: { val: 'E', left: null, right: null },
      },
      right: {
        val: 'C',
        left: {
          val: 'F',
          left: { val: 'H', left: null, right: null },
          right: { val: 'I', left: null, right: null },
        },
        right: { val: 'G', left: null, right: null },
      },
    }

    function dfs(root) {
      if (!root) return
      console.log(root.val)
      root.left && dfs(root.left)
      root.right && dfs(root.right) 
    }
    dfs(bt)
    /** 结果
    A B D E C F H I G
    */

    function bfs(root) {
      if (!root) return
      const queue = [root]
      while (queue.length) {
        const node = queue.shift()
        console.log(node.val)
        node.left && queue.push(node.left)
        node.right && queue.push(node.right)
      }
    }
    bfs(bt)
    /** 结果
    A B C D E F G H I
    */

    动态规划 dp  
    搜索算法 dfs（深度优先搜索） 暴力搜索  ->  记忆化搜索  ->  递推dp

    // 暴力搜索 递归
    function calc(arr, currentIndex, currentLength) {
      // 递归结束的情况
      if (currentIndex === arr.length) {
        return currentLength;
      }
      // 当前元素可以加入子序列中
      if (arr[currentIndex] > arr[currentIndex - 1]) {
        const length1 = calc(arr, currentIndex + 1, currentLength + 1);
        // 当前元素不能加入子序列中
        const length2 = calc(arr, currentIndex + 1, currentLength);
        return Math.max(length1, length2);
      } else { // 当前元素不能加入子序列中
        return calc(arr, currentIndex + 1, currentLength);
      }
    }

    const arr = [1, 5, 2, 4, 3];
    const result = calc(arr, 1, 1);
    console.log(result); // 3

    // 记忆化搜索 递归，但是可以把记忆的过程存到内存，下次遇到用过的直接复用，空间换时间
    function calc(arr, currentIndex, currentLength, memo) {
      memo[currentIndex][currentLength] = memo[currentIndex][currentLength] || 1;
      if (memo[currentIndex][currentLength] !== 1) {
        return memo[currentIndex][currentLength];
      }
      if (currentIndex === arr.length) {
        return currentLength;
      }
      if (arr[currentIndex] > arr[currentIndex - 1]) {
        const length1 = calc(arr, currentIndex + 1, currentLength + 1, memo);
        const length2 = calc(arr, currentIndex + 1, currentLength, memo);
        memo[currentIndex][currentLength] = Math.max(length1, length2);
        return memo[currentIndex][currentLength];
      } else {
        const length = calc(arr, currentIndex + 1, currentLength, memo);
        memo[currentIndex][currentLength] = length;
        return length;
      }
    }

    const arr = [1, 5, 2, 4, 3];
    const memo = Array(arr.length + 1).fill().map(() => Array(arr.length + 1));
    const result = calc(arr, 1, 1, memo);
    console.log(result); // 3

    // 动态规划，直接把递归变成一个循环了，逆天，其实就是找到规律（数学归纳法），总结规律，从下往上推，上面递归都是从上往下
    function cacl(arr) {
      const dp = Array(arr.length).fill(1);
      let maxLength = 1;
      for (let i = 1; i < arr.length; i++) {
        for (let j = 0; j < i; j++) {
          if (arr[j] < arr[i]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
          }
        }
        maxLength = Math.max(maxLength, dp[i]);
      }
      return maxLength;
    }

    const arr = [1, 5, 2, 4, 3];
    const result = cacl(arr);
    console.log(result); // 3

其他篇
    输入一个url
      dns解析，找到对应ip
      TCP三次握手四次挥手建立连接
      从服务器请求资源 https
      请求到html
      dom tree，cssom tree  
      render Tree
      js 加载 加载完之后渲染页面

      浏览器根据url地址查找本地缓存，根据缓存规则看是否命中http缓存，若命中缓存则直接使用缓存，不再发出请求（http缓存）
      如果没命中缓存，就要向服务器发起请求
      浏览器向本地DNS服务器请求对该域名的解析。
      本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。（dns-prefetch）
      本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以迭代方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。
      浏览器向服务器发出建立TCP连接的申请，完成三次握手后，连接通道建立
      若使用了HTTPS协议，则还会进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2
      浏览器决定要附带哪些cookie到请求头中
      浏览器自动设置好请求头、协议版本、cookie，发出GET请求
      服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。
      浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接。 （经过标准的TCP挥手流程，断开TCP连接。）
      浏览器根据响应状态码决定如何处理这一次响应
      浏览器根据响应头中的Content-Type字段识别响应类型，如果是text/html，则对响应体的内容进行HTML解析，否则做其他处理
      浏览器根据响应头的其他内容完成缓存、cookie的设置
      浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源
      解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），
      随后对渲染树中的每个节点计算位置和大小（reflow），  回流
      最后把每个节点利用GPU绘制到屏幕（repaint）  重绘
      在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件

    http和https的区别
      加密： HTTPS 是 HTTP 协议的更加安全的版本，通过使用SSL/TLS进行加密传输的数据；
      连接方式： HTTP（三次握手）和 HTTPS （三次握手+数字证书）连接方式不一样；
      端口： HTTP 默认的端口是 80和 HTTPS 默认端口是 443

    七层网络模型

    请求一个网站的请求过程 
          
      cdn的组成
        中心节点
          中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理。

        边缘节点
          CDN边缘节点主要指异地分发节点，由负载均衡设备、高速缓存服务器两部分组成。
          中心节点就像仓配网络中负责货物调配的总仓，而边缘节点就是负责存储货物的各个城市的本地仓库。

    引入了cdn的过程
      当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，
      则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。
      CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。
      用户向CDN的全局负载均衡设备发起URL访问请求。
      CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。
      基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的IP地址，
      最终将得到的IP地址返回给全局负载均衡设备：根据用户IP地址，判断哪一个边缘节点距用户最近；根据用户所请求的URL中携带的内容名称，
      判断哪一个边缘节点上有用户所需内容；查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。
      全局负载均衡设备把服务器的IP地址返回给用户。
      用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，
      而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

    async await 原理
    其实就是  generator

    async函数对 Generator 函数的改进，体现在以下四点：

    1.  `内置执行器`。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。
    1.  `更好的语义`。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
    1.  `更广的适用性`。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
    1.  `返回值是 Promise`。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。

    先搞一个会自动执行的generator
    ```js
    function *gen(){
      const res1 = yield new Promise((resolve, reject) => setTimeout(() => {
        resolve(1)
      }, 1000));
      console.log(res1);
      const res2 = yield new Promise((resolve, reject) => setTimeout(() => {
        resolve(2)
      }, 1000));
      console.log(res2);
    }

    function run(gen) {
      const g = gen();

      return function () {
        return new Promise((resolve, reject) => {
            function next(data) {
                var result = g.next(data);
                if (result.done) {
                  resolve(result.value);
                  return result.value;
                }
                result.value.then(function (data) {
                  next(data);
                });
              }
          
              next();
        })
      };
    }

    const asyncFunc = run(gen);

    asyncFunc();
    ```
    这样子就已经很像是async await

    async await后面可以不跟promise吗，可以的呢，会转成已经resolve的对象
    async function test(){
      return await console.log(2);
    }

    test();
    Promise {<resolved>: undefined}

    async function test(){
      return await 1;
    }

    test();
    Promise {<resolved>: 1}

    async function test(){
      return await Promise.resolve(2);
    }

    test();
    Promise {<resolved>: 2}

    工作中遇到的问题
        load chunk failed  没有增量更新，删除了老的文件，那怎么解决呢
        监听报错事件，如果error报错信息里有loading chunk的字眼，就刷新页面
          window.addEventListener(
          'error',
          function (event) {
            if (
              event.message &&
              String(event.message).includes('Loading chunk') &&
              String(event.message).includes('failed')
            ) {
              window.location.reload();
            }
          },
          true,
        );
        css样式命名规范(css隔离问题)   BEM   模块+元素+修饰
        巨石应用  就是使用微前端解决  哈哈妈的傻逼
        页面卡顿排查，内存泄漏排查问题（memory，performance）   
          performance分析有任务因为js中的两个计算量都很大，所以有两个long task的提示，我们的目标就是去优化掉long task
          memory中可以看有没有占用内存大小特别高的变量
        nodejs断点  
          使用node --inspect-brk 和 chrome devTool 结合使用
          或者 vscode
          vscode需配置 .vscode/launch.json

    文件上传如何做断点续传
        客户端将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时附带其序号。
        服务器接收到每片数据时，将其保存成一个临时文件，并记录每个文件的 hash 和序号。
        若上传中止，将来再次上传时，可以向服务器索要已上传的分片序号，客户端仅需上传剩余分片即可。
        当全部分片上传完成后，服务器按照分片的顺序组装成完整的文件，并删除分片文件。

    webSocket
        websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，
        然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。
        首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，
        请求行中的 path 需要使用ws:开头的地址，请求头中要分别加入upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version标记
        然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含Switching Protocols，
        同时响应头中包含upgrade、connection、Sec-WebSocket-Accept标记
        当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。

        webSocket 与传统的 http 有什么优势
        当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成:
        第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据
        第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。
        响应后，客户端立即又发起一次请求，重复整个流程。
        无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，
        无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。
        websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，
        服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。

    dispatchEvent
        学到的骚操作，可以用来通信
        // 创建一个带有数据的自定义事件
        const myEvent = new CustomEvent('my-event', { detail: { data: 'Hello World' } });

        // 触发自定义事件并传递数据
        window.dispatchEvent(myEvent);

        // 监听自定义事件
        window.addEventListener('my-event', function(event) {
          console.log('Received data:', event.detail.data);
        });

        不用传数据的话
        window.dispatchEvent(new Event('vListenLogin'));
        window.addEventListener('vListenLogin', function(){});

        事件委托  子节点一个个加事件，不如直接怼到父节点上面
        前端模板引擎
        
    eslint
        {
            // 指定环境 , 可用的环境见下方详解, 这些环境并不互斥，所以你可以一次定义多个环境。
            "env": {
                "browser": true,
                "node": true,
                "es6": true // 支持新的 ES6 全局变量和类型了 
            },
            // ESLint 的一些核心规则依赖于对你的代码在运行时可用的全局变量的了解。
            // 由于这些变量在不同的环境中会有很大的不同，而且在运行时也会被修改，
            // 因此 ESLint 不会对你的执行环境中存在的全局变量进行假设。
            // 如果你想使用需要知道有哪些全局变量的规则，你可以在你的配置文件中定义全局变量，
            // 或者在你的源代码中使用配置注释。
            "globals": {
                "var1": "writable", // 允许变量被覆盖
                "var2": "readonly", // 禁止覆盖 仅可读
                // 可以将它们的值设置为字符串 "off" 来禁用全局变量。例如，在一个环境中，可以使用大多数 ES2015 全局变量，但不可以使用 Promise，那么你就可以使用这个配置：
                "Promise": "off"
            },
            // 覆盖规则, 
            // 比如某些文件内的写法你认为是对的,但还会提示错误,你就可以在这里配置覆盖规则,不需要单行或者文件使用eslint注释
            // 比如为特定类型的文件指定处理器：设置某些文件，禁用部分检查
            // 同一个配置文件中的多个覆盖会按顺序应用,也就是最后一个覆盖块总是具有最高的优先权
            "overrides": [
                {
                  "files": ["bin/*.js", "lib/*.js"],
                  "excludedFiles": "*.test.js",
                  "rules": {
                    "quotes": ["error", "single"]
                  }
                },
                // 为md文件指定使用a-plugin插件处理,注意要安装特定的插件
                { 
                    "files": ["*.md"], 
                    "processor": "a-plugin/markdown" 
                }
            ],
            // 添加自定义解析器  通常情况下，这意味着你应该使用 npm 单独安装解析器包。
            // 一般常与parserOptions一起使用,默认解析器为 espree。
            parser: 'vue-eslint-parser',
            // 指定解析器选项
            parserOptions: {
                // 这个自定义解析器中，使用@typescript-eslint/parser作为<script>标记。
                parser: '@typescript-eslint/parser',
                //  设置为 "script"（默认值）或 "module"（如果代码是 ECMAScript 模块）。
                sourceType : 'script',
                // 设置为 3、5（默认）、6、7、8、9、10、11、12 或 13，以指定你要使用的 ECMAScript 语法的版本
                // 你也可以设置为 2015（6）、2016（7）、2017（8）、2018（9）、2019（10）、2020（11）、2021（12）或 2022（13）来使用基于年份的命名。你也可以设置 "latest" 来使用受支持的最新版本。
                //  支持es6语法（但不支持新的 ES6 全局变量或类型，如Set）
                ecmaVersion: 'latest',
                // 设置为 "script"（默认值）或 "module"（如果代码是 ECMAScript 模块）。
                sourceType: 'module',
                jsxPragma: 'React',
                // 表示你想使用哪些额外的语言特性的对象, value 均为 true/false
                ecmaFeatures: {
                  // 启用 JSX
                  jsx: true,
                  globalReturn: true, // 允许在全局作用域下使用 return 语句
                },
            },
            // 规则配置
            rules: {
              // ***
            },
            // 配置插件 
            plugins: ['a-plugin'],
            // 拓展 集成
            extends: [],
        }


        eslint:recommended ESLint内置的推荐规则在么有讲到 所有打钩的就是内置规则
        eslint:all：ESLint 内置的所有规则；
        eslint-config-standard：standard 的 JS 规范；
        eslint-config-prettier：关闭和 ESLint 中以及其他扩展中有冲突的规则；

        平时用的是哪个规范 recommended standard prettier
        extends: [
          'eslint:recommended', // 是 ESLint 官方的扩展,内置推荐规则
          'eslint-config-standard',
          'plugin:react/recommended',
          "plugin:react-hooks/recommended",
          "plugin:@typescript-eslint/eslint-recommended",
          "plugin:@typescript-eslint/recommended",

          'eslint:recommended',
          'eslint-config-ali',
          'prettier/react',
          'prettier/@typescript-eslint',
          'plugin:prettier/recommended',
          'plugin:react/recommended',
          'plugin:@typescript-eslint/recommended',
          'plugin:import/typescript',
          'plugin:react-hooks/recommended',
        ],
        plugins: [
          'react',
          'react-hooks',
          '@typescript-eslint'
        ],
        parser: '@typescript-eslint/parser',

        如果 extends 配置的是一个数组，那么最终会将所有规则项进行合并，出现冲突的时候，后面的会覆盖前面的；
        通过 rules 单独配置的规则优先级比 extends 高；

        规则强度是 airbnb > standard > recommended

        ESlint的插件是干嘛的：
        首先我们需要知道的Eslint本质只是一个代码检测工具，默认情况下也只能检测js文件，如果我们需要在工程化中加入去兼容其他语法例如[.vue]、[.jsx]等其他格式的文件时就没有办法实现，
        所以我们需要加入一些插件来实现对非js格式的文件进行检测。
        
    国际化
        i18next react-i18next  一条龙搞定
        基本用法
        语言翻译器

        插值表达式  插值表达式的语法是使用两个大花括号包裹属性名。 
        {t('currentTime', { time: dayjs().format('MM/DD/YYYY') })}
        { currentTime: 'Current time is {{time}}' }

        格式化
        { currentTime: '当前时间是 {{time, YYYY-MM-DD}}' }
        i18n.services.formatter.add('DD/MM/YY', (value, lng, options) => {
          return dayjs(value).format('DD/MM/YY')
        });

        i18next-http-backend  能将翻译文件拆分，为了方便维护，我们可以选择使用 json 文件来作为保存翻译文本的资源文件。

    nginx  token被窃取
    token都被盗取了，那只能说对面肯定已经登录了你的账号（或者正在用你的电脑哈哈），那还能怎么样，改账号密码呗
    除非对面能从别的电脑劫持到你此时发出的请求
    
    截取token的方式
    网络钓鱼：黑客可能会发送伪装成合法网站的钓鱼链接，诱骗您在该网站上输入账户名和密码，从而获取您的登录凭证，包括token。
    XSS攻击：黑客可能会通过跨站脚本攻击（XSS）在您的浏览器中注入恶意代码，通过该代码获取您的token。
    CSRF攻击：黑客可能会通过跨站请求伪造（CSRF）攻击，让您在不知情的情况下进行某个操作，从而获取您的token。
    
    token被盗取后可以怎么办
    cors设置域名限制
    设置token有效期
    token加密
    出了token再加一层验证

    移动端 vconsole  抓包 fiddle

    页面抖动，占位解决一切

    http默认端口是80 https默认端口是443  nginx就是跑在80端口上的

    三个dependence的区别
    devDependencies：devDependencies是指该npm包在开发时所使用的依赖库，也就是说，它们是在开发过程中使用的工具库或测试库，
    不会影响到生产环境。
    通常情况下，开发者在提交代码时不会将devDependencies中的依赖包提交到代码仓库，而是在CI/CD工具中进行安装。

    peerDependencies 同伴依赖（其实就是宿主环境应该安装的依赖，比如你装了zzp这个package
    ，那你就必须在装16.x版本的react，zzp只支持在react16.x下面使用），比如我在package zzp中声明了
     { peerDependencies: { react: '16.x' } } 在npm 1 和 npm 2 中，当你 npm i zzp时，会强制帮你安装16.x的react，
     不过在高版本的npm中则不会帮你安装16.x的react，会产生警告！ 
     手动在package.json文件中添加依赖项可以解决。 那如果我安装了package zzp1，zzp1要求的是 15， zzp2要求的是16，
     那咋整？ 咋整，看看zzp2前面的版本有没有用15的（笑cry）

    提供了一个数组结构的 data，要求实现一个 query 方法，返回一个新的数组，query 方法内部有 过滤、排序、分组 等操作，
    并且支持链式调用，调用最终的 execute 方法返回结果：

    const result = query(list)
      .where(item => item.age > 18)
      .sortBy('id')
      .groupBy('name')
      .execute();

    console.log(result);

    function query(data) {
      return {
        where(callback) {
          data = data.filter(callback);
          return this;
        },
        sortBy(key) {
          data = data.sort((a, b) => a[key] - b[key]);
          return this;
        },
        groupBy(key) {
          data = data.reduce((result, item) => {
            const value = item[key];
            if (!result[value]) {
              result[value] = [];
            }
            result[value].push(item);
            return result;
          }, {});
          return this;
        },
        execute() {
          return data;
        },
      };
    }

    const list = [
      { id: 2, name: 'Alice', age: 20 },
      { id: 1, name: 'Bob', age: 25 },
      { id: 3, name: 'Charlie', age: 18 },
    ];

    const result = query(list)
      .where(item => item.age > 18)
      .sortBy('id')
      .groupBy('name')
      .execute();

    console.log(result);
    // { Alice: [{ id: 2, name: 'Alice', age: 20 }], Bob: [{ id: 1, name: 'Bob', age: 25 }] }


    具体实现这里就不贴了，过滤用原生的数组 filter 方法，排序用原生的数组 sort 方法，分组需要手写一下，类似 lodash/groupBy 方法。
    过滤和排序实现都比较顺利，在实现分组方法的时候不是很顺利，有点忘记思路了，不过最后还是写出来了，关于链式调用，核心是只需要在每一步
    的操作最后返回 this 即可

    七层模型

    object.defineProperty和proxy的区别
      在使用 Object.defineProperty 定义代理时，我们需要针对每个属性都进行 defineProperty 定义，这样代码量比较大，可读性也不是很好。
      而在使用 Proxy 定义代理时，我们只需要定义一个 handler 对象，然后使用 new Proxy(obj, handler) 将原始对象和 handler 对象相结合就可以了。这样代码量大大减少，可读性也更好。

    const obj = {
      name: '张三',
      age: 18,
      gender: '男'
    };

    // 使用 Object.defineProperty 定义代理
    Object.keys(obj).forEach(key => {
      Object.defineProperty(obj, key, {
        get() {
          console.log(`读取 "${key}" 属性`);
          return obj[key];
        },
        set(value) {
          console.log(`修改 "${key}" 属性，新值为 "${value}"`);
          obj[key] = value;
        }
      });
    });

    // 使用 Proxy 定义代理
    const handler = {
      get(target, key, receiver) {
        console.log(`读取 "${key}" 属性`);
        return Reflect.get(target, key, receiver);
      },
      set(target, key, value, receiver) {
        console.log(`修改 "${key}" 属性，新值为 "${value}"`);
        return Reflect.set(target, key, value, receiver);
      }
    };

    const proxyObj = new Proxy(obj, handler);

    // 读取属性
    console.log(proxyObj.name);
    console.log(proxyObj.age);

    // 修改属性
    proxyObj.name = '李四';
    proxyObj.age = 20;

    Proxy兼容差， Proxy能监听到数组的变化

    小程序
      其实没啥，就是一个脚手架，然后跑对应的命令
      比如 npm run build:weapp 就可以编译出对应的端代码，这个是编译出小程序的代码，然后用微信开发者工具打开dist目录，小程序就会跑起来了
      npm run dev:weapp 是热更新模式，在小程序那边会热更新看到效果，贼叼

      小程序生命周期
      全局生命周期

      -   onLaunch -- 小程序初始化完成，全局只触发一次
      -   onShow -- 小程序启动时，或者从后台进入前台
      -   onHide -- 小程序从前台进入后台时执行
      -   onError -- 小程序运行脚本出错或者api调用失败时执行，会带上错误信息
      -   onPageNotFound -- 小程序页面不存在时执行

      页面生命周期

      -   onLoad -- 页面加载时执行，只执行一次，发送请求
      -   onReady -- 页面初次渲染时执行，只执行一次
      -   onShow -- 页面展示时执行，执行多次
      -   onHide -- 页面从前台进入后台时执行
      -   onUnload -- 页面卸载时执行

      组件生命周期

      -   created -> attached -> ready -> detached

    微信小程序

    微信小程序面试题
    常用接口 wx.login  wx.request  1rpx  [`wx.startPullDownRefresh`]
    微信小程序优化 
    基础扎实  js基础
    web性能优化
    
    巨石应用  微前端
    
    函数柯里化
    函数柯里化是把接受多个参数的函数转变成接受一个单一参数(最初函数的第一个参数),并且
    返回接受余下的参数而且返回结果的新函数的技术
    柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。
    这增加了函数的适用性，但同时也降低了函数的适用范围。
    可以参考上面的节流防抖，就是用的函数柯里化

    spa
    SEO  搜索引擎优化
    搜索引擎是如何搜索到页面的
    搜索引擎通过爬虫程序（也称为蜘蛛、机器人等）自动访问互联网上的网站，并将网站的内容、链接等信息存储在数据库中。
    当用户在搜索引擎上输入关键词或查询条件时，搜索引擎会从数据库中找到相关的网页并呈现给用户。

    为什么说spa不利于SEO
    大概就是在搜索到spa的页面的时候，里面都是空白的，所以存到数据里的优先级就低了

    如何SEO
      ssr
      meta标签 description 
      <meta name="keywords" content="Lxxyx,博客，文科生，前端">  用于告诉搜索引擎，你网页的关键字
      <meta name="description" content="文科生，热爱前端与编程。目前大二，这是我的前端博客">  用于告诉搜索引擎，你网站的主要内容
      <meta name="robots" value="index,follow"> robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引

    总之，SPA应用的SEO优化需要采用上述多种方法的综合应用，以便在大大提高用户体验的同时，也能够提高网站在搜索引擎中的排名。

    数组扁平化
    function flatten(arr = []) {  
        return arr.reduce((result, item) => {
            return result.concat(Array.isArray(item) ? flatten(item) : item)
        }, [])
    }

    // (toString | join) & split(利用数组的toString或者join,将数组转化为字符串)
    function flatten(arr = []) {
        return arr.toString().split(',').map(item => Number(item))
    }

    react竞态 和 swr
    react竞态  多个promise如果拿到最新的那个 
    方案1 
      很有意思，利用闭包 + useEffect return
      即使组件没有卸载，cleanup 逻辑也会运行
      cleanup 函数不仅在卸载期间运行，也在每个依赖项变更的重新渲染前运行。

      useEffect(() => {
        let didCancel = false;

        async function fetchData() {
          const article = await API.fetchArticle(id);
          // 如果 didCancel 为 true 说明用户已经取消了
          if (!didCancel) {
            setArticle(article);
          }
        }

        fetchData();

        // 执行下一个 effect 之前会执行
        return () => {
          didCancel = true;
        };
      }, [id]);

    方案2
    使用ahooks 中的 useRequest
    const { data, loading } = useRequest(() => fakeFetch(person), {
      refreshDeps: [person],
    }); 

    方案3
    react.suspense

    Suspense 之所以能够有效的解决 Race Conditions 问题，就在于传统的实现中，我们需要考虑 setState 的正确时机，执行顺序是：1. 请求数据 2. 数据返回 3. setState 数据
    而在 Suspense 中，我们请求后，立刻就设置了 setState，然后就只用等待请求返回，React 执行 Suspense 的再次更新就好了，执行顺序是：1. 请求数据 2. setState 数据 3. 数据返回 4. Suspense 重新渲染，所以大大降低了出错的概率。
    jsx复制代码

    白屏时间计算
    在head头尾各取一个时间相减，或者利用window.performance来计算

    navigationStart - 文档的初始导航（跳转）开始时间
    domLoading - 文档解析开始时间
    domInteractive - 文档解析完成时间
    domContentLoadedEventStart - DOMContentLoaded 事件开始时间
    loadEventStart - 加载事件开始时间

    const performance = window.performance;
    if (performance) {
      const navigationStart = performance.timing.navigationStart;
      const domLoading = performance.timing.domLoading;
      const whiteScreenTime = domLoading - navigationStart;
      console.log('白屏时间：', whiteScreenTime);
    }

    响应式布局  媒体查询 flex布局 宽度百分比

    主题包还是 动态切换主题色还是不一样的
    不同主题包是指有点UI库有不同的主题包，要使用某些loader配合plugin去引入，其实就是一份css文件吧

    不同颜色主题切换的实现方案  
    方案1
      link标签动态引入（或是直接改变href属性）
    方案2
      提前引入所有主题样式，通过切换类名实现
    方案3
      切换类名改变量
      比如 
      /* 定义根作用域下的变量 */
      :root {
        --theme-color: #333;
        --theme-background: #eee;
      }
      /* 更改dark类名下变量的取值 */
      .dark{
        --theme-color: #eee;
        --theme-background: #333;
      }
      /* 更改pink类名下变量的取值 */
      .pink{
        --theme-color: #fff;
        --theme-background: pink;
      }
    css 变量命名  --primary-color: #007bff;  background-color: var(--primary-color);
    scss 变量命名  $primary-color: #007bff;   background-color: $primary-color;
    方案4
      也是通过切换类名
      通过mixin
      /* 定义混合器 */
      @mixin theme($primary, $secondary, $success, $danger, $warning, $info) {
        $primary-color: $primary;
        $secondary-color: $secondary;
        $success-color: $success;
        $danger-color: $danger;
        $warning-color: $warning;
        $info-color: $info;
      }
      .dark-theme {
        @include theme(#000, #666, #0f0, #f00, #ff0, #00f);
      }

      .light-theme {
        @include theme(#fff, #ccc, #0f0, #f00, #ff0, #00f);
      }

    啊哈哈哈 最快的主题切换- 给body加filter: invert(1);
    
    单点登录
    方案1 共享cookie模式  根域名一致  比如a.beiming.com  b.beiming.com  c.beiming.com
    共用 beiming.com 这个根域名  cookie挂在beiming.com上（理论上cookie的生成是服务器做的）就可以共用了
    大厂都是这么玩咯 阿里全是 alibaba.com
    方案2 跨域设置cookie  域名不需要一致了  但是这两种方案cookie都不是很安全
    https://zhuanlan.zhihu.com/p/400317377?utm_id=0
    方案3 客户端模式  要装客户端 成本高
    方案4 oauth2.0  搞一个独立的认证中心
    用户在系统1登录→跳转IDP（认证中心）→用户提交用户名密码→IDP登录成功→用户在IDP域名留下已登录的cookie→IDP跳转回系统1并带上code、
    token一类的凭证→系统1验证凭证，完成登录
    用户在系统2登录→跳转IDP→IDP根据已登录的cookie知道用户已登录→IDP跳转回系统2并带上code、token一类的凭证→系统2验证凭证，完成登录

    token 失效刷新如何实现的，token 和登录的处理
    一直以为是失效就重新登录，但是还有一个刷新token的功能，过期了可以刷新token，就不用重新登录
    但是这个功能应该是要由后端来做的，就是我用了你就得帮我延长token，一小时没用你就让我重新登录
    硬要前端做的话，只能在axios响应拦截里面做处理，需要把请求存起来，等刷新缓存后再发起请求，可是请求之后的对应操作呢，怎么重现，
    这就不知道咯哈哈

    两栏布局实现：flex；定位；grid；float 布局
    
    保证 3 个请求结果顺序显示
    第一个请求 index是 0 请求成功搞个数组 result[0] = 第一个请求的结果
    或者promise.all

    拿到最后一个请求的结果(竞态问题，上面的useEffect也有一个解法)
    外面搞个值
    比如 flagId；
    每个请求生成一个 uniqueId，然后请求的时候 将flagId赋值为 uniqueId，在请求成功的时候比较 外面的flagId === uniqueId，就是最后一个请求
    这里用到了闭包哈，uniqueId是每一个请求独特的id，flagId会被赋值为最后一个请求的uniqueId

    constructor(){
      this.flagId = '';
    }

    request = () => {
      const currentUniqueId = getUniqueId();
      this.flagId = currentUniqueId;
      fetch().then(() => {
        if (this.flagMap.calculateFreight === currentUniqueId) {}
      })
    }

    break 终止整个循环， continue跳出本次循环
    for循环能用break中断，用return中断只能是在函数中（return 语句只能出现在函数体中），其实这里是种中断了函数，不过也确实中断了整个循环
    function add(){
      let list = [1,2,3,4]
      for(var i=0;i<list.length;i++){
        if(i === 2)return;
        console.log(list[i]);  // 1 2
      }
    }
    add()

    forEach和map不能用break中断，使用return，只能跳出本次循环（和continue的效果一样），并不能中断整个循环，想终止整个循环，可以用trycatch
    for in for…in循环主要是为了遍历对象的，break或continue可以生效 和 for of一样
    for in：主要用来遍历对象（for keys in obj） for of遍历不了对象，只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for…of 循环遍历它的成员
    包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、Generator 对象，以及字符串
    
    const obj = { a: 1, b: 2 }
    const a = Object.entries(obj);  [['a', 1], ['b', 2]]

    for in遍历自身和继承的可枚举属性（延续原型链遍历出对象的原型属性）
    有什么问题：要使用 hasOwnProperty 判断，只处理自身的，不处理继承的

    for of也是遍历可枚举，应该不会遍历到原型链上 

    手写 reduce
    Array.prototype.myReduce = function (cb, initValue) {
      const array = this; // 获取数组
      let pre = initValue || array[0];
      const startIndex = initValue ? 1 : 0;
      for (let i = startIndex; i < array.length; i++) {
        const cur = array[i];
        pre = cb(pre, cur, i, array);
      }
      return pre;
    };

    function add() {
      return 10;
    }

    function multiple(a) {
      return a * 10;
    }

    const compose = (...arg) => {
      return function (x) {
        return arg.reduceRight((prev, cur) => {
          return cur(prev)
        }, x)
      }
    }

    // 我们来验证下这个方法
    let calculate = compose(multiple, add);
    let res = calculate(10);
    console.log(res);    // 结果还是200

    组合函数(compose)；管道函数(pipe)   
    redux的compose，loader的从右到左，都是用compose，实现原理是用reduceRight

    function add() {
      return 10;
    }

    function multiple(a) {
      return a * 10;
    }

    const compose = (...arg) => {
      return function (x) {
        return arg.reduceRight((prev, cur) => {
          return cur(prev)
        }, x)
      }
    }

    // 我们来验证下这个方法
    let calculate = compose(multiple, add);
    let res = calculate(10);
    console.log(res);    // 结果还是200

    pipe和compose差不多，只不过是从左到右，用的就是reduce

    const pipe = (...arg) => {
      return function (x) {
        return arg.reduce((prev, cur) => {
          return cur(prev)
        }, x)
      }
    }

    MVC controller  
      1. RESTFUL  提供接口
      2. 根据用户访问的URL 访问不同的HTML   渲染页面
      3. 代理服务器   代理服务器

    元素在页面隐藏的方式
    display:none
    visibility:hidden
    opacity:0
    设置 height、width 模型属性为 0
    position:absolute，将元素移出可视区域
    transform 偏移：同上
    clip-path：裁剪

    数据埋点如何实现
    
    虚拟列表实现，有高度的很简单，比如数据1000条，一条50高度，然后你要展示10条，
    搞个容器5000px，外面搞个总的容器1000条就是500000px，然后数组一直切10条出来展示，
    一开始肯定是第一条到第10条，也就是索引取0到10，后面滚动了，比如滚动了50px，那索引就是
    取1到11了，然后记得1的position：top就是50，因为是相对滚动的

    没高度的有点难搞

    js math 取整
    1. Math.floor() 向下取整
    2. Math.ceil() 向上取整
    3. Math.round() 四舍五入取整
  
    whistle
    # /dev.g.alicdn.com/workstation-apps/neptune/(.*?)/(.*?)/index.js/ http://localhost:7002/$2/index.js

    /dev.g.alicdn.com/workstation-apps/neptune/.+?/(.+)/  http://localhost:7002/$1

    /dev.g.alicdn.com/LABTest/lazada-abtest-manager/.+?/(.+)/  http://localhost:3333/$1

    # New Rules
    https://pre-lab.alibaba-inc.com/api/metric/stat-v3 file://{result.json}   // values中新建result.json

    https://pre-lab.alibaba-inc.com/api/metric/stat-v3 resBody://{test}   // values中新建test

    values
    使用示例
    存储请求头：假设频繁需要使用特定的Authorization值，可以将其存储为一个 value，名称为authHeader，之后，在需要使用
    这个请求头的规则中，引用{authHeader}即可。
    快速改变环境：保存不同环境的API服务器地址为不同的values（如apiDev、apiStage），在规则中通过切换引用的value的名称
    （如使用{apiDev}或{apiStage}），快速实现不同环境间的切换。

